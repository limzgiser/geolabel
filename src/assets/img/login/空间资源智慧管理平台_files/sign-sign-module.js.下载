(window["webpackJsonp_geolabel"] = window["webpackJsonp_geolabel"] || []).push([["sign-sign-module"],{

/***/ "./node_modules/@mapbox/extent/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@mapbox/extent/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = Extent;

function Extent(bbox) {
    if (!(this instanceof Extent)) {
        return new Extent(bbox);
    }
    this._bbox = bbox || [Infinity, Infinity, -Infinity, -Infinity];
    this._valid = !!bbox;
}

Extent.prototype.include = function(ll) {
    this._valid = true;
    this._bbox[0] = Math.min(this._bbox[0], ll[0]);
    this._bbox[1] = Math.min(this._bbox[1], ll[1]);
    this._bbox[2] = Math.max(this._bbox[2], ll[0]);
    this._bbox[3] = Math.max(this._bbox[3], ll[1]);
    return this;
};

Extent.prototype.equals = function(_) {
    var other;
    if (_ instanceof Extent) { other = _.bbox(); } else { other = _; }
    return this._bbox[0] == other[0] &&
        this._bbox[1] == other[1] &&
        this._bbox[2] == other[2] &&
        this._bbox[3] == other[3];
};

Extent.prototype.center = function(_) {
    if (!this._valid) return null;
    return [
        (this._bbox[0] + this._bbox[2]) / 2,
        (this._bbox[1] + this._bbox[3]) / 2]
};

Extent.prototype.union = function(_) {
    this._valid = true;
    var other;
    if (_ instanceof Extent) { other = _.bbox(); } else { other = _; }
    this._bbox[0] = Math.min(this._bbox[0], other[0]);
    this._bbox[1] = Math.min(this._bbox[1], other[1]);
    this._bbox[2] = Math.max(this._bbox[2], other[2]);
    this._bbox[3] = Math.max(this._bbox[3], other[3]);
    return this;
};

Extent.prototype.bbox = function() {
    if (!this._valid) return null;
    return this._bbox;
};

Extent.prototype.contains = function(ll) {
    if (!ll) return this._fastContains();
    if (!this._valid) return null;
    var lon = ll[0], lat = ll[1];
    return this._bbox[0] <= lon &&
        this._bbox[1] <= lat &&
        this._bbox[2] >= lon &&
        this._bbox[3] >= lat;
};

Extent.prototype.intersect = function(_) {
    if (!this._valid) return null;

    var other;
    if (_ instanceof Extent) { other = _.bbox(); } else { other = _; }

    return !(
      this._bbox[0] > other[2] ||
      this._bbox[2] < other[0] ||
      this._bbox[3] < other[1] ||
      this._bbox[1] > other[3]
    );
};

Extent.prototype._fastContains = function() {
    if (!this._valid) return new Function('return null;');
    var body = 'return ' +
        this._bbox[0] + '<= ll[0] &&' +
        this._bbox[1] + '<= ll[1] &&' +
        this._bbox[2] + '>= ll[0] &&' +
        this._bbox[3] + '>= ll[1]';
    return new Function('ll', body);
};

Extent.prototype.polygon = function() {
    if (!this._valid) return null;
    return {
        type: 'Polygon',
        coordinates: [
            [
                // W, S
                [this._bbox[0], this._bbox[1]],
                // E, S
                [this._bbox[2], this._bbox[1]],
                // E, N
                [this._bbox[2], this._bbox[3]],
                // W, N
                [this._bbox[0], this._bbox[3]],
                // W, S
                [this._bbox[0], this._bbox[1]]
            ]
        ]
    };
};


/***/ }),

/***/ "./node_modules/@mapbox/geojson-area/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@mapbox/geojson-area/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var wgs84 = __webpack_require__(/*! wgs84 */ "./node_modules/wgs84/index.js");

module.exports.geometry = geometry;
module.exports.ring = ringArea;

function geometry(_) {
    var area = 0, i;
    switch (_.type) {
        case 'Polygon':
            return polygonArea(_.coordinates);
        case 'MultiPolygon':
            for (i = 0; i < _.coordinates.length; i++) {
                area += polygonArea(_.coordinates[i]);
            }
            return area;
        case 'Point':
        case 'MultiPoint':
        case 'LineString':
        case 'MultiLineString':
            return 0;
        case 'GeometryCollection':
            for (i = 0; i < _.geometries.length; i++) {
                area += geometry(_.geometries[i]);
            }
            return area;
    }
}

function polygonArea(coords) {
    var area = 0;
    if (coords && coords.length > 0) {
        area += Math.abs(ringArea(coords[0]));
        for (var i = 1; i < coords.length; i++) {
            area -= Math.abs(ringArea(coords[i]));
        }
    }
    return area;
}

/**
 * Calculate the approximate area of the polygon were it projected onto
 *     the earth.  Note that this area will be positive if ring is oriented
 *     clockwise, otherwise it will be negative.
 *
 * Reference:
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
 *
 * Returns:
 * {float} The approximate signed geodesic area of the polygon in square
 *     meters.
 */

function ringArea(coords) {
    var p1, p2, p3, lowerIndex, middleIndex, upperIndex, i,
    area = 0,
    coordsLength = coords.length;

    if (coordsLength > 2) {
        for (i = 0; i < coordsLength; i++) {
            if (i === coordsLength - 2) {// i = N-2
                lowerIndex = coordsLength - 2;
                middleIndex = coordsLength -1;
                upperIndex = 0;
            } else if (i === coordsLength - 1) {// i = N-1
                lowerIndex = coordsLength - 1;
                middleIndex = 0;
                upperIndex = 1;
            } else { // i = 0 to N-3
                lowerIndex = i;
                middleIndex = i+1;
                upperIndex = i+2;
            }
            p1 = coords[lowerIndex];
            p2 = coords[middleIndex];
            p3 = coords[upperIndex];
            area += ( rad(p3[0]) - rad(p1[0]) ) * Math.sin( rad(p2[1]));
        }

        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;
    }

    return area;
}

function rad(_) {
    return _ * Math.PI / 180;
}

/***/ }),

/***/ "./node_modules/@mapbox/geojson-coords/flatten.js":
/*!********************************************************!*\
  !*** ./node_modules/@mapbox/geojson-coords/flatten.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function flatten(list) {
    return _flatten(list);

    function _flatten(list) {
        if (Array.isArray(list) && list.length &&
            typeof list[0] === 'number') {
            return [list];
        }
        return list.reduce(function (acc, item) {
            if (Array.isArray(item) && Array.isArray(item[0])) {
                return acc.concat(_flatten(item));
            } else {
                acc.push(item);
                return acc;
            }
        }, []);
    }
};


/***/ }),

/***/ "./node_modules/@mapbox/geojson-coords/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@mapbox/geojson-coords/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var geojsonNormalize = __webpack_require__(/*! @mapbox/geojson-normalize */ "./node_modules/@mapbox/geojson-normalize/index.js"),
    geojsonFlatten = __webpack_require__(/*! geojson-flatten */ "./node_modules/geojson-flatten/dist/index.js"),
    flatten = __webpack_require__(/*! ./flatten */ "./node_modules/@mapbox/geojson-coords/flatten.js");

module.exports = function(_) {
    if (!_) return [];
    var normalized = geojsonFlatten(geojsonNormalize(_)),
        coordinates = [];
    normalized.features.forEach(function(feature) {
        if (!feature.geometry) return;
        coordinates = coordinates.concat(flatten(feature.geometry.coordinates));
    });
    return coordinates;
};


/***/ }),

/***/ "./node_modules/@mapbox/geojson-extent/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@mapbox/geojson-extent/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var geojsonCoords = __webpack_require__(/*! @mapbox/geojson-coords */ "./node_modules/@mapbox/geojson-coords/index.js"),
    traverse = __webpack_require__(/*! traverse */ "./node_modules/traverse/index.js"),
    extent = __webpack_require__(/*! @mapbox/extent */ "./node_modules/@mapbox/extent/index.js");

var geojsonTypesByDataAttributes = {
    features: ['FeatureCollection'],
    coordinates: ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon'],
    geometry: ['Feature'],
    geometries: ['GeometryCollection']
}

var dataAttributes = Object.keys(geojsonTypesByDataAttributes);

module.exports = function(_) {
    return getExtent(_).bbox();
};

module.exports.polygon = function(_) {
    return getExtent(_).polygon();
};

module.exports.bboxify = function(_) {
    return traverse(_).map(function(value) {
        if (!value) return ;

        var isValid = dataAttributes.some(function(attribute){
            if(value[attribute]) {
                return geojsonTypesByDataAttributes[attribute].indexOf(value.type) !== -1;
            }
            return false;
        });

        if(isValid){
            value.bbox = getExtent(value).bbox();
            this.update(value);
        }

    });
};

function getExtent(_) {
    var bbox = [Infinity, Infinity, -Infinity, -Infinity],
        ext = extent(),
        coords = geojsonCoords(_);
    for (var i = 0; i < coords.length; i++) ext.include(coords[i]);
    return ext;
}


/***/ }),

/***/ "./node_modules/@mapbox/geojson-normalize/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@mapbox/geojson-normalize/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = normalize;

var types = {
    Point: 'geometry',
    MultiPoint: 'geometry',
    LineString: 'geometry',
    MultiLineString: 'geometry',
    Polygon: 'geometry',
    MultiPolygon: 'geometry',
    GeometryCollection: 'geometry',
    Feature: 'feature',
    FeatureCollection: 'featurecollection'
};

/**
 * Normalize a GeoJSON feature into a FeatureCollection.
 *
 * @param {object} gj geojson data
 * @returns {object} normalized geojson data
 */
function normalize(gj) {
    if (!gj || !gj.type) return null;
    var type = types[gj.type];
    if (!type) return null;

    if (type === 'geometry') {
        return {
            type: 'FeatureCollection',
            features: [{
                type: 'Feature',
                properties: {},
                geometry: gj
            }]
        };
    } else if (type === 'feature') {
        return {
            type: 'FeatureCollection',
            features: [gj]
        };
    } else if (type === 'featurecollection') {
        return gj;
    }
}


/***/ }),

/***/ "./node_modules/@mapbox/geojsonhint/lib/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@mapbox/geojsonhint/lib/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var jsonlint = __webpack_require__(/*! jsonlint-lines */ "./node_modules/jsonlint-lines/lib/jsonlint.js"),
  geojsonHintObject = __webpack_require__(/*! ./object */ "./node_modules/@mapbox/geojsonhint/lib/object.js");

/**
 * @alias geojsonhint
 * @param {(string|object)} GeoJSON given as a string or as an object
 * @param {Object} options
 * @param {boolean} [options.noDuplicateMembers=true] forbid repeated
 * properties. This is only available for string input, becaused parsed
 * Objects cannot have duplicate properties.
 * @param {boolean} [options.precisionWarning=true] warn if GeoJSON contains
 * unnecessary coordinate precision.
 * @returns {Array<Object>} an array of errors
 */
function hint(str, options) {

    var gj, errors = [];

    if (typeof str === 'object') {
        gj = str;
    } else if (typeof str === 'string') {
        try {
            gj = jsonlint.parse(str);
        } catch(e) {
            var match = e.message.match(/line (\d+)/);
            var lineNumber = parseInt(match[1], 10);
            return [{
                line: lineNumber - 1,
                message: e.message,
                error: e
            }];
        }
    } else {
        return [{
            message: 'Expected string or object as input',
            line: 0
        }];
    }

    errors = errors.concat(geojsonHintObject.hint(gj, options));

    return errors;
}

module.exports.hint = hint;


/***/ }),

/***/ "./node_modules/@mapbox/geojsonhint/lib/object.js":
/*!********************************************************!*\
  !*** ./node_modules/@mapbox/geojsonhint/lib/object.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rightHandRule = __webpack_require__(/*! ./rhr */ "./node_modules/@mapbox/geojsonhint/lib/rhr.js");

/**
 * @alias geojsonhint
 * @param {(string|object)} GeoJSON given as a string or as an object
 * @param {Object} options
 * @param {boolean} [options.noDuplicateMembers=true] forbid repeated
 * properties. This is only available for string input, becaused parsed
 * Objects cannot have duplicate properties.
 * @param {boolean} [options.precisionWarning=true] warn if GeoJSON contains
 * unnecessary coordinate precision.
 * @returns {Array<Object>} an array of errors
 */
function hint(gj, options) {

    var errors = [];
    var precisionWarningCount = 0;
    var maxPrecisionWarnings = 10;
    var maxPrecision = 6;

    function root(_) {

        if ((!options || options.noDuplicateMembers !== false) &&
           _.__duplicateProperties__) {
            errors.push({
                message: 'An object contained duplicate members, making parsing ambigous: ' + _.__duplicateProperties__.join(', '),
                line: _.__line__
            });
        }

        if (requiredProperty(_, 'type', 'string')) {
            return;
        }

        if (!types[_.type]) {
            var expectedType = typesLower[_.type.toLowerCase()];
            if (expectedType !== undefined) {
                errors.push({
                    message: 'Expected ' + expectedType + ' but got ' + _.type + ' (case sensitive)',
                    line: _.__line__
                });
            } else {
                errors.push({
                    message: 'The type ' + _.type + ' is unknown',
                    line: _.__line__
                });
            }
        } else if (_) {
            types[_.type](_);
        }
    }

    function everyIs(_, type) {
        // make a single exception because typeof null === 'object'
        return _.every(function(x) {
            return x !== null && typeof x === type;
        });
    }

    function requiredProperty(_, name, type) {
        if (typeof _[name] === 'undefined') {
            return errors.push({
                message: '"' + name + '" member required',
                line: _.__line__
            });
        } else if (type === 'array') {
            if (!Array.isArray(_[name])) {
                return errors.push({
                    message: '"' + name +
                        '" member should be an array, but is an ' +
                        (typeof _[name]) + ' instead',
                    line: _.__line__
                });
            }
        } else if (type === 'object' && _[name] && _[name].constructor !== Object) {
            return errors.push({
                message: '"' + name +
                    '" member should be ' + (type) +
                    ', but is an ' + (_[name].constructor.name) + ' instead',
                line: _.__line__
            });
        } else if (type && typeof _[name] !== type) {
            return errors.push({
                message: '"' + name +
                    '" member should be ' + (type) +
                    ', but is an ' + (typeof _[name]) + ' instead',
                line: _.__line__
            });
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.3
    function FeatureCollection(featureCollection) {
        crs(featureCollection);
        bbox(featureCollection);
        if (featureCollection.properties !== undefined) {
            errors.push({
                message: 'FeatureCollection object cannot contain a "properties" member',
                line: featureCollection.__line__
            });
        }
        if (featureCollection.coordinates !== undefined) {
            errors.push({
                message: 'FeatureCollection object cannot contain a "coordinates" member',
                line: featureCollection.__line__
            });
        }
        if (!requiredProperty(featureCollection, 'features', 'array')) {
            if (!everyIs(featureCollection.features, 'object')) {
                return errors.push({
                    message: 'Every feature must be an object',
                    line: featureCollection.__line__
                });
            }
            featureCollection.features.forEach(Feature);
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.1.1
    function position(_, line) {
        if (!Array.isArray(_)) {
            return errors.push({
                message: 'position should be an array, is a ' + (typeof _) +
                    ' instead',
                line: _.__line__ || line
            });
        }
        if (_.length < 2) {
            return errors.push({
                message: 'position must have 2 or more elements',
                line: _.__line__ || line
            });
        }
        if (_.length > 3) {
            return errors.push({
                message: 'position should not have more than 3 elements',
                level: 'message',
                line: _.__line__ || line
            });
        }
        if (!everyIs(_, 'number')) {
            return errors.push({
                message: 'each element in a position must be a number',
                line: _.__line__ || line
            });
        }

        if (options && options.precisionWarning) {
            if (precisionWarningCount === maxPrecisionWarnings) {
                precisionWarningCount += 1;
                return errors.push({
                    message: 'truncated warnings: we\'ve encountered coordinate precision warning ' + maxPrecisionWarnings + ' times, no more warnings will be reported',
                    level: 'message',
                    line: _.__line__ || line
                });
            } else if (precisionWarningCount < maxPrecisionWarnings) {
                _.forEach(function(num) {
                    var precision = 0;
                    var decimalStr = String(num).split('.')[1];
                    if (decimalStr !== undefined)
                        precision = decimalStr.length;
                    if (precision > maxPrecision) {
                        precisionWarningCount += 1;
                        return errors.push({
                            message: 'precision of coordinates should be reduced',
                            level: 'message',
                            line: _.__line__ || line
                        });
                    }
                });
            }
        }
    }

    function positionArray(coords, type, depth, line) {
        if (line === undefined && coords.__line__ !== undefined) {
            line = coords.__line__;
        }
        if (depth === 0) {
            return position(coords, line);
        }
        if (depth === 1 && type) {
            if (type === 'LinearRing') {
                if (!Array.isArray(coords[coords.length - 1])) {
                    errors.push({
                        message: 'a number was found where a coordinate array should have been found: this needs to be nested more deeply',
                        line: line
                    });
                    return true;
                }
                if (coords.length < 4) {
                    errors.push({
                        message: 'a LinearRing of coordinates needs to have four or more positions',
                        line: line
                    });
                }
                if (coords.length &&
                    (coords[coords.length - 1].length !== coords[0].length ||
                    !coords[coords.length - 1].every(function(pos, index) {
                        return coords[0][index] === pos;
                }))) {
                    errors.push({
                        message: 'the first and last positions in a LinearRing of coordinates must be the same',
                        line: line
                    });
                    return true;
                }
            } else if (type === 'Line' && coords.length < 2) {
                return errors.push({
                    message: 'a line needs to have two or more coordinates to be valid',
                    line: line
                });
            }
        }
        if (!Array.isArray(coords)) {
            errors.push({
                message: 'a number was found where a coordinate array should have been found: this needs to be nested more deeply',
                line: line
            });
        } else {
            var results = coords.map(function(c) {
                return positionArray(c, type, depth - 1, c.__line__ || line);
            });
            return results.some(function(r) {
                return r;
            });
        }
    }

    function crs(_) {
        if (!_.crs) return;
        var defaultCRSName = 'urn:ogc:def:crs:OGC:1.3:CRS84';
        if (typeof _.crs === 'object' && _.crs.properties && _.crs.properties.name === defaultCRSName) {
            errors.push({
                message: 'old-style crs member is not recommended, this object is equivalent to the default and should be removed',
                line: _.__line__
            });
        } else {
            errors.push({
                message: 'old-style crs member is not recommended',
                line: _.__line__
            });
        }
    }

    function bbox(_) {
        if (!_.bbox) {
            return;
        }
        if (Array.isArray(_.bbox)) {
            if (!everyIs(_.bbox, 'number')) {
                errors.push({
                    message: 'each element in a bbox member must be a number',
                    line: _.bbox.__line__
                });
            }
            if (!(_.bbox.length === 4 || _.bbox.length === 6)) {
                errors.push({
                    message: 'bbox must contain 4 elements (for 2D) or 6 elements (for 3D)',
                    line: _.bbox.__line__
                });
            }
            return errors.length;
        }
        errors.push({
            message: 'bbox member must be an array of numbers, but is a ' + (typeof _.bbox),
            line: _.__line__
        });
    }

    function geometrySemantics(geom) {
        if (geom.properties !== undefined) {
            errors.push({
                message: 'geometry object cannot contain a "properties" member',
                line: geom.__line__
            });
        }
        if (geom.geometry !== undefined) {
            errors.push({
                message: 'geometry object cannot contain a "geometry" member',
                line: geom.__line__
            });
        }
        if (geom.features !== undefined) {
            errors.push({
                message: 'geometry object cannot contain a "features" member',
                line: geom.__line__
            });
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.1.2
    function Point(point) {
        crs(point);
        bbox(point);
        geometrySemantics(point);
        if (!requiredProperty(point, 'coordinates', 'array')) {
            position(point.coordinates);
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.1.6
    function Polygon(polygon) {
        crs(polygon);
        bbox(polygon);
        if (!requiredProperty(polygon, 'coordinates', 'array')) {
            if (!positionArray(polygon.coordinates, 'LinearRing', 2)) {
                rightHandRule(polygon, errors);
            }
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.1.7
    function MultiPolygon(multiPolygon) {
        crs(multiPolygon);
        bbox(multiPolygon);
        if (!requiredProperty(multiPolygon, 'coordinates', 'array')) {
            if (!positionArray(multiPolygon.coordinates, 'LinearRing', 3)) {
                rightHandRule(multiPolygon, errors);
            }
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.1.4
    function LineString(lineString) {
        crs(lineString);
        bbox(lineString);
        if (!requiredProperty(lineString, 'coordinates', 'array')) {
            positionArray(lineString.coordinates, 'Line', 1);
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.1.5
    function MultiLineString(multiLineString) {
        crs(multiLineString);
        bbox(multiLineString);
        if (!requiredProperty(multiLineString, 'coordinates', 'array')) {
            positionArray(multiLineString.coordinates, 'Line', 2);
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.1.3
    function MultiPoint(multiPoint) {
        crs(multiPoint);
        bbox(multiPoint);
        if (!requiredProperty(multiPoint, 'coordinates', 'array')) {
            positionArray(multiPoint.coordinates, '', 1);
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.1.8
    function GeometryCollection(geometryCollection) {
        crs(geometryCollection);
        bbox(geometryCollection);
        if (!requiredProperty(geometryCollection, 'geometries', 'array')) {
            if (!everyIs(geometryCollection.geometries, 'object')) {
                errors.push({
                    message: 'The geometries array in a GeometryCollection must contain only geometry objects',
                    line: geometryCollection.__line__
                });
            }
            if (geometryCollection.geometries.length === 1) {
                errors.push({
                    message: 'GeometryCollection with a single geometry should be avoided in favor of single part or a single object of multi-part type',
                    line: geometryCollection.geometries.__line__
                });
            }
            geometryCollection.geometries.forEach(function(geometry) {
                if (geometry) {
                    if (geometry.type === 'GeometryCollection') {
                        errors.push({
                            message: 'GeometryCollection should avoid nested geometry collections',
                            line: geometryCollection.geometries.__line__
                        });
                    }
                    root(geometry);
                }
            });
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.2
    function Feature(feature) {
        crs(feature);
        bbox(feature);
        // https://github.com/geojson/draft-geojson/blob/master/middle.mkd#feature-object
        if (feature.id !== undefined &&
            typeof feature.id !== 'string' &&
            typeof feature.id !== 'number') {
            errors.push({
                message: 'Feature "id" member must have a string or number value',
                line: feature.__line__
            });
        }
        if (feature.features !== undefined) {
            errors.push({
                message: 'Feature object cannot contain a "features" member',
                line: feature.__line__
            });
        }
        if (feature.coordinates !== undefined) {
            errors.push({
                message: 'Feature object cannot contain a "coordinates" member',
                line: feature.__line__
            });
        }
        if (feature.type !== 'Feature') {
            errors.push({
                message: 'GeoJSON features must have a type=feature member',
                line: feature.__line__
            });
        }
        requiredProperty(feature, 'properties', 'object');
        if (!requiredProperty(feature, 'geometry', 'object')) {
            // https://tools.ietf.org/html/rfc7946#section-3.2
            // tolerate null geometry
            if (feature.geometry) root(feature.geometry);
        }
    }

    var types = {
        Point: Point,
        Feature: Feature,
        MultiPoint: MultiPoint,
        LineString: LineString,
        MultiLineString: MultiLineString,
        FeatureCollection: FeatureCollection,
        GeometryCollection: GeometryCollection,
        Polygon: Polygon,
        MultiPolygon: MultiPolygon
    };

    var typesLower = Object.keys(types).reduce(function(prev, curr) {
        prev[curr.toLowerCase()] = curr;
        return prev;
    }, {});

    if (typeof gj !== 'object' ||
        gj === null ||
        gj === undefined) {
        errors.push({
            message: 'The root of a GeoJSON object must be an object.',
            line: 0
        });
        return errors;
    }

    root(gj);

    errors.forEach(function(err) {
        if ({}.hasOwnProperty.call(err, 'line') && err.line === undefined) {
            delete err.line;
        }
    });

    return errors;
}

module.exports.hint = hint;


/***/ }),

/***/ "./node_modules/@mapbox/geojsonhint/lib/rhr.js":
/*!*****************************************************!*\
  !*** ./node_modules/@mapbox/geojsonhint/lib/rhr.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function rad(x) {
    return x * Math.PI / 180;
}

function isRingClockwise (coords) {
    var area = 0;
    if (coords.length > 2) {
        var p1, p2;
        for (var i = 0; i < coords.length - 1; i++) {
            p1 = coords[i];
            p2 = coords[i + 1];
            area += rad(p2[0] - p1[0]) * (2 + Math.sin(rad(p1[1])) + Math.sin(rad(p2[1])));
        }
    }

    return area >= 0;
}

function isPolyRHR (coords) {
    if (coords && coords.length > 0) {
        if (isRingClockwise(coords[0]))
            return false;
        var interiorCoords = coords.slice(1, coords.length);
        if (!interiorCoords.every(isRingClockwise))
            return false;
    }
    return true;
}

function rightHandRule (geometry) {
    if (geometry.type === 'Polygon') {
        return isPolyRHR(geometry.coordinates);
    } else if (geometry.type === 'MultiPolygon') {
        return geometry.coordinates.every(isPolyRHR);
    }
}

module.exports = function validateRightHandRule(geometry, errors) {
    if (!rightHandRule(geometry)) {
        errors.push({
            message: 'Polygons and MultiPolygons should follow the right-hand rule',
            level: 'message',
            line: geometry.__line__
        });
    }
};


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/index.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_setup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/setup */ "./node_modules/@mapbox/mapbox-gl-draw/src/setup.js");
/* harmony import */ var _src_options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/options */ "./node_modules/@mapbox/mapbox-gl-draw/src/options.js");
/* harmony import */ var _src_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/api */ "./node_modules/@mapbox/mapbox-gl-draw/src/api.js");
/* harmony import */ var _src_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/constants */ "./node_modules/@mapbox/mapbox-gl-draw/src/constants.js");
/* harmony import */ var _src_modes_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/modes/index */ "./node_modules/@mapbox/mapbox-gl-draw/src/modes/index.js");





const setupDraw = function(options, api) {
  options = Object(_src_options__WEBPACK_IMPORTED_MODULE_1__["default"])(options);

  const ctx = {
    options
  };

  api = Object(_src_api__WEBPACK_IMPORTED_MODULE_2__["default"])(ctx, api);
  ctx.api = api;

  const setup = Object(_src_setup__WEBPACK_IMPORTED_MODULE_0__["default"])(ctx);

  api.onAdd = setup.onAdd;
  api.onRemove = setup.onRemove;
  api.types = _src_constants__WEBPACK_IMPORTED_MODULE_3__["types"];
  api.options = options;

  return api;
};

function MapboxDraw(options) {
  setupDraw(options, this);
}


MapboxDraw.modes = _src_modes_index__WEBPACK_IMPORTED_MODULE_4__["default"];

/* harmony default export */ __webpack_exports__["default"] = (MapboxDraw);


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/api.js":
/*!********************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/api.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var lodash_isequal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.isequal */ "./node_modules/lodash.isequal/index.js");
/* harmony import */ var lodash_isequal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isequal__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _mapbox_geojson_normalize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @mapbox/geojson-normalize */ "./node_modules/@mapbox/geojson-normalize/index.js");
/* harmony import */ var _mapbox_geojson_normalize__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_mapbox_geojson_normalize__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var hat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hat */ "./node_modules/hat/index.js");
/* harmony import */ var hat__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(hat__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _lib_features_at__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/features_at */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/features_at.js");
/* harmony import */ var _lib_string_sets_are_equal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/string_sets_are_equal */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/string_sets_are_equal.js");
/* harmony import */ var _mapbox_geojsonhint__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @mapbox/geojsonhint */ "./node_modules/@mapbox/geojsonhint/lib/index.js");
/* harmony import */ var _mapbox_geojsonhint__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_mapbox_geojsonhint__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./constants */ "./node_modules/@mapbox/mapbox-gl-draw/src/constants.js");
/* harmony import */ var _lib_string_set__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/string_set */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/string_set.js");
/* harmony import */ var _feature_types_polygon__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./feature_types/polygon */ "./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/polygon.js");
/* harmony import */ var _feature_types_line_string__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./feature_types/line_string */ "./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/line_string.js");
/* harmony import */ var _feature_types_point__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./feature_types/point */ "./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/point.js");
/* harmony import */ var _feature_types_multi_feature__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./feature_types/multi_feature */ "./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/multi_feature.js");














const featureTypes = {
  Polygon: _feature_types_polygon__WEBPACK_IMPORTED_MODULE_8__["default"],
  LineString: _feature_types_line_string__WEBPACK_IMPORTED_MODULE_9__["default"],
  Point: _feature_types_point__WEBPACK_IMPORTED_MODULE_10__["default"],
  MultiPolygon: _feature_types_multi_feature__WEBPACK_IMPORTED_MODULE_11__["default"],
  MultiLineString: _feature_types_multi_feature__WEBPACK_IMPORTED_MODULE_11__["default"],
  MultiPoint: _feature_types_multi_feature__WEBPACK_IMPORTED_MODULE_11__["default"]
};

/* harmony default export */ __webpack_exports__["default"] = (function(ctx, api) {

  api.modes = _constants__WEBPACK_IMPORTED_MODULE_6__["modes"];

  api.getFeatureIdsAt = function(point) {
    const features = _lib_features_at__WEBPACK_IMPORTED_MODULE_3__["default"].click({ point }, null, ctx);
    return features.map(feature => feature.properties.id);
  };

  api.getSelectedIds = function () {
    return ctx.store.getSelectedIds();
  };

  api.getSelected = function () {
    return {
      type: _constants__WEBPACK_IMPORTED_MODULE_6__["geojsonTypes"].FEATURE_COLLECTION,
      features: ctx.store.getSelectedIds().map(id => ctx.store.get(id)).map(feature => feature.toGeoJSON())
    };
  };

  api.getSelectedPoints = function () {
    return {
      type: _constants__WEBPACK_IMPORTED_MODULE_6__["geojsonTypes"].FEATURE_COLLECTION,
      features: ctx.store.getSelectedCoordinates().map(coordinate => ({
        type: _constants__WEBPACK_IMPORTED_MODULE_6__["geojsonTypes"].FEATURE,
        properties: {},
        geometry: {
          type: _constants__WEBPACK_IMPORTED_MODULE_6__["geojsonTypes"].POINT,
          coordinates: coordinate.coordinates
        }
      }))
    };
  };

  api.set = function(featureCollection) {
    if (featureCollection.type === undefined || featureCollection.type !== _constants__WEBPACK_IMPORTED_MODULE_6__["geojsonTypes"].FEATURE_COLLECTION || !Array.isArray(featureCollection.features)) {
      throw new Error('Invalid FeatureCollection');
    }
    const renderBatch = ctx.store.createRenderBatch();
    let toDelete = ctx.store.getAllIds().slice();
    const newIds = api.add(featureCollection);
    const newIdsLookup = new _lib_string_set__WEBPACK_IMPORTED_MODULE_7__["default"](newIds);

    toDelete = toDelete.filter(id => !newIdsLookup.has(id));
    if (toDelete.length) {
      api.delete(toDelete);
    }

    renderBatch();
    return newIds;
  };

  api.add = function (geojson) {
    const errors = _mapbox_geojsonhint__WEBPACK_IMPORTED_MODULE_5___default.a.hint(geojson, { precisionWarning: false }).filter(e => e.level !== 'message');
    if (errors.length) {
      throw new Error(errors[0].message);
    }
    const featureCollection = JSON.parse(JSON.stringify(_mapbox_geojson_normalize__WEBPACK_IMPORTED_MODULE_1___default()(geojson)));

    const ids = featureCollection.features.map((feature) => {
      feature.id = feature.id || hat__WEBPACK_IMPORTED_MODULE_2___default()();

      if (feature.geometry === null) {
        throw new Error('Invalid geometry: null');
      }

      if (ctx.store.get(feature.id) === undefined || ctx.store.get(feature.id).type !== feature.geometry.type) {
        // If the feature has not yet been created ...
        const Model = featureTypes[feature.geometry.type];
        if (Model === undefined) {
          throw new Error(`Invalid geometry type: ${feature.geometry.type}.`);
        }
        const internalFeature = new Model(ctx, feature);
        ctx.store.add(internalFeature);
      } else {
        // If a feature of that id has already been created, and we are swapping it out ...
        const internalFeature = ctx.store.get(feature.id);
        internalFeature.properties = feature.properties;
        if (!lodash_isequal__WEBPACK_IMPORTED_MODULE_0___default()(internalFeature.getCoordinates(), feature.geometry.coordinates)) {
          internalFeature.incomingCoords(feature.geometry.coordinates);
        }
      }
      return feature.id;
    });

    ctx.store.render();
    return ids;
  };


  api.get = function (id) {
    const feature = ctx.store.get(id);
    if (feature) {
      return feature.toGeoJSON();
    }
  };

  api.getAll = function() {
    return {
      type: _constants__WEBPACK_IMPORTED_MODULE_6__["geojsonTypes"].FEATURE_COLLECTION,
      features: ctx.store.getAll().map(feature => feature.toGeoJSON())
    };
  };

  api.delete = function(featureIds) {
    ctx.store.delete(featureIds, { silent: true });
    // If we were in direct select mode and our selected feature no longer exists
    // (because it was deleted), we need to get out of that mode.
    if (api.getMode() === _constants__WEBPACK_IMPORTED_MODULE_6__["modes"].DIRECT_SELECT && !ctx.store.getSelectedIds().length) {
      ctx.events.changeMode(_constants__WEBPACK_IMPORTED_MODULE_6__["modes"].SIMPLE_SELECT, undefined, { silent: true });
    } else {
      ctx.store.render();
    }

    return api;
  };

  api.deleteAll = function() {
    ctx.store.delete(ctx.store.getAllIds(), { silent: true });
    // If we were in direct select mode, now our selected feature no longer exists,
    // so escape that mode.
    if (api.getMode() === _constants__WEBPACK_IMPORTED_MODULE_6__["modes"].DIRECT_SELECT) {
      ctx.events.changeMode(_constants__WEBPACK_IMPORTED_MODULE_6__["modes"].SIMPLE_SELECT, undefined, { silent: true });
    } else {
      ctx.store.render();
    }

    return api;
  };

  api.changeMode = function(mode, modeOptions = {}) {
    // Avoid changing modes just to re-select what's already selected
    if (mode === _constants__WEBPACK_IMPORTED_MODULE_6__["modes"].SIMPLE_SELECT && api.getMode() === _constants__WEBPACK_IMPORTED_MODULE_6__["modes"].SIMPLE_SELECT) {
      if (Object(_lib_string_sets_are_equal__WEBPACK_IMPORTED_MODULE_4__["default"])((modeOptions.featureIds || []), ctx.store.getSelectedIds())) return api;
      // And if we are changing the selection within simple_select mode, just change the selection,
      // instead of stopping and re-starting the mode
      ctx.store.setSelected(modeOptions.featureIds, { silent: true });
      ctx.store.render();
      return api;
    }

    if (mode === _constants__WEBPACK_IMPORTED_MODULE_6__["modes"].DIRECT_SELECT && api.getMode() === _constants__WEBPACK_IMPORTED_MODULE_6__["modes"].DIRECT_SELECT &&
      modeOptions.featureId === ctx.store.getSelectedIds()[0]) {
      return api;
    }

    ctx.events.changeMode(mode, modeOptions, { silent: true });
    return api;
  };

  api.getMode = function() {
    return ctx.events.getMode();
  };

  api.trash = function() {
    ctx.events.trash({ silent: true });
    return api;
  };

  api.combineFeatures = function() {
    ctx.events.combineFeatures({ silent: true });
    return api;
  };

  api.uncombineFeatures = function() {
    ctx.events.uncombineFeatures({ silent: true });
    return api;
  };

  api.setFeatureProperty = function(featureId, property, value) {
    ctx.store.setFeatureProperty(featureId, property, value);
    return api;
  };

  return api;
});


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/constants.js":
/*!**************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/constants.js ***!
  \**************************************************************/
/*! exports provided: classes, sources, cursors, types, geojsonTypes, modes, events, updateActions, meta, activeStates, interactions, LAT_MIN, LAT_RENDERED_MIN, LAT_MAX, LAT_RENDERED_MAX, LNG_MIN, LNG_MAX */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "classes", function() { return classes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sources", function() { return sources; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cursors", function() { return cursors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "types", function() { return types; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geojsonTypes", function() { return geojsonTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modes", function() { return modes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "events", function() { return events; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateActions", function() { return updateActions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "meta", function() { return meta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "activeStates", function() { return activeStates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interactions", function() { return interactions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LAT_MIN", function() { return LAT_MIN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LAT_RENDERED_MIN", function() { return LAT_RENDERED_MIN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LAT_MAX", function() { return LAT_MAX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LAT_RENDERED_MAX", function() { return LAT_RENDERED_MAX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LNG_MIN", function() { return LNG_MIN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LNG_MAX", function() { return LNG_MAX; });
const classes = {
  CONTROL_BASE: 'mapboxgl-ctrl',
  CONTROL_PREFIX: 'mapboxgl-ctrl-',
  CONTROL_BUTTON: 'mapbox-gl-draw_ctrl-draw-btn',
  CONTROL_BUTTON_LINE: 'mapbox-gl-draw_line',
  CONTROL_BUTTON_POLYGON: 'mapbox-gl-draw_polygon',
  CONTROL_BUTTON_POINT: 'mapbox-gl-draw_point',
  CONTROL_BUTTON_TRASH: 'mapbox-gl-draw_trash',
  CONTROL_BUTTON_COMBINE_FEATURES: 'mapbox-gl-draw_combine',
  CONTROL_BUTTON_UNCOMBINE_FEATURES: 'mapbox-gl-draw_uncombine',
  CONTROL_GROUP: 'mapboxgl-ctrl-group',
  ATTRIBUTION: 'mapboxgl-ctrl-attrib',
  ACTIVE_BUTTON: 'active',
  BOX_SELECT: 'mapbox-gl-draw_boxselect'
};

const sources = {
  HOT: 'mapbox-gl-draw-hot',
  COLD: 'mapbox-gl-draw-cold'
};

const cursors = {
  ADD: 'add',
  MOVE: 'move',
  DRAG: 'drag',
  POINTER: 'pointer',
  NONE: 'none'
};

const types = {
  POLYGON: 'polygon',
  LINE: 'line_string',
  POINT: 'point'
};

const geojsonTypes = {
  FEATURE: 'Feature',
  POLYGON: 'Polygon',
  LINE_STRING: 'LineString',
  POINT: 'Point',
  FEATURE_COLLECTION: 'FeatureCollection',
  MULTI_PREFIX: 'Multi',
  MULTI_POINT: 'MultiPoint',
  MULTI_LINE_STRING: 'MultiLineString',
  MULTI_POLYGON: 'MultiPolygon'
};

const modes = {
  DRAW_LINE_STRING: 'draw_line_string',
  DRAW_POLYGON: 'draw_polygon',
  DRAW_POINT: 'draw_point',
  SIMPLE_SELECT: 'simple_select',
  DIRECT_SELECT: 'direct_select',
  STATIC: 'static'
};

const events = {
  CREATE: 'draw.create',
  DELETE: 'draw.delete',
  UPDATE: 'draw.update',
  SELECTION_CHANGE: 'draw.selectionchange',
  MODE_CHANGE: 'draw.modechange',
  ACTIONABLE: 'draw.actionable',
  RENDER: 'draw.render',
  COMBINE_FEATURES: 'draw.combine',
  UNCOMBINE_FEATURES: 'draw.uncombine'
};

const updateActions = {
  MOVE: 'move',
  CHANGE_COORDINATES: 'change_coordinates'
};

const meta = {
  FEATURE: 'feature',
  MIDPOINT: 'midpoint',
  VERTEX: 'vertex'
};

const activeStates = {
  ACTIVE: 'true',
  INACTIVE: 'false'
};

const interactions = [
  'scrollZoom',
  'boxZoom',
  'dragRotate',
  'dragPan',
  'keyboard',
  'doubleClickZoom',
  'touchZoomRotate'
];

const LAT_MIN = -90;
const LAT_RENDERED_MIN = -85;
const LAT_MAX = 90;
const LAT_RENDERED_MAX = 85;
const LNG_MIN = -270;
const LNG_MAX = 270;


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/events.js":
/*!***********************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/events.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_mode_handler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/mode_handler */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/mode_handler.js");
/* harmony import */ var _lib_get_features_and_set_cursor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/get_features_and_set_cursor */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/get_features_and_set_cursor.js");
/* harmony import */ var _lib_features_at__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/features_at */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/features_at.js");
/* harmony import */ var _lib_is_click__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/is_click */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/is_click.js");
/* harmony import */ var _lib_is_tap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/is_tap */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/is_tap.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants */ "./node_modules/@mapbox/mapbox-gl-draw/src/constants.js");
/* harmony import */ var _modes_object_to_mode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modes/object_to_mode */ "./node_modules/@mapbox/mapbox-gl-draw/src/modes/object_to_mode.js");








/* harmony default export */ __webpack_exports__["default"] = (function(ctx) {

  const modes = Object.keys(ctx.options.modes).reduce((m, k) => {
    m[k] = Object(_modes_object_to_mode__WEBPACK_IMPORTED_MODULE_6__["default"])(ctx.options.modes[k]);
    return m;
  }, {});

  let mouseDownInfo = {};
  let touchStartInfo = {};
  const events = {};
  let currentModeName = null;
  let currentMode = null;

  events.drag = function(event, isDrag) {
    if (isDrag({
      point: event.point,
      time: new Date().getTime()
    })) {
      ctx.ui.queueMapClasses({ mouse: _constants__WEBPACK_IMPORTED_MODULE_5__["cursors"].DRAG });
      currentMode.drag(event);
    } else {
      event.originalEvent.stopPropagation();
    }
  };

  events.mousedrag = function(event) {
    events.drag(event, endInfo => !Object(_lib_is_click__WEBPACK_IMPORTED_MODULE_3__["default"])(mouseDownInfo, endInfo));
  };

  events.touchdrag = function(event) {
    events.drag(event, endInfo => !Object(_lib_is_tap__WEBPACK_IMPORTED_MODULE_4__["default"])(touchStartInfo, endInfo));
  };

  events.mousemove = function(event) {
    const button = event.originalEvent.buttons !== undefined ? event.originalEvent.buttons : event.originalEvent.which;
    if (button === 1) {
      return events.mousedrag(event);
    }
    const target = Object(_lib_get_features_and_set_cursor__WEBPACK_IMPORTED_MODULE_1__["default"])(event, ctx);
    event.featureTarget = target;
    currentMode.mousemove(event);
  };

  events.mousedown = function(event) {
    mouseDownInfo = {
      time: new Date().getTime(),
      point: event.point
    };
    const target = Object(_lib_get_features_and_set_cursor__WEBPACK_IMPORTED_MODULE_1__["default"])(event, ctx);
    event.featureTarget = target;
    currentMode.mousedown(event);
  };

  events.mouseup = function(event) {
    const target = Object(_lib_get_features_and_set_cursor__WEBPACK_IMPORTED_MODULE_1__["default"])(event, ctx);
    event.featureTarget = target;

    if (Object(_lib_is_click__WEBPACK_IMPORTED_MODULE_3__["default"])(mouseDownInfo, {
      point: event.point,
      time: new Date().getTime()
    })) {
      currentMode.click(event);
    } else {
      currentMode.mouseup(event);
    }
  };

  events.mouseout = function(event) {
    currentMode.mouseout(event);
  };

  events.touchstart = function(event) {
    // Prevent emulated mouse events because we will fully handle the touch here.
    // This does not stop the touch events from propogating to mapbox though.
    event.originalEvent.preventDefault();
    if (!ctx.options.touchEnabled) {
      return;
    }

    touchStartInfo = {
      time: new Date().getTime(),
      point: event.point
    };
    const target = _lib_features_at__WEBPACK_IMPORTED_MODULE_2__["default"].touch(event, null, ctx)[0];
    event.featureTarget = target;
    currentMode.touchstart(event);
  };

  events.touchmove = function(event) {
    event.originalEvent.preventDefault();
    if (!ctx.options.touchEnabled) {
      return;
    }

    currentMode.touchmove(event);
    return events.touchdrag(event);
  };

  events.touchend = function(event) {
    event.originalEvent.preventDefault();
    if (!ctx.options.touchEnabled) {
      return;
    }

    const target = _lib_features_at__WEBPACK_IMPORTED_MODULE_2__["default"].touch(event, null, ctx)[0];
    event.featureTarget = target;
    if (Object(_lib_is_tap__WEBPACK_IMPORTED_MODULE_4__["default"])(touchStartInfo, {
      time: new Date().getTime(),
      point: event.point
    })) {
      currentMode.tap(event);
    } else {
      currentMode.touchend(event);
    }
  };

  // 8 - Backspace
  // 46 - Delete
  const isKeyModeValid = code => !(code === 8 || code === 46 || (code >= 48 && code <= 57));

  events.keydown = function(event) {
    if ((event.srcElement || event.target).classList[0] !== 'mapboxgl-canvas') return; // we only handle events on the map

    if ((event.keyCode === 8 || event.keyCode === 46) && ctx.options.controls.trash) {
      event.preventDefault();
      currentMode.trash();
    } else if (isKeyModeValid(event.keyCode)) {
      currentMode.keydown(event);
    } else if (event.keyCode === 49 && ctx.options.controls.point) {
      changeMode(_constants__WEBPACK_IMPORTED_MODULE_5__["modes"].DRAW_POINT);
    } else if (event.keyCode === 50 && ctx.options.controls.line_string) {
      changeMode(_constants__WEBPACK_IMPORTED_MODULE_5__["modes"].DRAW_LINE_STRING);
    } else if (event.keyCode === 51 && ctx.options.controls.polygon) {
      changeMode(_constants__WEBPACK_IMPORTED_MODULE_5__["modes"].DRAW_POLYGON);
    }
  };

  events.keyup = function(event) {
    if (isKeyModeValid(event.keyCode)) {
      currentMode.keyup(event);
    }
  };

  events.zoomend = function() {
    ctx.store.changeZoom();
  };

  events.data = function(event) {
    if (event.dataType === 'style') {
      const { setup, map, options, store } = ctx;
      const hasLayers = options.styles.some(style => map.getLayer(style.id));
      if (!hasLayers) {
        setup.addLayers();
        store.setDirty();
        store.render();
      }
    }
  };

  function changeMode(modename, nextModeOptions, eventOptions = {}) {
    currentMode.stop();

    const modebuilder = modes[modename];
    if (modebuilder === undefined) {
      throw new Error(`${modename} is not valid`);
    }
    currentModeName = modename;
    const mode = modebuilder(ctx, nextModeOptions);
    currentMode = Object(_lib_mode_handler__WEBPACK_IMPORTED_MODULE_0__["default"])(mode, ctx);

    if (!eventOptions.silent) {
      ctx.map.fire(_constants__WEBPACK_IMPORTED_MODULE_5__["events"].MODE_CHANGE, { mode: modename});
    }

    ctx.store.setDirty();
    ctx.store.render();
  }

  const actionState = {
    trash: false,
    combineFeatures: false,
    uncombineFeatures: false
  };

  function actionable(actions) {
    let changed = false;
    Object.keys(actions).forEach((action) => {
      if (actionState[action] === undefined) throw new Error('Invalid action type');
      if (actionState[action] !== actions[action]) changed = true;
      actionState[action] = actions[action];
    });
    if (changed) ctx.map.fire(_constants__WEBPACK_IMPORTED_MODULE_5__["events"].ACTIONABLE, { actions: actionState });
  }

  const api = {
    start() {
      currentModeName = ctx.options.defaultMode;
      currentMode = Object(_lib_mode_handler__WEBPACK_IMPORTED_MODULE_0__["default"])(modes[currentModeName](ctx), ctx);
    },
    changeMode,
    actionable,
    currentModeName() {
      return currentModeName;
    },
    currentModeRender(geojson, push) {
      return currentMode.render(geojson, push);
    },
    fire(name, event) {
      if (events[name]) {
        events[name](event);
      }
    },
    addEventListeners() {
      ctx.map.on('mousemove', events.mousemove);
      ctx.map.on('mousedown', events.mousedown);
      ctx.map.on('mouseup', events.mouseup);
      ctx.map.on('data', events.data);

      ctx.map.on('touchmove', events.touchmove);
      ctx.map.on('touchstart', events.touchstart);
      ctx.map.on('touchend', events.touchend);

      ctx.container.addEventListener('mouseout', events.mouseout);

      if (ctx.options.keybindings) {
        ctx.container.addEventListener('keydown', events.keydown);
        ctx.container.addEventListener('keyup', events.keyup);
      }
    },
    removeEventListeners() {
      ctx.map.off('mousemove', events.mousemove);
      ctx.map.off('mousedown', events.mousedown);
      ctx.map.off('mouseup', events.mouseup);
      ctx.map.off('data', events.data);

      ctx.map.off('touchmove', events.touchmove);
      ctx.map.off('touchstart', events.touchstart);
      ctx.map.off('touchend', events.touchend);

      ctx.container.removeEventListener('mouseout', events.mouseout);

      if (ctx.options.keybindings) {
        ctx.container.removeEventListener('keydown', events.keydown);
        ctx.container.removeEventListener('keyup', events.keyup);
      }
    },
    trash(options) {
      currentMode.trash(options);
    },
    combineFeatures() {
      currentMode.combineFeatures();
    },
    uncombineFeatures() {
      currentMode.uncombineFeatures();
    },
    getMode() {
      return currentModeName;
    }
  };

  return api;
});


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/feature.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/feature.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var hat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hat */ "./node_modules/hat/index.js");
/* harmony import */ var hat__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(hat__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ "./node_modules/@mapbox/mapbox-gl-draw/src/constants.js");



const Feature = function(ctx, geojson) {
  this.ctx = ctx;
  this.properties = geojson.properties || {};
  this.coordinates = geojson.geometry.coordinates;
  this.id = geojson.id || hat__WEBPACK_IMPORTED_MODULE_0___default()();
  this.type = geojson.geometry.type;
};

Feature.prototype.changed = function() {
  this.ctx.store.featureChanged(this.id);
};

Feature.prototype.incomingCoords = function(coords) {
  this.setCoordinates(coords);
};

Feature.prototype.setCoordinates = function(coords) {
  this.coordinates = coords;
  this.changed();
};

Feature.prototype.getCoordinates = function() {
  return JSON.parse(JSON.stringify(this.coordinates));
};

Feature.prototype.setProperty = function(property, value) {
  this.properties[property] = value;
};

Feature.prototype.toGeoJSON = function() {
  return JSON.parse(JSON.stringify({
    id: this.id,
    type: _constants__WEBPACK_IMPORTED_MODULE_1__["geojsonTypes"].FEATURE,
    properties: this.properties,
    geometry: {
      coordinates: this.getCoordinates(),
      type: this.type
    }
  }));
};

Feature.prototype.internal = function(mode) {
  const properties = {
    id: this.id,
    meta: _constants__WEBPACK_IMPORTED_MODULE_1__["meta"].FEATURE,
    'meta:type': this.type,
    active: _constants__WEBPACK_IMPORTED_MODULE_1__["activeStates"].INACTIVE,
    mode
  };

  if (this.ctx.options.userProperties) {
    for (const name in this.properties) {
      properties[`user_${name}`] = this.properties[name];
    }
  }

  return {
    type: _constants__WEBPACK_IMPORTED_MODULE_1__["geojsonTypes"].FEATURE,
    properties,
    geometry: {
      coordinates: this.getCoordinates(),
      type: this.type
    }
  };
};

/* harmony default export */ __webpack_exports__["default"] = (Feature);


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/line_string.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/line_string.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _feature__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature */ "./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/feature.js");


const LineString = function(ctx, geojson) {
  _feature__WEBPACK_IMPORTED_MODULE_0__["default"].call(this, ctx, geojson);
};

LineString.prototype = Object.create(_feature__WEBPACK_IMPORTED_MODULE_0__["default"].prototype);

LineString.prototype.isValid = function() {
  return this.coordinates.length > 1;
};

LineString.prototype.addCoordinate = function(path, lng, lat) {
  this.changed();
  const id = parseInt(path, 10);
  this.coordinates.splice(id, 0, [lng, lat]);
};

LineString.prototype.getCoordinate = function(path) {
  const id = parseInt(path, 10);
  return JSON.parse(JSON.stringify(this.coordinates[id]));
};

LineString.prototype.removeCoordinate = function(path) {
  this.changed();
  this.coordinates.splice(parseInt(path, 10), 1);
};

LineString.prototype.updateCoordinate = function(path, lng, lat) {
  const id = parseInt(path, 10);
  this.coordinates[id] = [lng, lat];
  this.changed();
};

/* harmony default export */ __webpack_exports__["default"] = (LineString);


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/multi_feature.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/multi_feature.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _feature__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature */ "./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/feature.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ "./node_modules/@mapbox/mapbox-gl-draw/src/constants.js");
/* harmony import */ var hat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hat */ "./node_modules/hat/index.js");
/* harmony import */ var hat__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(hat__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./point */ "./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/point.js");
/* harmony import */ var _line_string__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line_string */ "./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/line_string.js");
/* harmony import */ var _polygon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./polygon */ "./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/polygon.js");








const models = {
  MultiPoint: _point__WEBPACK_IMPORTED_MODULE_3__["default"],
  MultiLineString: _line_string__WEBPACK_IMPORTED_MODULE_4__["default"],
  MultiPolygon: _polygon__WEBPACK_IMPORTED_MODULE_5__["default"]
};

const takeAction = (features, action, path, lng, lat) => {
  const parts = path.split('.');
  const idx = parseInt(parts[0], 10);
  const tail = (!parts[1]) ? null : parts.slice(1).join('.');
  return features[idx][action](tail, lng, lat);
};

const MultiFeature = function(ctx, geojson) {
  _feature__WEBPACK_IMPORTED_MODULE_0__["default"].call(this, ctx, geojson);

  delete this.coordinates;
  this.model = models[geojson.geometry.type];
  if (this.model === undefined) throw new TypeError(`${geojson.geometry.type} is not a valid type`);
  this.features = this._coordinatesToFeatures(geojson.geometry.coordinates);
};

MultiFeature.prototype = Object.create(_feature__WEBPACK_IMPORTED_MODULE_0__["default"].prototype);

MultiFeature.prototype._coordinatesToFeatures = function(coordinates) {
  const Model = this.model.bind(this);
  return coordinates.map(coords => new Model(this.ctx, {
    id: hat__WEBPACK_IMPORTED_MODULE_2___default()(),
    type: _constants__WEBPACK_IMPORTED_MODULE_1__["geojsonTypes"].FEATURE,
    properties: {},
    geometry: {
      coordinates: coords,
      type: this.type.replace('Multi', '')
    }
  }));
};

MultiFeature.prototype.isValid = function() {
  return this.features.every(f => f.isValid());
};

MultiFeature.prototype.setCoordinates = function(coords) {
  this.features = this._coordinatesToFeatures(coords);
  this.changed();
};

MultiFeature.prototype.getCoordinate = function(path) {
  return takeAction(this.features, 'getCoordinate', path);
};

MultiFeature.prototype.getCoordinates = function() {
  return JSON.parse(JSON.stringify(this.features.map((f) => {
    if (f.type === _constants__WEBPACK_IMPORTED_MODULE_1__["geojsonTypes"].POLYGON) return f.getCoordinates();
    return f.coordinates;
  })));
};

MultiFeature.prototype.updateCoordinate = function(path, lng, lat) {
  takeAction(this.features, 'updateCoordinate', path, lng, lat);
  this.changed();
};

MultiFeature.prototype.addCoordinate = function(path, lng, lat) {
  takeAction(this.features, 'addCoordinate', path, lng, lat);
  this.changed();
};

MultiFeature.prototype.removeCoordinate = function(path) {
  takeAction(this.features, 'removeCoordinate', path);
  this.changed();
};

MultiFeature.prototype.getFeatures = function() {
  return this.features;
};

/* harmony default export */ __webpack_exports__["default"] = (MultiFeature);


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/point.js":
/*!************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/point.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _feature__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature */ "./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/feature.js");


const Point = function(ctx, geojson) {
  _feature__WEBPACK_IMPORTED_MODULE_0__["default"].call(this, ctx, geojson);
};

Point.prototype = Object.create(_feature__WEBPACK_IMPORTED_MODULE_0__["default"].prototype);

Point.prototype.isValid = function() {
  return typeof this.coordinates[0] === 'number' &&
    typeof this.coordinates[1] === 'number';
};

Point.prototype.updateCoordinate = function(pathOrLng, lngOrLat, lat) {
  if (arguments.length === 3) {
    this.coordinates = [lngOrLat, lat];
  } else {
    this.coordinates = [pathOrLng, lngOrLat];
  }
  this.changed();
};

Point.prototype.getCoordinate = function() {
  return this.getCoordinates();
};

/* harmony default export */ __webpack_exports__["default"] = (Point);


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/polygon.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/polygon.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _feature__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature */ "./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/feature.js");


const Polygon = function(ctx, geojson) {
  _feature__WEBPACK_IMPORTED_MODULE_0__["default"].call(this, ctx, geojson);
  this.coordinates = this.coordinates.map(ring => ring.slice(0, -1));
};

Polygon.prototype = Object.create(_feature__WEBPACK_IMPORTED_MODULE_0__["default"].prototype);

Polygon.prototype.isValid = function() {
  if (this.coordinates.length === 0) return false;
  return this.coordinates.every(ring => ring.length > 2);
};

// Expects valid geoJSON polygon geometry: first and last positions must be equivalent.
Polygon.prototype.incomingCoords = function(coords) {
  this.coordinates = coords.map(ring => ring.slice(0, -1));
  this.changed();
};

// Does NOT expect valid geoJSON polygon geometry: first and last positions should not be equivalent.
Polygon.prototype.setCoordinates = function(coords) {
  this.coordinates = coords;
  this.changed();
};

Polygon.prototype.addCoordinate = function(path, lng, lat) {
  this.changed();
  const ids = path.split('.').map(x => parseInt(x, 10));

  const ring = this.coordinates[ids[0]];

  ring.splice(ids[1], 0, [lng, lat]);
};

Polygon.prototype.removeCoordinate = function(path) {
  this.changed();
  const ids = path.split('.').map(x => parseInt(x, 10));
  const ring = this.coordinates[ids[0]];
  if (ring) {
    ring.splice(ids[1], 1);
    if (ring.length < 3) {
      this.coordinates.splice(ids[0], 1);
    }
  }
};

Polygon.prototype.getCoordinate = function(path) {
  const ids = path.split('.').map(x => parseInt(x, 10));
  const ring = this.coordinates[ids[0]];
  return JSON.parse(JSON.stringify(ring[ids[1]]));
};

Polygon.prototype.getCoordinates = function() {
  return this.coordinates.map(coords => coords.concat([coords[0]]));
};

Polygon.prototype.updateCoordinate = function(path, lng, lat) {
  this.changed();
  const parts = path.split('.');
  const ringId = parseInt(parts[0], 10);
  const coordId = parseInt(parts[1], 10);

  if (this.coordinates[ringId] === undefined) {
    this.coordinates[ringId] = [];
  }

  this.coordinates[ringId][coordId] = [lng, lat];
};

/* harmony default export */ __webpack_exports__["default"] = (Polygon);


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/common_selectors.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/lib/common_selectors.js ***!
  \*************************************************************************/
/*! exports provided: isOfMetaType, isShiftMousedown, isActiveFeature, isInactiveFeature, noTarget, isFeature, isVertex, isShiftDown, isEscapeKey, isEnterKey, isTrue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isOfMetaType", function() { return isOfMetaType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isShiftMousedown", function() { return isShiftMousedown; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isActiveFeature", function() { return isActiveFeature; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isInactiveFeature", function() { return isInactiveFeature; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "noTarget", function() { return noTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFeature", function() { return isFeature; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isVertex", function() { return isVertex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isShiftDown", function() { return isShiftDown; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEscapeKey", function() { return isEscapeKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEnterKey", function() { return isEnterKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTrue", function() { return isTrue; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants */ "./node_modules/@mapbox/mapbox-gl-draw/src/constants.js");


function isOfMetaType(type) {
  return function(e) {
    const featureTarget = e.featureTarget;
    if (!featureTarget) return false;
    if (!featureTarget.properties) return false;
    return featureTarget.properties.meta === type;
  };
}

function isShiftMousedown(e) {
  if (!e.originalEvent) return false;
  if (!e.originalEvent.shiftKey) return false;
  return e.originalEvent.button === 0;
}

function isActiveFeature(e) {
  if (!e.featureTarget) return false;
  if (!e.featureTarget.properties) return false;
  return e.featureTarget.properties.active === _constants__WEBPACK_IMPORTED_MODULE_0__["activeStates"].ACTIVE &&
    e.featureTarget.properties.meta === _constants__WEBPACK_IMPORTED_MODULE_0__["meta"].FEATURE;
}

function isInactiveFeature(e) {
  if (!e.featureTarget) return false;
  if (!e.featureTarget.properties) return false;
  return e.featureTarget.properties.active === _constants__WEBPACK_IMPORTED_MODULE_0__["activeStates"].INACTIVE &&
    e.featureTarget.properties.meta === _constants__WEBPACK_IMPORTED_MODULE_0__["meta"].FEATURE;
}

function noTarget(e) {
  return e.featureTarget === undefined;
}

function isFeature(e) {
  if (!e.featureTarget) return false;
  if (!e.featureTarget.properties) return false;
  return e.featureTarget.properties.meta === _constants__WEBPACK_IMPORTED_MODULE_0__["meta"].FEATURE;
}

function isVertex(e) {
  const featureTarget = e.featureTarget;
  if (!featureTarget) return false;
  if (!featureTarget.properties) return false;
  return featureTarget.properties.meta === _constants__WEBPACK_IMPORTED_MODULE_0__["meta"].VERTEX;
}

function isShiftDown(e) {
  if (!e.originalEvent) return false;
  return e.originalEvent.shiftKey === true;
}

function isEscapeKey(e) {
  return e.keyCode === 27;
}

function isEnterKey(e) {
  return e.keyCode === 13;
}

function isTrue() {
  return true;
}


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/constrain_feature_movement.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/lib/constrain_feature_movement.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mapbox_geojson_extent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @mapbox/geojson-extent */ "./node_modules/@mapbox/geojson-extent/index.js");
/* harmony import */ var _mapbox_geojson_extent__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mapbox_geojson_extent__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ "./node_modules/@mapbox/mapbox-gl-draw/src/constants.js");



const {
  LAT_MIN,
  LAT_MAX,
  LAT_RENDERED_MIN,
  LAT_RENDERED_MAX,
  LNG_MIN,
  LNG_MAX
} = _constants__WEBPACK_IMPORTED_MODULE_1__;

// Ensure that we do not drag north-south far enough for
// - any part of any feature to exceed the poles
// - any feature to be completely lost in the space between the projection's
//   edge and the poles, such that it couldn't be re-selected and moved back
/* harmony default export */ __webpack_exports__["default"] = (function(geojsonFeatures, delta) {
  // "inner edge" = a feature's latitude closest to the equator
  let northInnerEdge = LAT_MIN;
  let southInnerEdge = LAT_MAX;
  // "outer edge" = a feature's latitude furthest from the equator
  let northOuterEdge = LAT_MIN;
  let southOuterEdge = LAT_MAX;

  let westEdge = LNG_MAX;
  let eastEdge = LNG_MIN;

  geojsonFeatures.forEach((feature) => {
    const bounds = _mapbox_geojson_extent__WEBPACK_IMPORTED_MODULE_0___default()(feature);
    const featureSouthEdge = bounds[1];
    const featureNorthEdge = bounds[3];
    const featureWestEdge = bounds[0];
    const featureEastEdge = bounds[2];
    if (featureSouthEdge > northInnerEdge) northInnerEdge = featureSouthEdge;
    if (featureNorthEdge < southInnerEdge) southInnerEdge = featureNorthEdge;
    if (featureNorthEdge > northOuterEdge) northOuterEdge = featureNorthEdge;
    if (featureSouthEdge < southOuterEdge) southOuterEdge = featureSouthEdge;
    if (featureWestEdge < westEdge) westEdge = featureWestEdge;
    if (featureEastEdge > eastEdge) eastEdge = featureEastEdge;
  });


  // These changes are not mutually exclusive: we might hit the inner
  // edge but also have hit the outer edge and therefore need
  // another readjustment
  const constrainedDelta = delta;
  if (northInnerEdge + constrainedDelta.lat > LAT_RENDERED_MAX) {
    constrainedDelta.lat = LAT_RENDERED_MAX - northInnerEdge;
  }
  if (northOuterEdge + constrainedDelta.lat > LAT_MAX) {
    constrainedDelta.lat = LAT_MAX - northOuterEdge;
  }
  if (southInnerEdge + constrainedDelta.lat < LAT_RENDERED_MIN) {
    constrainedDelta.lat = LAT_RENDERED_MIN - southInnerEdge;
  }
  if (southOuterEdge + constrainedDelta.lat < LAT_MIN) {
    constrainedDelta.lat = LAT_MIN - southOuterEdge;
  }
  if (westEdge + constrainedDelta.lng <= LNG_MIN) {
    constrainedDelta.lng += Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;
  }
  if (eastEdge + constrainedDelta.lng >= LNG_MAX) {
    constrainedDelta.lng -= Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;
  }

  return constrainedDelta;
});


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/create_midpoint.js":
/*!************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/lib/create_midpoint.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants */ "./node_modules/@mapbox/mapbox-gl-draw/src/constants.js");


/* harmony default export */ __webpack_exports__["default"] = (function(parent, startVertex, endVertex, map) {
  const startCoord = startVertex.geometry.coordinates;
  const endCoord = endVertex.geometry.coordinates;

  // If a coordinate exceeds the projection, we can't calculate a midpoint,
  // so run away
  if (startCoord[1] > _constants__WEBPACK_IMPORTED_MODULE_0__["LAT_RENDERED_MAX"] ||
    startCoord[1] < _constants__WEBPACK_IMPORTED_MODULE_0__["LAT_RENDERED_MIN"] ||
    endCoord[1] > _constants__WEBPACK_IMPORTED_MODULE_0__["LAT_RENDERED_MAX"] ||
    endCoord[1] < _constants__WEBPACK_IMPORTED_MODULE_0__["LAT_RENDERED_MIN"]) {
    return null;
  }

  const ptA = map.project([ startCoord[0], startCoord[1] ]);
  const ptB = map.project([ endCoord[0], endCoord[1] ]);
  const mid = map.unproject([ (ptA.x + ptB.x) / 2, (ptA.y + ptB.y) / 2 ]);

  return {
    type: _constants__WEBPACK_IMPORTED_MODULE_0__["geojsonTypes"].FEATURE,
    properties: {
      meta: _constants__WEBPACK_IMPORTED_MODULE_0__["meta"].MIDPOINT,
      parent,
      lng: mid.lng,
      lat: mid.lat,
      coord_path: endVertex.properties.coord_path
    },
    geometry: {
      type: _constants__WEBPACK_IMPORTED_MODULE_0__["geojsonTypes"].POINT,
      coordinates: [mid.lng, mid.lat]
    }
  };
});


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/create_supplementary_points.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/lib/create_supplementary_points.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _create_vertex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./create_vertex */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/create_vertex.js");
/* harmony import */ var _create_midpoint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./create_midpoint */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/create_midpoint.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants */ "./node_modules/@mapbox/mapbox-gl-draw/src/constants.js");




function createSupplementaryPoints(geojson, options = {}, basePath = null) {
  const { type, coordinates } = geojson.geometry;
  const featureId = geojson.properties && geojson.properties.id;

  let supplementaryPoints = [];

  if (type === _constants__WEBPACK_IMPORTED_MODULE_2__["geojsonTypes"].POINT) {
    // For points, just create a vertex
    supplementaryPoints.push(Object(_create_vertex__WEBPACK_IMPORTED_MODULE_0__["default"])(featureId, coordinates, basePath, isSelectedPath(basePath)));
  } else if (type === _constants__WEBPACK_IMPORTED_MODULE_2__["geojsonTypes"].POLYGON) {
    // Cycle through a Polygon's rings and
    // process each line
    coordinates.forEach((line, lineIndex) => {
      processLine(line, (basePath !== null) ? `${basePath}.${lineIndex}` : String(lineIndex));
    });
  } else if (type === _constants__WEBPACK_IMPORTED_MODULE_2__["geojsonTypes"].LINE_STRING) {
    processLine(coordinates, basePath);
  } else if (type.indexOf(_constants__WEBPACK_IMPORTED_MODULE_2__["geojsonTypes"].MULTI_PREFIX) === 0) {
    processMultiGeometry();
  }

  function processLine(line, lineBasePath) {
    let firstPointString = '';
    let lastVertex = null;
    line.forEach((point, pointIndex) => {
      const pointPath = (lineBasePath !== undefined && lineBasePath !== null) ? `${lineBasePath}.${pointIndex}` : String(pointIndex);
      const vertex = Object(_create_vertex__WEBPACK_IMPORTED_MODULE_0__["default"])(featureId, point, pointPath, isSelectedPath(pointPath));

      // If we're creating midpoints, check if there was a
      // vertex before this one. If so, add a midpoint
      // between that vertex and this one.
      if (options.midpoints && lastVertex) {
        const midpoint = Object(_create_midpoint__WEBPACK_IMPORTED_MODULE_1__["default"])(featureId, lastVertex, vertex, options.map);
        if (midpoint) {
          supplementaryPoints.push(midpoint);
        }
      }
      lastVertex = vertex;

      // A Polygon line's last point is the same as the first point. If we're on the last
      // point, we want to draw a midpoint before it but not another vertex on it
      // (since we already a vertex there, from the first point).
      const stringifiedPoint = JSON.stringify(point);
      if (firstPointString !== stringifiedPoint) {
        supplementaryPoints.push(vertex);
      }
      if (pointIndex === 0) {
        firstPointString = stringifiedPoint;
      }
    });
  }

  function isSelectedPath(path) {
    if (!options.selectedPaths) return false;
    return options.selectedPaths.indexOf(path) !== -1;
  }

  // Split a multi-geometry into constituent
  // geometries, and accumulate the supplementary points
  // for each of those constituents
  function processMultiGeometry() {
    const subType = type.replace(_constants__WEBPACK_IMPORTED_MODULE_2__["geojsonTypes"].MULTI_PREFIX, '');
    coordinates.forEach((subCoordinates, index) => {
      const subFeature = {
        type: _constants__WEBPACK_IMPORTED_MODULE_2__["geojsonTypes"].FEATURE,
        properties: geojson.properties,
        geometry: {
          type: subType,
          coordinates: subCoordinates
        }
      };
      supplementaryPoints = supplementaryPoints.concat(createSupplementaryPoints(subFeature, options, index));
    });
  }

  return supplementaryPoints;
}

/* harmony default export */ __webpack_exports__["default"] = (createSupplementaryPoints);


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/create_vertex.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/lib/create_vertex.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants */ "./node_modules/@mapbox/mapbox-gl-draw/src/constants.js");


/**
 * Returns GeoJSON for a Point representing the
 * vertex of another feature.
 *
 * @param {string} parentId
 * @param {Array<number>} coordinates
 * @param {string} path - Dot-separated numbers indicating exactly
 *   where the point exists within its parent feature's coordinates.
 * @param {boolean} selected
 * @return {GeoJSON} Point
 */
/* harmony default export */ __webpack_exports__["default"] = (function(parentId, coordinates, path, selected) {
  return {
    type: _constants__WEBPACK_IMPORTED_MODULE_0__["geojsonTypes"].FEATURE,
    properties: {
      meta: _constants__WEBPACK_IMPORTED_MODULE_0__["meta"].VERTEX,
      parent: parentId,
      coord_path: path,
      active: (selected) ? _constants__WEBPACK_IMPORTED_MODULE_0__["activeStates"].ACTIVE : _constants__WEBPACK_IMPORTED_MODULE_0__["activeStates"].INACTIVE
    },
    geometry: {
      type: _constants__WEBPACK_IMPORTED_MODULE_0__["geojsonTypes"].POINT,
      coordinates
    }
  };
});


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/double_click_zoom.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/lib/double_click_zoom.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({
  enable(ctx) {
    setTimeout(() => {
      // First check we've got a map and some context.
      if (!ctx.map || !ctx.map.doubleClickZoom || !ctx._ctx || !ctx._ctx.store || !ctx._ctx.store.getInitialConfigValue) return;
      // Now check initial state wasn't false (we leave it disabled if so)
      if (!ctx._ctx.store.getInitialConfigValue('doubleClickZoom')) return;
      ctx.map.doubleClickZoom.enable();
    }, 0);
  },
  disable(ctx) {
    setTimeout(() => {
      if (!ctx.map || !ctx.map.doubleClickZoom) return;
      // Always disable here, as it's necessary in some cases.
      ctx.map.doubleClickZoom.disable();
    }, 0);
  }
});


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/euclidean_distance.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/lib/euclidean_distance.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  const x = a.x - b.x;
  const y = a.y - b.y;
  return Math.sqrt((x * x) + (y * y));
});


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/features_at.js":
/*!********************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/lib/features_at.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sort_features__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sort_features */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/sort_features.js");
/* harmony import */ var _map_event_to_bounding_box__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map_event_to_bounding_box */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/map_event_to_bounding_box.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants */ "./node_modules/@mapbox/mapbox-gl-draw/src/constants.js");
/* harmony import */ var _string_set__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./string_set */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/string_set.js");





const META_TYPES = [
  _constants__WEBPACK_IMPORTED_MODULE_2__["meta"].FEATURE,
  _constants__WEBPACK_IMPORTED_MODULE_2__["meta"].MIDPOINT,
  _constants__WEBPACK_IMPORTED_MODULE_2__["meta"].VERTEX
];

// Requires either event or bbox
/* harmony default export */ __webpack_exports__["default"] = ({
  click: featuresAtClick,
  touch: featuresAtTouch
});

function featuresAtClick(event, bbox, ctx) {
  return featuresAt(event, bbox, ctx, ctx.options.clickBuffer);
}

function featuresAtTouch(event, bbox, ctx) {
  return featuresAt(event, bbox, ctx, ctx.options.touchBuffer);
}

function featuresAt(event, bbox, ctx, buffer) {
  if (ctx.map === null) return [];

  const box = (event) ? Object(_map_event_to_bounding_box__WEBPACK_IMPORTED_MODULE_1__["default"])(event, buffer) : bbox;

  const queryParams = {};
  if (ctx.options.styles) queryParams.layers = ctx.options.styles.map(s => s.id);

  const features = ctx.map.queryRenderedFeatures(box, queryParams)
    .filter(feature => META_TYPES.indexOf(feature.properties.meta) !== -1);

  const featureIds = new _string_set__WEBPACK_IMPORTED_MODULE_3__["default"]();
  const uniqueFeatures = [];
  features.forEach((feature) => {
    const featureId = feature.properties.id;
    if (featureIds.has(featureId)) return;
    featureIds.add(featureId);
    uniqueFeatures.push(feature);
  });

  return Object(_sort_features__WEBPACK_IMPORTED_MODULE_0__["default"])(uniqueFeatures);
}


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/get_features_and_set_cursor.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/lib/get_features_and_set_cursor.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getFeatureAtAndSetCursors; });
/* harmony import */ var _features_at__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./features_at */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/features_at.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ "./node_modules/@mapbox/mapbox-gl-draw/src/constants.js");



function getFeatureAtAndSetCursors(event, ctx) {
  const features = _features_at__WEBPACK_IMPORTED_MODULE_0__["default"].click(event, null, ctx);
  const classes = { mouse: _constants__WEBPACK_IMPORTED_MODULE_1__["cursors"].NONE };

  if (features[0]) {
    classes.mouse = (features[0].properties.active === _constants__WEBPACK_IMPORTED_MODULE_1__["activeStates"].ACTIVE) ?
      _constants__WEBPACK_IMPORTED_MODULE_1__["cursors"].MOVE : _constants__WEBPACK_IMPORTED_MODULE_1__["cursors"].POINTER;
    classes.feature = features[0].properties.meta;
  }

  if (ctx.events.currentModeName().indexOf('draw') !== -1) {
    classes.mouse = _constants__WEBPACK_IMPORTED_MODULE_1__["cursors"].ADD;
  }

  ctx.ui.queueMapClasses(classes);
  ctx.ui.updateMapClasses();

  return features[0];
}


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/is_click.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/lib/is_click.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isClick; });
/* harmony import */ var _euclidean_distance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./euclidean_distance */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/euclidean_distance.js");


const FINE_TOLERANCE = 4;
const GROSS_TOLERANCE = 12;
const INTERVAL = 500;

function isClick(start, end, options = {}) {
  const fineTolerance = (options.fineTolerance != null) ? options.fineTolerance : FINE_TOLERANCE;
  const grossTolerance = (options.grossTolerance != null) ? options.grossTolerance : GROSS_TOLERANCE;
  const interval = (options.interval != null) ? options.interval : INTERVAL;

  start.point = start.point || end.point;
  start.time = start.time || end.time;
  const moveDistance = Object(_euclidean_distance__WEBPACK_IMPORTED_MODULE_0__["default"])(start.point, end.point);

  return moveDistance < fineTolerance ||
    (moveDistance < grossTolerance && (end.time - start.time) < interval);
}


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/is_event_at_coordinates.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/lib/is_event_at_coordinates.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function isEventAtCoordinates(event, coordinates) {
  if (!event.lngLat) return false;
  return event.lngLat.lng === coordinates[0] && event.lngLat.lat === coordinates[1];
}

/* harmony default export */ __webpack_exports__["default"] = (isEventAtCoordinates);


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/is_tap.js":
/*!***************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/lib/is_tap.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isTap; });
/* harmony import */ var _euclidean_distance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./euclidean_distance */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/euclidean_distance.js");


const TOLERANCE = 25;
const INTERVAL = 250;

function isTap(start, end, options = {}) {
  const tolerance = (options.tolerance != null) ? options.tolerance : TOLERANCE;
  const interval = (options.interval != null) ? options.interval : INTERVAL;

  start.point = start.point || end.point;
  start.time = start.time || end.time;
  const moveDistance = Object(_euclidean_distance__WEBPACK_IMPORTED_MODULE_0__["default"])(start.point, end.point);

  return moveDistance < tolerance && (end.time - start.time) < interval;
}


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/map_event_to_bounding_box.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/lib/map_event_to_bounding_box.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Returns a bounding box representing the event's location.
 *
 * @param {Event} mapEvent - Mapbox GL JS map event, with a point properties.
 * @return {Array<Array<number>>} Bounding box.
 */
function mapEventToBoundingBox(mapEvent, buffer = 0) {
  return [
    [mapEvent.point.x - buffer, mapEvent.point.y - buffer],
    [mapEvent.point.x + buffer, mapEvent.point.y + buffer]
  ];
}

/* harmony default export */ __webpack_exports__["default"] = (mapEventToBoundingBox);


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/mode_handler.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/lib/mode_handler.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

const ModeHandler = function(mode, DrawContext) {

  const handlers = {
    drag: [],
    click: [],
    mousemove: [],
    mousedown: [],
    mouseup: [],
    mouseout: [],
    keydown: [],
    keyup: [],
    touchstart: [],
    touchmove: [],
    touchend: [],
    tap: []
  };

  const ctx = {
    on(event, selector, fn) {
      if (handlers[event] === undefined) {
        throw new Error(`Invalid event type: ${event}`);
      }
      handlers[event].push({
        selector,
        fn
      });
    },
    render(id) {
      DrawContext.store.featureChanged(id);
    }
  };

  const delegate = function (eventName, event) {
    const handles = handlers[eventName];
    let iHandle = handles.length;
    while (iHandle--) {
      const handle = handles[iHandle];
      if (handle.selector(event)) {
        handle.fn.call(ctx, event);
        DrawContext.store.render();
        DrawContext.ui.updateMapClasses();

        // ensure an event is only handled once
        // we do this to let modes have multiple overlapping selectors
        // and relay on order of oppertations to filter
        break;
      }
    }
  };

  mode.start.call(ctx);

  return {
    render: mode.render,
    stop() {
      if (mode.stop) mode.stop();
    },
    trash() {
      if (mode.trash) {
        mode.trash();
        DrawContext.store.render();
      }
    },
    combineFeatures() {
      if (mode.combineFeatures) {
        mode.combineFeatures();
      }
    },
    uncombineFeatures() {
      if (mode.uncombineFeatures) {
        mode.uncombineFeatures();
      }
    },
    drag(event) {
      delegate('drag', event);
    },
    click(event) {
      delegate('click', event);
    },
    mousemove(event) {
      delegate('mousemove', event);
    },
    mousedown(event) {
      delegate('mousedown', event);
    },
    mouseup(event) {
      delegate('mouseup', event);
    },
    mouseout(event) {
      delegate('mouseout', event);
    },
    keydown(event) {
      delegate('keydown', event);
    },
    keyup(event) {
      delegate('keyup', event);
    },
    touchstart(event) {
      delegate('touchstart', event);
    },
    touchmove(event) {
      delegate('touchmove', event);
    },
    touchend(event) {
      delegate('touchend', event);
    },
    tap(event) {
      delegate('tap', event);
    }
  };
};

/* harmony default export */ __webpack_exports__["default"] = (ModeHandler);


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/mouse_event_point.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/lib/mouse_event_point.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mapbox_point_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @mapbox/point-geometry */ "./node_modules/@mapbox/point-geometry/index.js");
/* harmony import */ var _mapbox_point_geometry__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mapbox_point_geometry__WEBPACK_IMPORTED_MODULE_0__);


/**
 * Returns a Point representing a mouse event's position
 * relative to a containing element.
 *
 * @param {MouseEvent} mouseEvent
 * @param {Node} container
 * @returns {Point}
 */
function mouseEventPoint(mouseEvent, container) {
  const rect = container.getBoundingClientRect();
  return new _mapbox_point_geometry__WEBPACK_IMPORTED_MODULE_0___default.a(
    mouseEvent.clientX - rect.left - (container.clientLeft || 0),
    mouseEvent.clientY - rect.top - (container.clientTop || 0)
  );
}

/* harmony default export */ __webpack_exports__["default"] = (mouseEventPoint);


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/move_features.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/lib/move_features.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _constrain_feature_movement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constrain_feature_movement */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/constrain_feature_movement.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ "./node_modules/@mapbox/mapbox-gl-draw/src/constants.js");



/* harmony default export */ __webpack_exports__["default"] = (function(features, delta) {
  const constrainedDelta = Object(_constrain_feature_movement__WEBPACK_IMPORTED_MODULE_0__["default"])(features.map(feature => feature.toGeoJSON()), delta);

  features.forEach((feature) => {
    const currentCoordinates = feature.getCoordinates();

    const moveCoordinate = (coord) => {
      const point = {
        lng: coord[0] + constrainedDelta.lng,
        lat: coord[1] + constrainedDelta.lat
      };
      return [point.lng, point.lat];
    };
    const moveRing = ring => ring.map(coord => moveCoordinate(coord));
    const moveMultiPolygon = multi => multi.map(ring => moveRing(ring));

    let nextCoordinates;
    if (feature.type === _constants__WEBPACK_IMPORTED_MODULE_1__["geojsonTypes"].POINT) {
      nextCoordinates = moveCoordinate(currentCoordinates);
    } else if (feature.type === _constants__WEBPACK_IMPORTED_MODULE_1__["geojsonTypes"].LINE_STRING || feature.type === _constants__WEBPACK_IMPORTED_MODULE_1__["geojsonTypes"].MULTI_POINT) {
      nextCoordinates = currentCoordinates.map(moveCoordinate);
    } else if (feature.type === _constants__WEBPACK_IMPORTED_MODULE_1__["geojsonTypes"].POLYGON || feature.type === _constants__WEBPACK_IMPORTED_MODULE_1__["geojsonTypes"].MULTI_LINE_STRING) {
      nextCoordinates = currentCoordinates.map(moveRing);
    } else if (feature.type === _constants__WEBPACK_IMPORTED_MODULE_1__["geojsonTypes"].MULTI_POLYGON) {
      nextCoordinates = currentCoordinates.map(moveMultiPolygon);
    }

    feature.incomingCoords(nextCoordinates);
  });
});


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/sort_features.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/lib/sort_features.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mapbox_geojson_area__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @mapbox/geojson-area */ "./node_modules/@mapbox/geojson-area/index.js");
/* harmony import */ var _mapbox_geojson_area__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mapbox_geojson_area__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ "./node_modules/@mapbox/mapbox-gl-draw/src/constants.js");



const FEATURE_SORT_RANKS = {
  Point: 0,
  LineString: 1,
  Polygon: 2
};

function comparator(a, b) {
  const score = FEATURE_SORT_RANKS[a.geometry.type] - FEATURE_SORT_RANKS[b.geometry.type];

  if (score === 0 && a.geometry.type === _constants__WEBPACK_IMPORTED_MODULE_1__["geojsonTypes"].POLYGON) {
    return a.area - b.area;
  }

  return score;
}

// Sort in the order above, then sort polygons by area ascending.
function sortFeatures(features) {
  return features.map((feature) => {
    if (feature.geometry.type === _constants__WEBPACK_IMPORTED_MODULE_1__["geojsonTypes"].POLYGON) {
      feature.area = _mapbox_geojson_area__WEBPACK_IMPORTED_MODULE_0___default.a.geometry({
        type: _constants__WEBPACK_IMPORTED_MODULE_1__["geojsonTypes"].FEATURE,
        property: {},
        geometry: feature.geometry
      });
    }
    return feature;
  }).sort(comparator).map((feature) => {
    delete feature.area;
    return feature;
  });
}

/* harmony default export */ __webpack_exports__["default"] = (sortFeatures);


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/string_set.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/lib/string_set.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function StringSet(items) {
  this._items = {};
  this._nums = {};
  this._length = items ? items.length : 0;
  if (!items) return;
  for (let i = 0, l = items.length; i < l; i++) {
    this.add(items[i]);
    if (items[i] === undefined) continue;
    if (typeof items[i] === 'string') this._items[items[i]] = i;
    else this._nums[items[i]] = i;

  }
}

StringSet.prototype.add = function(x) {
  if (this.has(x)) return this;
  this._length++;
  if (typeof x === 'string') this._items[x] = this._length;
  else this._nums[x] = this._length;
  return this;
};

StringSet.prototype.delete = function(x) {
  if (this.has(x) === false) return this;
  this._length--;
  delete this._items[x];
  delete this._nums[x];
  return this;
};

StringSet.prototype.has = function(x) {
  if (typeof x !== 'string' && typeof x !== 'number') return false;
  return this._items[x] !== undefined || this._nums[x] !== undefined;
};

StringSet.prototype.values = function() {
  const values = [];
  Object.keys(this._items).forEach((k) => {
    values.push({ k, v: this._items[k] });
  });
  Object.keys(this._nums).forEach((k) => {
    values.push({ k: JSON.parse(k), v: this._nums[k] });
  });

  return values.sort((a, b) => a.v - b.v).map(a => a.k);
};

StringSet.prototype.clear = function() {
  this._length = 0;
  this._items = {};
  this._nums = {};
  return this;
};

/* harmony default export */ __webpack_exports__["default"] = (StringSet);


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/string_sets_are_equal.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/lib/string_sets_are_equal.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function(a, b) {
  if (a.length !== b.length) return false;
  return JSON.stringify(a.map(id => id).sort()) === JSON.stringify(b.map(id => id).sort());
});


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/theme.js":
/*!**************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/lib/theme.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ([
  {
    'id': 'gl-draw-polygon-fill-inactive',
    'type': 'fill',
    'filter': ['all',
      ['==', 'active', 'false'],
      ['==', '$type', 'Polygon'],
      ['!=', 'mode', 'static']
    ],
    'paint': {
      'fill-color': '#3bb2d0',
      'fill-outline-color': '#3bb2d0',
      'fill-opacity': 0.1
    }
  },
  {
    'id': 'gl-draw-polygon-fill-active',
    'type': 'fill',
    'filter': ['all', ['==', 'active', 'true'], ['==', '$type', 'Polygon']],
    'paint': {
      'fill-color': '#fbb03b',
      'fill-outline-color': '#fbb03b',
      'fill-opacity': 0.1
    }
  },
  {
    'id': 'gl-draw-polygon-midpoint',
    'type': 'circle',
    'filter': ['all',
      ['==', '$type', 'Point'],
      ['==', 'meta', 'midpoint']],
    'paint': {
      'circle-radius': 3,
      'circle-color': '#fbb03b'
    }
  },
  {
    'id': 'gl-draw-polygon-stroke-inactive',
    'type': 'line',
    'filter': ['all',
      ['==', 'active', 'false'],
      ['==', '$type', 'Polygon'],
      ['!=', 'mode', 'static']
    ],
    'layout': {
      'line-cap': 'round',
      'line-join': 'round'
    },
    'paint': {
      'line-color': '#3bb2d0',
      'line-width': 2
    }
  },
  {
    'id': 'gl-draw-polygon-stroke-active',
    'type': 'line',
    'filter': ['all', ['==', 'active', 'true'], ['==', '$type', 'Polygon']],
    'layout': {
      'line-cap': 'round',
      'line-join': 'round'
    },
    'paint': {
      'line-color': '#fbb03b',
      'line-dasharray': [0.2, 2],
      'line-width': 2
    }
  },
  {
    'id': 'gl-draw-line-inactive',
    'type': 'line',
    'filter': ['all',
      ['==', 'active', 'false'],
      ['==', '$type', 'LineString'],
      ['!=', 'mode', 'static']
    ],
    'layout': {
      'line-cap': 'round',
      'line-join': 'round'
    },
    'paint': {
      'line-color': '#3bb2d0',
      'line-width': 2
    }
  },
  {
    'id': 'gl-draw-line-active',
    'type': 'line',
    'filter': ['all',
      ['==', '$type', 'LineString'],
      ['==', 'active', 'true']
    ],
    'layout': {
      'line-cap': 'round',
      'line-join': 'round'
    },
    'paint': {
      'line-color': '#fbb03b',
      'line-dasharray': [0.2, 2],
      'line-width': 2
    }
  },
  {
    'id': 'gl-draw-polygon-and-line-vertex-stroke-inactive',
    'type': 'circle',
    'filter': ['all',
      ['==', 'meta', 'vertex'],
      ['==', '$type', 'Point'],
      ['!=', 'mode', 'static']
    ],
    'paint': {
      'circle-radius': 5,
      'circle-color': '#fff'
    }
  },
  {
    'id': 'gl-draw-polygon-and-line-vertex-inactive',
    'type': 'circle',
    'filter': ['all',
      ['==', 'meta', 'vertex'],
      ['==', '$type', 'Point'],
      ['!=', 'mode', 'static']
    ],
    'paint': {
      'circle-radius': 3,
      'circle-color': '#fbb03b'
    }
  },
  {
    'id': 'gl-draw-point-point-stroke-inactive',
    'type': 'circle',
    'filter': ['all',
      ['==', 'active', 'false'],
      ['==', '$type', 'Point'],
      ['==', 'meta', 'feature'],
      ['!=', 'mode', 'static']
    ],
    'paint': {
      'circle-radius': 5,
      'circle-opacity': 1,
      'circle-color': '#fff'
    }
  },
  {
    'id': 'gl-draw-point-inactive',
    'type': 'circle',
    'filter': ['all',
      ['==', 'active', 'false'],
      ['==', '$type', 'Point'],
      ['==', 'meta', 'feature'],
      ['!=', 'mode', 'static']
    ],
    'paint': {
      'circle-radius': 3,
      'circle-color': '#3bb2d0'
    }
  },
  {
    'id': 'gl-draw-point-stroke-active',
    'type': 'circle',
    'filter': ['all',
      ['==', '$type', 'Point'],
      ['==', 'active', 'true'],
      ['!=', 'meta', 'midpoint']
    ],
    'paint': {
      'circle-radius': 7,
      'circle-color': '#fff'
    }
  },
  {
    'id': 'gl-draw-point-active',
    'type': 'circle',
    'filter': ['all',
      ['==', '$type', 'Point'],
      ['!=', 'meta', 'midpoint'],
      ['==', 'active', 'true']],
    'paint': {
      'circle-radius': 5,
      'circle-color': '#fbb03b'
    }
  },
  {
    'id': 'gl-draw-polygon-fill-static',
    'type': 'fill',
    'filter': ['all', ['==', 'mode', 'static'], ['==', '$type', 'Polygon']],
    'paint': {
      'fill-color': '#404040',
      'fill-outline-color': '#404040',
      'fill-opacity': 0.1
    }
  },
  {
    'id': 'gl-draw-polygon-stroke-static',
    'type': 'line',
    'filter': ['all', ['==', 'mode', 'static'], ['==', '$type', 'Polygon']],
    'layout': {
      'line-cap': 'round',
      'line-join': 'round'
    },
    'paint': {
      'line-color': '#404040',
      'line-width': 2
    }
  },
  {
    'id': 'gl-draw-line-static',
    'type': 'line',
    'filter': ['all', ['==', 'mode', 'static'], ['==', '$type', 'LineString']],
    'layout': {
      'line-cap': 'round',
      'line-join': 'round'
    },
    'paint': {
      'line-color': '#404040',
      'line-width': 2
    }
  },
  {
    'id': 'gl-draw-point-static',
    'type': 'circle',
    'filter': ['all', ['==', 'mode', 'static'], ['==', '$type', 'Point']],
    'paint': {
      'circle-radius': 5,
      'circle-color': '#404040'
    }
  }
]);


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/to_dense_array.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/lib/to_dense_array.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Derive a dense array (no `undefined`s) from a single value or array.
 *
 * @param {any} x
 * @return {Array<any>}
 */
function toDenseArray(x) {
  return [].concat(x).filter(y => y !== undefined);
}

/* harmony default export */ __webpack_exports__["default"] = (toDenseArray);


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/modes/direct_select.js":
/*!************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/modes/direct_select.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/common_selectors */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/common_selectors.js");
/* harmony import */ var _lib_create_supplementary_points__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/create_supplementary_points */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/create_supplementary_points.js");
/* harmony import */ var _lib_constrain_feature_movement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/constrain_feature_movement */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/constrain_feature_movement.js");
/* harmony import */ var _lib_double_click_zoom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/double_click_zoom */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/double_click_zoom.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants */ "./node_modules/@mapbox/mapbox-gl-draw/src/constants.js");
/* harmony import */ var _lib_move_features__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../lib/move_features */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/move_features.js");







const isVertex = Object(_lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["isOfMetaType"])(_constants__WEBPACK_IMPORTED_MODULE_4__["meta"].VERTEX);
const isMidpoint = Object(_lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["isOfMetaType"])(_constants__WEBPACK_IMPORTED_MODULE_4__["meta"].MIDPOINT);

const DirectSelect = {};

// INTERNAL FUCNTIONS

DirectSelect.fireUpdate = function() {
  this.map.fire(_constants__WEBPACK_IMPORTED_MODULE_4__["events"].UPDATE, {
    action: _constants__WEBPACK_IMPORTED_MODULE_4__["updateActions"].CHANGE_COORDINATES,
    features: this.getSelected().map(f => f.toGeoJSON())
  });
};

DirectSelect.fireActionable = function(state) {
  this.setActionableState({
    combineFeatures: false,
    uncombineFeatures: false,
    trash: state.selectedCoordPaths.length > 0
  });
};

DirectSelect.startDragging = function(state, e) {
  this.map.dragPan.disable();
  state.canDragMove = true;
  state.dragMoveLocation = e.lngLat;
};

DirectSelect.stopDragging = function(state) {
  this.map.dragPan.enable();
  state.dragMoving = false;
  state.canDragMove = false;
  state.dragMoveLocation = null;
};

DirectSelect.onVertex = function (state, e) {
  this.startDragging(state, e);
  const about = e.featureTarget.properties;
  const selectedIndex = state.selectedCoordPaths.indexOf(about.coord_path);
  if (!Object(_lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["isShiftDown"])(e) && selectedIndex === -1) {
    state.selectedCoordPaths = [about.coord_path];
  } else if (Object(_lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["isShiftDown"])(e) && selectedIndex === -1) {
    state.selectedCoordPaths.push(about.coord_path);
  }

  const selectedCoordinates = this.pathsToCoordinates(state.featureId, state.selectedCoordPaths);
  this.setSelectedCoordinates(selectedCoordinates);
};

DirectSelect.onMidpoint = function(state, e) {
  this.startDragging(state, e);
  const about = e.featureTarget.properties;
  state.feature.addCoordinate(about.coord_path, about.lng, about.lat);
  this.fireUpdate();
  state.selectedCoordPaths = [about.coord_path];
};

DirectSelect.pathsToCoordinates = function(featureId, paths) {
  return paths.map(coord_path => ({ feature_id: featureId, coord_path }));
};

DirectSelect.onFeature = function(state, e) {
  if (state.selectedCoordPaths.length === 0) this.startDragging(state, e);
  else this.stopDragging(state);
};

DirectSelect.dragFeature = function(state, e, delta) {
  Object(_lib_move_features__WEBPACK_IMPORTED_MODULE_5__["default"])(this.getSelected(), delta);
  state.dragMoveLocation = e.lngLat;
};

DirectSelect.dragVertex = function(state, e, delta) {
  const selectedCoords = state.selectedCoordPaths.map(coord_path => state.feature.getCoordinate(coord_path));
  const selectedCoordPoints = selectedCoords.map(coords => ({
    type: _constants__WEBPACK_IMPORTED_MODULE_4__["geojsonTypes"].FEATURE,
    properties: {},
    geometry: {
      type: _constants__WEBPACK_IMPORTED_MODULE_4__["geojsonTypes"].POINT,
      coordinates: coords
    }
  }));

  const constrainedDelta = Object(_lib_constrain_feature_movement__WEBPACK_IMPORTED_MODULE_2__["default"])(selectedCoordPoints, delta);
  for (let i = 0; i < selectedCoords.length; i++) {
    const coord = selectedCoords[i];
    state.feature.updateCoordinate(state.selectedCoordPaths[i], coord[0] + constrainedDelta.lng, coord[1] + constrainedDelta.lat);
  }
};

DirectSelect.clickNoTarget = function () {
  this.changeMode(_constants__WEBPACK_IMPORTED_MODULE_4__["modes"].SIMPLE_SELECT);
};

DirectSelect.clickInactive = function () {
  this.changeMode(_constants__WEBPACK_IMPORTED_MODULE_4__["modes"].SIMPLE_SELECT);
};

DirectSelect.clickActiveFeature = function (state) {
  state.selectedCoordPaths = [];
  this.clearSelectedCoordinates();
  state.feature.changed();
};

// EXTERNAL FUNCTIONS

DirectSelect.onSetup = function(opts) {
  const featureId = opts.featureId;
  const feature = this.getFeature(featureId);

  if (!feature) {
    throw new Error('You must provide a featureId to enter direct_select mode');
  }

  if (feature.type === _constants__WEBPACK_IMPORTED_MODULE_4__["geojsonTypes"].POINT) {
    throw new TypeError('direct_select mode doesn\'t handle point features');
  }

  const state = {
    featureId,
    feature,
    dragMoveLocation: opts.startPos || null,
    dragMoving: false,
    canDragMove: false,
    selectedCoordPaths: opts.coordPath ? [opts.coordPath] : []
  };

  this.setSelectedCoordinates(this.pathsToCoordinates(featureId, state.selectedCoordPaths));
  this.setSelected(featureId);
  _lib_double_click_zoom__WEBPACK_IMPORTED_MODULE_3__["default"].disable(this);

  this.setActionableState({
    trash: true
  });

  return state;
};

DirectSelect.onStop = function() {
  _lib_double_click_zoom__WEBPACK_IMPORTED_MODULE_3__["default"].enable(this);
  this.clearSelectedCoordinates();
};

DirectSelect.toDisplayFeatures = function(state, geojson, push) {
  if (state.featureId === geojson.properties.id) {
    geojson.properties.active = _constants__WEBPACK_IMPORTED_MODULE_4__["activeStates"].ACTIVE;
    push(geojson);
    Object(_lib_create_supplementary_points__WEBPACK_IMPORTED_MODULE_1__["default"])(geojson, {
      map: this.map,
      midpoints: true,
      selectedPaths: state.selectedCoordPaths
    }).forEach(push);
  } else {
    geojson.properties.active = _constants__WEBPACK_IMPORTED_MODULE_4__["activeStates"].INACTIVE;
    push(geojson);
  }
  this.fireActionable(state);
};

DirectSelect.onTrash = function(state) {
  // Uses number-aware sorting to make sure '9' < '10'. Comparison is reversed because we want them
  // in reverse order so that we can remove by index safely.
  state.selectedCoordPaths
    .sort((a, b) => b.localeCompare(a, 'en', { numeric: true }))
    .forEach(id => state.feature.removeCoordinate(id));
  this.fireUpdate();
  state.selectedCoordPaths = [];
  this.clearSelectedCoordinates();
  this.fireActionable(state);
  if (state.feature.isValid() === false) {
    this.deleteFeature([state.featureId]);
    this.changeMode(_constants__WEBPACK_IMPORTED_MODULE_4__["modes"].SIMPLE_SELECT, {});
  }
};

DirectSelect.onMouseMove = function(state, e) {
  // On mousemove that is not a drag, stop vertex movement.
  const isFeature = Object(_lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["isActiveFeature"])(e);
  const onVertex = isVertex(e);
  const noCoords = state.selectedCoordPaths.length === 0;
  if (isFeature && noCoords) this.updateUIClasses({ mouse: _constants__WEBPACK_IMPORTED_MODULE_4__["cursors"].MOVE });
  else if (onVertex && !noCoords) this.updateUIClasses({ mouse: _constants__WEBPACK_IMPORTED_MODULE_4__["cursors"].MOVE });
  else this.updateUIClasses({ mouse: _constants__WEBPACK_IMPORTED_MODULE_4__["cursors"].NONE });
  this.stopDragging(state);
};

DirectSelect.onMouseOut = function(state) {
  // As soon as you mouse leaves the canvas, update the feature
  if (state.dragMoving) this.fireUpdate();
};

DirectSelect.onTouchStart = DirectSelect.onMouseDown = function(state, e) {
  if (isVertex(e)) return this.onVertex(state, e);
  if (Object(_lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["isActiveFeature"])(e)) return this.onFeature(state, e);
  if (isMidpoint(e)) return this.onMidpoint(state, e);
};

DirectSelect.onDrag = function(state, e) {
  if (state.canDragMove !== true) return;
  state.dragMoving = true;
  e.originalEvent.stopPropagation();

  const delta = {
    lng: e.lngLat.lng - state.dragMoveLocation.lng,
    lat: e.lngLat.lat - state.dragMoveLocation.lat
  };
  if (state.selectedCoordPaths.length > 0) this.dragVertex(state, e, delta);
  else this.dragFeature(state, e, delta);

  state.dragMoveLocation = e.lngLat;
};

DirectSelect.onClick = function(state, e) {
  if (Object(_lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["noTarget"])(e)) return this.clickNoTarget(state, e);
  if (Object(_lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["isActiveFeature"])(e)) return this.clickActiveFeature(state, e);
  if (Object(_lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["isInactiveFeature"])(e)) return this.clickInactive(state, e);
  this.stopDragging(state);
};

DirectSelect.onTap = function(state, e) {
  if (Object(_lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["noTarget"])(e)) return this.clickNoTarget(state, e);
  if (Object(_lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["isActiveFeature"])(e)) return this.clickActiveFeature(state, e);
  if (Object(_lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["isInactiveFeature"])(e)) return this.clickInactive(state, e);
};

DirectSelect.onTouchEnd = DirectSelect.onMouseUp = function(state) {
  if (state.dragMoving) {
    this.fireUpdate();
  }
  this.stopDragging(state);
};

/* harmony default export */ __webpack_exports__["default"] = (DirectSelect);



/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_line_string.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_line_string.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/common_selectors */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/common_selectors.js");
/* harmony import */ var _lib_is_event_at_coordinates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/is_event_at_coordinates */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/is_event_at_coordinates.js");
/* harmony import */ var _lib_double_click_zoom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/double_click_zoom */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/double_click_zoom.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants */ "./node_modules/@mapbox/mapbox-gl-draw/src/constants.js");
/* harmony import */ var _lib_create_vertex__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/create_vertex */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/create_vertex.js");






const DrawLineString = {};

DrawLineString.onSetup = function(opts) {
  opts = opts || {};
  const featureId = opts.featureId;

  let line, currentVertexPosition;
  let direction = 'forward';
  if (featureId) {
    line = this.getFeature(featureId);
    if (!line) {
      throw new Error('Could not find a feature with the provided featureId');
    }
    let from = opts.from;
    if (from && from.type === 'Feature' && from.geometry && from.geometry.type === 'Point') {
      from = from.geometry;
    }
    if (from && from.type === 'Point' && from.coordinates && from.coordinates.length === 2) {
      from = from.coordinates;
    }
    if (!from || !Array.isArray(from)) {
      throw new Error('Please use the `from` property to indicate which point to continue the line from');
    }
    const lastCoord = line.coordinates.length - 1;
    if (line.coordinates[lastCoord][0] === from[0] && line.coordinates[lastCoord][1] === from[1]) {
      currentVertexPosition = lastCoord + 1;
      // add one new coordinate to continue from
      line.addCoordinate(currentVertexPosition, ...line.coordinates[lastCoord]);
    } else if (line.coordinates[0][0] === from[0] && line.coordinates[0][1] === from[1]) {
      direction = 'backwards';
      currentVertexPosition = 0;
      // add one new coordinate to continue from
      line.addCoordinate(currentVertexPosition, ...line.coordinates[0]);
    } else {
      throw new Error('`from` should match the point at either the start or the end of the provided LineString');
    }
  } else {
    line = this.newFeature({
      type: _constants__WEBPACK_IMPORTED_MODULE_3__["geojsonTypes"].FEATURE,
      properties: {},
      geometry: {
        type: _constants__WEBPACK_IMPORTED_MODULE_3__["geojsonTypes"].LINE_STRING,
        coordinates: []
      }
    });
    currentVertexPosition = 0;
    this.addFeature(line);
  }

  this.clearSelectedFeatures();
  _lib_double_click_zoom__WEBPACK_IMPORTED_MODULE_2__["default"].disable(this);
  this.updateUIClasses({ mouse: _constants__WEBPACK_IMPORTED_MODULE_3__["cursors"].ADD });
  this.activateUIButton(_constants__WEBPACK_IMPORTED_MODULE_3__["types"].LINE);
  this.setActionableState({
    trash: true
  });

  return {
    line,
    currentVertexPosition,
    direction
  };
};

DrawLineString.clickAnywhere = function(state, e) {
  if (state.currentVertexPosition > 0 && Object(_lib_is_event_at_coordinates__WEBPACK_IMPORTED_MODULE_1__["default"])(e, state.line.coordinates[state.currentVertexPosition - 1]) ||
      state.direction === 'backwards' && Object(_lib_is_event_at_coordinates__WEBPACK_IMPORTED_MODULE_1__["default"])(e, state.line.coordinates[state.currentVertexPosition + 1])) {
    return this.changeMode(_constants__WEBPACK_IMPORTED_MODULE_3__["modes"].SIMPLE_SELECT, { featureIds: [state.line.id] });
  }
  this.updateUIClasses({ mouse: _constants__WEBPACK_IMPORTED_MODULE_3__["cursors"].ADD });
  state.line.updateCoordinate(state.currentVertexPosition, e.lngLat.lng, e.lngLat.lat);
  if (state.direction === 'forward') {
    state.currentVertexPosition++;
    state.line.updateCoordinate(state.currentVertexPosition, e.lngLat.lng, e.lngLat.lat);
  } else {
    state.line.addCoordinate(0, e.lngLat.lng, e.lngLat.lat);
  }
};

DrawLineString.clickOnVertex = function(state) {
  return this.changeMode(_constants__WEBPACK_IMPORTED_MODULE_3__["modes"].SIMPLE_SELECT, { featureIds: [state.line.id] });
};

DrawLineString.onMouseMove = function(state, e) {
  state.line.updateCoordinate(state.currentVertexPosition, e.lngLat.lng, e.lngLat.lat);
  if (_lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["isVertex"](e)) {
    this.updateUIClasses({ mouse: _constants__WEBPACK_IMPORTED_MODULE_3__["cursors"].POINTER });
  }
};

DrawLineString.onTap = DrawLineString.onClick = function(state, e) {
  if (_lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["isVertex"](e)) return this.clickOnVertex(state, e);
  this.clickAnywhere(state, e);
};

DrawLineString.onKeyUp = function(state, e) {
  if (_lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["isEnterKey"](e)) {
    this.changeMode(_constants__WEBPACK_IMPORTED_MODULE_3__["modes"].SIMPLE_SELECT, { featureIds: [state.line.id] });
  } else if (_lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["isEscapeKey"](e)) {
    this.deleteFeature([state.line.id], { silent: true });
    this.changeMode(_constants__WEBPACK_IMPORTED_MODULE_3__["modes"].SIMPLE_SELECT);
  }
};

DrawLineString.onStop = function(state) {
  _lib_double_click_zoom__WEBPACK_IMPORTED_MODULE_2__["default"].enable(this);
  this.activateUIButton();

  // check to see if we've deleted this feature
  if (this.getFeature(state.line.id) === undefined) return;

  //remove last added coordinate
  state.line.removeCoordinate(`${state.currentVertexPosition}`);
  if (state.line.isValid()) {
    this.map.fire(_constants__WEBPACK_IMPORTED_MODULE_3__["events"].CREATE, {
      features: [state.line.toGeoJSON()]
    });
  } else {
    this.deleteFeature([state.line.id], { silent: true });
    this.changeMode(_constants__WEBPACK_IMPORTED_MODULE_3__["modes"].SIMPLE_SELECT, {}, { silent: true });
  }
};

DrawLineString.onTrash = function(state) {
  this.deleteFeature([state.line.id], { silent: true });
  this.changeMode(_constants__WEBPACK_IMPORTED_MODULE_3__["modes"].SIMPLE_SELECT);
};

DrawLineString.toDisplayFeatures = function(state, geojson, display) {
  const isActiveLine = geojson.properties.id === state.line.id;
  geojson.properties.active = (isActiveLine) ? _constants__WEBPACK_IMPORTED_MODULE_3__["activeStates"].ACTIVE : _constants__WEBPACK_IMPORTED_MODULE_3__["activeStates"].INACTIVE;
  if (!isActiveLine) return display(geojson);
  // Only render the line if it has at least one real coordinate
  if (geojson.geometry.coordinates.length < 2) return;
  geojson.properties.meta = _constants__WEBPACK_IMPORTED_MODULE_3__["meta"].FEATURE;
  display(Object(_lib_create_vertex__WEBPACK_IMPORTED_MODULE_4__["default"])(
    state.line.id,
    geojson.geometry.coordinates[state.direction === 'forward' ? geojson.geometry.coordinates.length - 2 : 1],
    `${state.direction === 'forward' ? geojson.geometry.coordinates.length - 2 : 1}`,
    false
  ));

  display(geojson);
};

/* harmony default export */ __webpack_exports__["default"] = (DrawLineString);


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_point.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_point.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/common_selectors */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/common_selectors.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ "./node_modules/@mapbox/mapbox-gl-draw/src/constants.js");



const DrawPoint = {};

DrawPoint.onSetup = function() {
  const point = this.newFeature({
    type: _constants__WEBPACK_IMPORTED_MODULE_1__["geojsonTypes"].FEATURE,
    properties: {},
    geometry: {
      type: _constants__WEBPACK_IMPORTED_MODULE_1__["geojsonTypes"].POINT,
      coordinates: []
    }
  });

  this.addFeature(point);

  this.clearSelectedFeatures();
  this.updateUIClasses({ mouse: _constants__WEBPACK_IMPORTED_MODULE_1__["cursors"].ADD });
  this.activateUIButton(_constants__WEBPACK_IMPORTED_MODULE_1__["types"].POINT);

  this.setActionableState({
    trash: true
  });

  return { point };
};

DrawPoint.stopDrawingAndRemove = function(state) {
  this.deleteFeature([state.point.id], { silent: true });
  this.changeMode(_constants__WEBPACK_IMPORTED_MODULE_1__["modes"].SIMPLE_SELECT);
};

DrawPoint.onTap = DrawPoint.onClick = function(state, e) {
  this.updateUIClasses({ mouse: _constants__WEBPACK_IMPORTED_MODULE_1__["cursors"].MOVE });
  state.point.updateCoordinate('', e.lngLat.lng, e.lngLat.lat);
  this.map.fire(_constants__WEBPACK_IMPORTED_MODULE_1__["events"].CREATE, {
    features: [state.point.toGeoJSON()]
  });
  this.changeMode(_constants__WEBPACK_IMPORTED_MODULE_1__["modes"].SIMPLE_SELECT, { featureIds: [state.point.id] });
};

DrawPoint.onStop = function(state) {
  this.activateUIButton();
  if (!state.point.getCoordinate().length) {
    this.deleteFeature([state.point.id], { silent: true });
  }
};

DrawPoint.toDisplayFeatures = function(state, geojson, display) {
  // Never render the point we're drawing
  const isActivePoint = geojson.properties.id === state.point.id;
  geojson.properties.active = (isActivePoint) ? _constants__WEBPACK_IMPORTED_MODULE_1__["activeStates"].ACTIVE : _constants__WEBPACK_IMPORTED_MODULE_1__["activeStates"].INACTIVE;
  if (!isActivePoint) return display(geojson);
};

DrawPoint.onTrash = DrawPoint.stopDrawingAndRemove;

DrawPoint.onKeyUp = function(state, e) {
  if (_lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["isEscapeKey"](e) || _lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["isEnterKey"](e)) {
    return this.stopDrawingAndRemove(state, e);
  }
};

/* harmony default export */ __webpack_exports__["default"] = (DrawPoint);


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_polygon.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_polygon.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/common_selectors */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/common_selectors.js");
/* harmony import */ var _lib_double_click_zoom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/double_click_zoom */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/double_click_zoom.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants */ "./node_modules/@mapbox/mapbox-gl-draw/src/constants.js");
/* harmony import */ var _lib_is_event_at_coordinates__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/is_event_at_coordinates */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/is_event_at_coordinates.js");
/* harmony import */ var _lib_create_vertex__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/create_vertex */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/create_vertex.js");






const DrawPolygon = {};

DrawPolygon.onSetup = function() {
  const polygon = this.newFeature({
    type: _constants__WEBPACK_IMPORTED_MODULE_2__["geojsonTypes"].FEATURE,
    properties: {},
    geometry: {
      type: _constants__WEBPACK_IMPORTED_MODULE_2__["geojsonTypes"].POLYGON,
      coordinates: [[]]
    }
  });

  this.addFeature(polygon);

  this.clearSelectedFeatures();
  _lib_double_click_zoom__WEBPACK_IMPORTED_MODULE_1__["default"].disable(this);
  this.updateUIClasses({ mouse: _constants__WEBPACK_IMPORTED_MODULE_2__["cursors"].ADD });
  this.activateUIButton(_constants__WEBPACK_IMPORTED_MODULE_2__["types"].POLYGON);
  this.setActionableState({
    trash: true
  });

  return {
    polygon,
    currentVertexPosition: 0
  };
};

DrawPolygon.clickAnywhere = function(state, e) {
  if (state.currentVertexPosition > 0 && Object(_lib_is_event_at_coordinates__WEBPACK_IMPORTED_MODULE_3__["default"])(e, state.polygon.coordinates[0][state.currentVertexPosition - 1])) {
    return this.changeMode(_constants__WEBPACK_IMPORTED_MODULE_2__["modes"].SIMPLE_SELECT, { featureIds: [state.polygon.id] });
  }
  this.updateUIClasses({ mouse: _constants__WEBPACK_IMPORTED_MODULE_2__["cursors"].ADD });
  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, e.lngLat.lng, e.lngLat.lat);
  state.currentVertexPosition++;
  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, e.lngLat.lng, e.lngLat.lat);
};

DrawPolygon.clickOnVertex = function(state) {
  return this.changeMode(_constants__WEBPACK_IMPORTED_MODULE_2__["modes"].SIMPLE_SELECT, { featureIds: [state.polygon.id] });
};

DrawPolygon.onMouseMove = function(state, e) {
  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, e.lngLat.lng, e.lngLat.lat);
  if (_lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["isVertex"](e)) {
    this.updateUIClasses({ mouse: _constants__WEBPACK_IMPORTED_MODULE_2__["cursors"].POINTER });
  }
};

DrawPolygon.onTap = DrawPolygon.onClick = function(state, e) {
  if (_lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["isVertex"](e)) return this.clickOnVertex(state, e);
  return this.clickAnywhere(state, e);
};

DrawPolygon.onKeyUp = function(state, e) {
  if (_lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["isEscapeKey"](e)) {
    this.deleteFeature([state.polygon.id], { silent: true });
    this.changeMode(_constants__WEBPACK_IMPORTED_MODULE_2__["modes"].SIMPLE_SELECT);
  } else if (_lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["isEnterKey"](e)) {
    this.changeMode(_constants__WEBPACK_IMPORTED_MODULE_2__["modes"].SIMPLE_SELECT, { featureIds: [state.polygon.id] });
  }
};

DrawPolygon.onStop = function(state) {
  this.updateUIClasses({ mouse: _constants__WEBPACK_IMPORTED_MODULE_2__["cursors"].NONE });
  _lib_double_click_zoom__WEBPACK_IMPORTED_MODULE_1__["default"].enable(this);
  this.activateUIButton();

  // check to see if we've deleted this feature
  if (this.getFeature(state.polygon.id) === undefined) return;

  //remove last added coordinate
  state.polygon.removeCoordinate(`0.${state.currentVertexPosition}`);
  if (state.polygon.isValid()) {
    this.map.fire(_constants__WEBPACK_IMPORTED_MODULE_2__["events"].CREATE, {
      features: [state.polygon.toGeoJSON()]
    });
  } else {
    this.deleteFeature([state.polygon.id], { silent: true });
    this.changeMode(_constants__WEBPACK_IMPORTED_MODULE_2__["modes"].SIMPLE_SELECT, {}, { silent: true });
  }
};

DrawPolygon.toDisplayFeatures = function(state, geojson, display) {
  const isActivePolygon = geojson.properties.id === state.polygon.id;
  geojson.properties.active = (isActivePolygon) ? _constants__WEBPACK_IMPORTED_MODULE_2__["activeStates"].ACTIVE : _constants__WEBPACK_IMPORTED_MODULE_2__["activeStates"].INACTIVE;
  if (!isActivePolygon) return display(geojson);

  // Don't render a polygon until it has two positions
  // (and a 3rd which is just the first repeated)
  if (geojson.geometry.coordinates.length === 0) return;

  const coordinateCount = geojson.geometry.coordinates[0].length;
  // 2 coordinates after selecting a draw type
  // 3 after creating the first point
  if (coordinateCount < 3) {
    return;
  }
  geojson.properties.meta = _constants__WEBPACK_IMPORTED_MODULE_2__["meta"].FEATURE;
  display(Object(_lib_create_vertex__WEBPACK_IMPORTED_MODULE_4__["default"])(state.polygon.id, geojson.geometry.coordinates[0][0], '0.0', false));
  if (coordinateCount > 3) {
    // Add a start position marker to the map, clicking on this will finish the feature
    // This should only be shown when we're in a valid spot
    const endPos = geojson.geometry.coordinates[0].length - 3;
    display(Object(_lib_create_vertex__WEBPACK_IMPORTED_MODULE_4__["default"])(state.polygon.id, geojson.geometry.coordinates[0][endPos], `0.${endPos}`, false));
  }
  if (coordinateCount <= 4) {
    // If we've only drawn two positions (plus the closer),
    // make a LineString instead of a Polygon
    const lineCoordinates = [
      [geojson.geometry.coordinates[0][0][0], geojson.geometry.coordinates[0][0][1]], [geojson.geometry.coordinates[0][1][0], geojson.geometry.coordinates[0][1][1]]
    ];
    // create an initial vertex so that we can track the first point on mobile devices
    display({
      type: _constants__WEBPACK_IMPORTED_MODULE_2__["geojsonTypes"].FEATURE,
      properties: geojson.properties,
      geometry: {
        coordinates: lineCoordinates,
        type: _constants__WEBPACK_IMPORTED_MODULE_2__["geojsonTypes"].LINE_STRING
      }
    });
    if (coordinateCount === 3) {
      return;
    }
  }
  // render the Polygon
  return display(geojson);
};

DrawPolygon.onTrash = function(state) {
  this.deleteFeature([state.polygon.id], { silent: true });
  this.changeMode(_constants__WEBPACK_IMPORTED_MODULE_2__["modes"].SIMPLE_SELECT);
};

/* harmony default export */ __webpack_exports__["default"] = (DrawPolygon);


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/modes/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/modes/index.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _simple_select__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./simple_select */ "./node_modules/@mapbox/mapbox-gl-draw/src/modes/simple_select.js");
/* harmony import */ var _direct_select__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./direct_select */ "./node_modules/@mapbox/mapbox-gl-draw/src/modes/direct_select.js");
/* harmony import */ var _draw_point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./draw_point */ "./node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_point.js");
/* harmony import */ var _draw_polygon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./draw_polygon */ "./node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_polygon.js");
/* harmony import */ var _draw_line_string__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./draw_line_string */ "./node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_line_string.js");







/* harmony default export */ __webpack_exports__["default"] = ({
  simple_select: _simple_select__WEBPACK_IMPORTED_MODULE_0__["default"],
  direct_select: _direct_select__WEBPACK_IMPORTED_MODULE_1__["default"],
  draw_point: _draw_point__WEBPACK_IMPORTED_MODULE_2__["default"],
  draw_polygon: _draw_polygon__WEBPACK_IMPORTED_MODULE_3__["default"],
  draw_line_string: _draw_line_string__WEBPACK_IMPORTED_MODULE_4__["default"],
});


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/modes/mode_interface.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/modes/mode_interface.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mode_interface_accessors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mode_interface_accessors */ "./node_modules/@mapbox/mapbox-gl-draw/src/modes/mode_interface_accessors.js");

/* harmony default export */ __webpack_exports__["default"] = (_mode_interface_accessors__WEBPACK_IMPORTED_MODULE_0__["default"]);

/**
 * Triggered while a mode is being transitioned into.
 * @param opts {Object} - this is the object passed via `draw.changeMode('mode', opts)`;
 * @name MODE.onSetup
 * @returns {Object} - this object will be passed to all other life cycle functions
 */
_mode_interface_accessors__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.onSetup = function() {};

/**
 * Triggered when a drag event is detected on the map
 * @name MODE.onDrag
 * @param state {Object} - a mutible state object created by onSetup
 * @param e {Object} - the captured event that is triggering this life cycle event
 */
_mode_interface_accessors__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.onDrag = function() {};

/**
 * Triggered when the mouse is clicked
 * @name MODE.onClick
 * @param state {Object} - a mutible state object created by onSetup
 * @param e {Object} - the captured event that is triggering this life cycle event
 */
_mode_interface_accessors__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.onClick = function() {};

/**
 * Triggered with the mouse is moved
 * @name MODE.onMouseMove
 * @param state {Object} - a mutible state object created by onSetup
 * @param e {Object} - the captured event that is triggering this life cycle event
 */
_mode_interface_accessors__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.onMouseMove = function() {};

/**
 * Triggered when the mouse button is pressed down
 * @name MODE.onMouseDown
 * @param state {Object} - a mutible state object created by onSetup
 * @param e {Object} - the captured event that is triggering this life cycle event
 */
_mode_interface_accessors__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.onMouseDown = function() {};

/**
 * Triggered when the mouse button is released
 * @name MODE.onMouseUp
 * @param state {Object} - a mutible state object created by onSetup
 * @param e {Object} - the captured event that is triggering this life cycle event
 */
_mode_interface_accessors__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.onMouseUp = function() {};

/**
 * Triggered when the mouse leaves the map's container
 * @name MODE.onMouseOut
 * @param state {Object} - a mutible state object created by onSetup
 * @param e {Object} - the captured event that is triggering this life cycle event
 */
_mode_interface_accessors__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.onMouseOut = function() {};

/**
 * Triggered when a key up event is detected
 * @name MODE.onKeyUp
 * @param state {Object} - a mutible state object created by onSetup
 * @param e {Object} - the captured event that is triggering this life cycle event
 */
_mode_interface_accessors__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.onKeyUp = function() {};

/**
 * Triggered when a key down event is detected
 * @name MODE.onKeyDown
 * @param state {Object} - a mutible state object created by onSetup
 * @param e {Object} - the captured event that is triggering this life cycle event
 */
_mode_interface_accessors__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.onKeyDown = function() {};

/**
 * Triggered when a touch event is started
 * @name MODE.onTouchStart
 * @param state {Object} - a mutible state object created by onSetup
 * @param e {Object} - the captured event that is triggering this life cycle event
 */
_mode_interface_accessors__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.onTouchStart = function() {};

/**
 * Triggered when one drags thier finger on a mobile device
 * @name MODE.onTouchMove
 * @param state {Object} - a mutible state object created by onSetup
 * @param e {Object} - the captured event that is triggering this life cycle event
 */
_mode_interface_accessors__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.onTouchMove = function() {};

/**
 * Triggered when one removes their finger from the map
 * @name MODE.onTouchEnd
 * @param state {Object} - a mutible state object created by onSetup
 * @param e {Object} - the captured event that is triggering this life cycle event
 */
_mode_interface_accessors__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.onTouchEnd = function() {};

/**
 * Triggered when one quicly taps the map
 * @name MODE.onTap
 * @param state {Object} - a mutible state object created by onSetup
 * @param e {Object} - the captured event that is triggering this life cycle event
 */
_mode_interface_accessors__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.onTap = function() {};

/**
 * Triggered when the mode is being exited, to be used for cleaning up artifacts such as invalid features
 * @name MODE.onStop
 * @param state {Object} - a mutible state object created by onSetup
 */
_mode_interface_accessors__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.onStop = function() {};

/**
 * Triggered when [draw.trash()](https://github.com/mapbox/mapbox-gl-draw/blob/master/API.md#trash-draw) is called.
 * @name MODE.onTrash
 * @param state {Object} - a mutible state object created by onSetup
 */
_mode_interface_accessors__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.onTrash = function() {};

/**
 * Triggered when [draw.combineFeatures()](https://github.com/mapbox/mapbox-gl-draw/blob/master/API.md#combinefeatures-draw) is called.
 * @name MODE.onCombineFeature
 * @param state {Object} - a mutible state object created by onSetup
 */
_mode_interface_accessors__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.onCombineFeature = function() {};

/**
 * Triggered when [draw.uncombineFeatures()](https://github.com/mapbox/mapbox-gl-draw/blob/master/API.md#uncombinefeatures-draw) is called.
 * @name MODE.onUncombineFeature
 * @param state {Object} - a mutible state object created by onSetup
 */
_mode_interface_accessors__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.onUncombineFeature = function() {};

/**
 * Triggered per feature on render to convert raw features into set of features for display on the map
 * See [styling draw](https://github.com/mapbox/mapbox-gl-draw/blob/master/API.md#styling-draw) for information about what geojson properties Draw uses as part of rendering.
 * @name MODE.toDisplayFeatures
 * @param state {Object} - a mutible state object created by onSetup
 * @param geojson {Object} - a geojson being evaulated. To render, pass to `display`.
 * @param display {Function} - all geojson objects passed to this be rendered onto the map
 */
_mode_interface_accessors__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.toDisplayFeatures = function() {
  throw new Error('You must overwrite toDisplayFeatures');
};



/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/modes/mode_interface_accessors.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/modes/mode_interface_accessors.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModeInterface; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants */ "./node_modules/@mapbox/mapbox-gl-draw/src/constants.js");
/* harmony import */ var _lib_features_at__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/features_at */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/features_at.js");
/* harmony import */ var _feature_types_point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../feature_types/point */ "./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/point.js");
/* harmony import */ var _feature_types_line_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../feature_types/line_string */ "./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/line_string.js");
/* harmony import */ var _feature_types_polygon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../feature_types/polygon */ "./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/polygon.js");
/* harmony import */ var _feature_types_multi_feature__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../feature_types/multi_feature */ "./node_modules/@mapbox/mapbox-gl-draw/src/feature_types/multi_feature.js");







function ModeInterface(ctx) {
  this.map = ctx.map;
  this.drawConfig = JSON.parse(JSON.stringify(ctx.options || {}));
  this._ctx = ctx;
}

/**
 * Sets Draw's interal selected state
 * @name this.setSelected
 * @param {DrawFeature[]} - whats selected as a [DrawFeature](https://github.com/mapbox/mapbox-gl-draw/blob/master/src/feature_types/feature.js)
 */
ModeInterface.prototype.setSelected = function(features) {
  return this._ctx.store.setSelected(features);
};

/**
 * Sets Draw's internal selected coordinate state
 * @name this.setSelectedCoordinates
 * @param {Object[]} coords - a array of {coord_path: 'string', featureId: 'string'}
 */
ModeInterface.prototype.setSelectedCoordinates = function(coords) {
  this._ctx.store.setSelectedCoordinates(coords);
  coords.reduce((m, c) => {
    if (m[c.feature_id] === undefined) {
      m[c.feature_id] = true;
      this._ctx.store.get(c.feature_id).changed();
    }
    return m;
  }, {});
};

/**
 * Get all selected features as a [DrawFeature](https://github.com/mapbox/mapbox-gl-draw/blob/master/src/feature_types/feature.js)
 * @name this.getSelected
 * @returns {DrawFeature[]}
 */
ModeInterface.prototype.getSelected = function() {
  return this._ctx.store.getSelected();
};

/**
 * Get the ids of all currently selected features
 * @name this.getSelectedIds
 * @returns {String[]}
 */
ModeInterface.prototype.getSelectedIds = function() {
  return this._ctx.store.getSelectedIds();
};

/**
 * Check if a feature is selected
 * @name this.isSelected
 * @param {String} id - a feature id
 * @returns {Boolean}
 */
ModeInterface.prototype.isSelected = function(id) {
  return this._ctx.store.isSelected(id);
};

/**
 * Get a [DrawFeature](https://github.com/mapbox/mapbox-gl-draw/blob/master/src/feature_types/feature.js) by its id
 * @name this.getFeature
 * @param {String} id - a feature id
 * @returns {DrawFeature}
 */
ModeInterface.prototype.getFeature = function(id) {
  return this._ctx.store.get(id);
};

/**
 * Add a feature to draw's internal selected state
 * @name this.select
 * @param {String} id
 */
ModeInterface.prototype.select = function(id) {
  return this._ctx.store.select(id);
};

/**
 * Remove a feature from draw's internal selected state
 * @name this.delete
 * @param {String} id
 */
ModeInterface.prototype.deselect = function(id) {
  return this._ctx.store.deselect(id);
};

/**
 * Delete a feature from draw
 * @name this.deleteFeature
 * @param {String} id - a feature id
 */
ModeInterface.prototype.deleteFeature = function(id, opts = {}) {
  return this._ctx.store.delete(id, opts);
};

/**
 * Add a [DrawFeature](https://github.com/mapbox/mapbox-gl-draw/blob/master/src/feature_types/feature.js) to draw.
 * See `this.newFeature` for converting geojson into a DrawFeature
 * @name this.addFeature
 * @param {DrawFeature} feature - the feature to add
 */
ModeInterface.prototype.addFeature = function(feature) {
  return this._ctx.store.add(feature);
};

/**
 * Clear all selected features
 */
ModeInterface.prototype.clearSelectedFeatures = function() {
  return this._ctx.store.clearSelected();
};

/**
 * Clear all selected coordinates
 */
ModeInterface.prototype.clearSelectedCoordinates = function() {
  return this._ctx.store.clearSelectedCoordinates();
};

/**
 * Indicate if the different action are currently possible with your mode
 * See [draw.actionalbe](https://github.com/mapbox/mapbox-gl-draw/blob/master/API.md#drawactionable) for a list of possible actions. All undefined actions are set to **false** by default
 * @name this.setActionableState
 * @param {Object} actions
 */
ModeInterface.prototype.setActionableState = function(actions = {}) {
  const newSet = {
    trash: actions.trash || false,
    combineFeatures: actions.combineFeatures || false,
    uncombineFeatures: actions.uncombineFeatures || false
  };
  return this._ctx.events.actionable(newSet);
};

/**
 * Trigger a mode change
 * @name this.changeMode
 * @param {String} mode - the mode to transition into
 * @param {Object} opts - the options object to pass to the new mode
 * @param {Object} eventOpts - used to control what kind of events are emitted.
 */
ModeInterface.prototype.changeMode = function(mode, opts = {}, eventOpts = {}) {
  return this._ctx.events.changeMode(mode, opts, eventOpts);
};

/**
 * Update the state of draw map classes
 * @name this.updateUIClasses
 * @param {Object} opts
 */
ModeInterface.prototype.updateUIClasses = function(opts) {
  return this._ctx.ui.queueMapClasses(opts);
};

/**
 * If a name is provided it makes that button active, else if makes all buttons inactive
 * @name this.activateUIButton
 * @param {String?} name - name of the button to make active, leave as undefined to set buttons to be inactive
 */
ModeInterface.prototype.activateUIButton = function(name) {
  return this._ctx.ui.setActiveButton(name);
};

/**
 * Get the features at the location of an event object or in a bbox
 * @name this.featuresAt
 * @param {Event||NULL} event - a mapbox-gl event object
 * @param {BBOX||NULL} bbox - the area to get features from
 * @param {String} bufferType - is this `click` or `tap` event, defaults to click
 */
ModeInterface.prototype.featuresAt = function(event, bbox, bufferType = 'click') {
  if (bufferType !== 'click' && bufferType !== 'touch') throw new Error('invalid buffer type');
  return _lib_features_at__WEBPACK_IMPORTED_MODULE_1__["default"][bufferType](event, bbox, this._ctx);
};

/**
 * Create a new [DrawFeature](https://github.com/mapbox/mapbox-gl-draw/blob/master/src/feature_types/feature.js) from geojson
 * @name this.newFeature
 * @param {GeoJSONFeature} geojson
 * @returns {DrawFeature}
 */
ModeInterface.prototype.newFeature = function(geojson) {
  const type = geojson.geometry.type;
  if (type === _constants__WEBPACK_IMPORTED_MODULE_0__["geojsonTypes"].POINT) return new _feature_types_point__WEBPACK_IMPORTED_MODULE_2__["default"](this._ctx, geojson);
  if (type === _constants__WEBPACK_IMPORTED_MODULE_0__["geojsonTypes"].LINE_STRING) return new _feature_types_line_string__WEBPACK_IMPORTED_MODULE_3__["default"](this._ctx, geojson);
  if (type === _constants__WEBPACK_IMPORTED_MODULE_0__["geojsonTypes"].POLYGON) return new _feature_types_polygon__WEBPACK_IMPORTED_MODULE_4__["default"](this._ctx, geojson);
  return new _feature_types_multi_feature__WEBPACK_IMPORTED_MODULE_5__["default"](this._ctx, geojson);
};

/**
 * Check is an object is an instance of a [DrawFeature](https://github.com/mapbox/mapbox-gl-draw/blob/master/src/feature_types/feature.js)
 * @name this.isInstanceOf
 * @param {String} type - `Point`, `LineString`, `Polygon`, `MultiFeature`
 * @param {Object} feature - the object that needs to be checked
 * @returns {Boolean}
 */
ModeInterface.prototype.isInstanceOf = function(type, feature) {
  if (type === _constants__WEBPACK_IMPORTED_MODULE_0__["geojsonTypes"].POINT) return feature instanceof _feature_types_point__WEBPACK_IMPORTED_MODULE_2__["default"];
  if (type === _constants__WEBPACK_IMPORTED_MODULE_0__["geojsonTypes"].LINE_STRING) return feature instanceof _feature_types_line_string__WEBPACK_IMPORTED_MODULE_3__["default"];
  if (type === _constants__WEBPACK_IMPORTED_MODULE_0__["geojsonTypes"].POLYGON) return feature instanceof _feature_types_polygon__WEBPACK_IMPORTED_MODULE_4__["default"];
  if (type === 'MultiFeature') return feature instanceof _feature_types_multi_feature__WEBPACK_IMPORTED_MODULE_5__["default"];
  throw new Error(`Unknown feature class: ${type}`);
};

/**
 * Force draw to rerender the feature of the provided id
 * @name this.doRender
 * @param {String} id - a feature id
 */
ModeInterface.prototype.doRender = function(id) {
  return this._ctx.store.featureChanged(id);
};



/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/modes/object_to_mode.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/modes/object_to_mode.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mode_interface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mode_interface */ "./node_modules/@mapbox/mapbox-gl-draw/src/modes/mode_interface.js");


const eventMapper = {
  drag: 'onDrag',
  click: 'onClick',
  mousemove: 'onMouseMove',
  mousedown: 'onMouseDown',
  mouseup: 'onMouseUp',
  mouseout: 'onMouseOut',
  keyup: 'onKeyUp',
  keydown: 'onKeyDown',
  touchstart: 'onTouchStart',
  touchmove: 'onTouchMove',
  touchend: 'onTouchEnd',
  tap: 'onTap'
};

const eventKeys = Object.keys(eventMapper);

/* harmony default export */ __webpack_exports__["default"] = (function(modeObject) {
  const modeObjectKeys = Object.keys(modeObject);

  return function(ctx, startOpts = {}) {
    let state = {};

    const mode = modeObjectKeys.reduce((m, k) => {
      m[k] = modeObject[k];
      return m;
    }, new _mode_interface__WEBPACK_IMPORTED_MODULE_0__["default"](ctx));

    function wrapper(eh) {
      return function(e) {
        mode[eh](state, e);
      };
    }

    return {
      start() {
        state = mode.onSetup(startOpts); // this should set ui buttons

        // Adds event handlers for all event options
        // add sets the selector to false for all
        // handlers that are not present in the mode
        // to reduce on render calls for functions that
        // have no logic
        eventKeys.forEach((key) => {
          const modeHandler = eventMapper[key];
          let selector = () => false;
          if (modeObject[modeHandler]) {
            selector = () => true;
          }
          this.on(key, selector, wrapper(modeHandler));
        });

      },
      stop() {
        mode.onStop(state);
      },
      trash() {
        mode.onTrash(state);
      },
      combineFeatures() {
        mode.onCombineFeatures(state);
      },
      uncombineFeatures() {
        mode.onUncombineFeatures(state);
      },
      render(geojson, push) {
        mode.toDisplayFeatures(state, geojson, push);
      }
    };
  };
});


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/modes/simple_select.js":
/*!************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/modes/simple_select.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/common_selectors */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/common_selectors.js");
/* harmony import */ var _lib_mouse_event_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/mouse_event_point */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/mouse_event_point.js");
/* harmony import */ var _lib_create_supplementary_points__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/create_supplementary_points */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/create_supplementary_points.js");
/* harmony import */ var _lib_string_set__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/string_set */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/string_set.js");
/* harmony import */ var _lib_double_click_zoom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/double_click_zoom */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/double_click_zoom.js");
/* harmony import */ var _lib_move_features__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../lib/move_features */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/move_features.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../constants */ "./node_modules/@mapbox/mapbox-gl-draw/src/constants.js");








const SimpleSelect = {};

SimpleSelect.onSetup = function(opts) {
  // turn the opts into state.
  const state = {
    dragMoveLocation: null,
    boxSelectStartLocation: null,
    boxSelectElement: undefined,
    boxSelecting: false,
    canBoxSelect: false,
    dragMoving: false,
    canDragMove: false,
    initiallySelectedFeatureIds: opts.featureIds || []
  };

  this.setSelected(state.initiallySelectedFeatureIds.filter(id => this.getFeature(id) !== undefined));
  this.fireActionable();

  this.setActionableState({
    combineFeatures: true,
    uncombineFeatures: true,
    trash: true
  });

  return state;
};

SimpleSelect.fireUpdate = function() {
  this.map.fire(_constants__WEBPACK_IMPORTED_MODULE_6__["events"].UPDATE, {
    action: _constants__WEBPACK_IMPORTED_MODULE_6__["updateActions"].MOVE,
    features: this.getSelected().map(f => f.toGeoJSON())
  });
};

SimpleSelect.fireActionable = function() {
  const selectedFeatures = this.getSelected();

  const multiFeatures = selectedFeatures.filter(
    feature => this.isInstanceOf('MultiFeature', feature)
  );

  let combineFeatures = false;

  if (selectedFeatures.length > 1) {
    combineFeatures = true;
    const featureType = selectedFeatures[0].type.replace('Multi', '');
    selectedFeatures.forEach((feature) => {
      if (feature.type.replace('Multi', '') !== featureType) {
        combineFeatures = false;
      }
    });
  }

  const uncombineFeatures = multiFeatures.length > 0;
  const trash = selectedFeatures.length > 0;

  this.setActionableState({
    combineFeatures, uncombineFeatures, trash
  });
};

SimpleSelect.getUniqueIds = function(allFeatures) {
  if (!allFeatures.length) return [];
  const ids = allFeatures.map(s => s.properties.id)
    .filter(id => id !== undefined)
    .reduce((memo, id) => {
      memo.add(id);
      return memo;
    }, new _lib_string_set__WEBPACK_IMPORTED_MODULE_3__["default"]());

  return ids.values();
};

SimpleSelect.stopExtendedInteractions = function(state) {
  if (state.boxSelectElement) {
    if (state.boxSelectElement.parentNode) state.boxSelectElement.parentNode.removeChild(state.boxSelectElement);
    state.boxSelectElement = null;
  }

  this.map.dragPan.enable();

  state.boxSelecting = false;
  state.canBoxSelect = false;
  state.dragMoving = false;
  state.canDragMove = false;
};

SimpleSelect.onStop = function() {
  _lib_double_click_zoom__WEBPACK_IMPORTED_MODULE_4__["default"].enable(this);
};

SimpleSelect.onMouseMove = function(state) {
  // On mousemove that is not a drag, stop extended interactions.
  // This is useful if you drag off the canvas, release the button,
  // then move the mouse back over the canvas --- we don't allow the
  // interaction to continue then, but we do let it continue if you held
  // the mouse button that whole time
  return this.stopExtendedInteractions(state);
};

SimpleSelect.onMouseOut = function(state) {
  // As soon as you mouse leaves the canvas, update the feature
  if (state.dragMoving) return this.fireUpdate();
};

SimpleSelect.onTap = SimpleSelect.onClick = function(state, e) {
  // Click (with or without shift) on no feature
  if (_lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["noTarget"](e)) return this.clickAnywhere(state, e); // also tap
  if (_lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["isOfMetaType"](_constants__WEBPACK_IMPORTED_MODULE_6__["meta"].VERTEX)(e)) return this.clickOnVertex(state, e); //tap
  if (_lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["isFeature"](e)) return this.clickOnFeature(state, e);
};

SimpleSelect.clickAnywhere = function (state) {
  // Clear the re-render selection
  const wasSelected = this.getSelectedIds();
  if (wasSelected.length) {
    this.clearSelectedFeatures();
    wasSelected.forEach(id => this.doRender(id));
  }
  _lib_double_click_zoom__WEBPACK_IMPORTED_MODULE_4__["default"].enable(this);
  this.stopExtendedInteractions(state);
};

SimpleSelect.clickOnVertex = function(state, e) {
  // Enter direct select mode
  this.changeMode(_constants__WEBPACK_IMPORTED_MODULE_6__["modes"].DIRECT_SELECT, {
    featureId: e.featureTarget.properties.parent,
    coordPath: e.featureTarget.properties.coord_path,
    startPos: e.lngLat
  });
  this.updateUIClasses({ mouse: _constants__WEBPACK_IMPORTED_MODULE_6__["cursors"].MOVE });
};

SimpleSelect.startOnActiveFeature = function(state, e) {
  // Stop any already-underway extended interactions
  this.stopExtendedInteractions(state);

  // Disable map.dragPan immediately so it can't start
  this.map.dragPan.disable();

  // Re-render it and enable drag move
  this.doRender(e.featureTarget.properties.id);

  // Set up the state for drag moving
  state.canDragMove = true;
  state.dragMoveLocation = e.lngLat;
};

SimpleSelect.clickOnFeature = function(state, e) {
  // Stop everything
  _lib_double_click_zoom__WEBPACK_IMPORTED_MODULE_4__["default"].disable(this);
  this.stopExtendedInteractions(state);

  const isShiftClick = _lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["isShiftDown"](e);
  const selectedFeatureIds = this.getSelectedIds();
  const featureId = e.featureTarget.properties.id;
  const isFeatureSelected = this.isSelected(featureId);

  // Click (without shift) on any selected feature but a point
  if (!isShiftClick && isFeatureSelected && this.getFeature(featureId).type !== _constants__WEBPACK_IMPORTED_MODULE_6__["geojsonTypes"].POINT) {
    // Enter direct select mode
    return this.changeMode(_constants__WEBPACK_IMPORTED_MODULE_6__["modes"].DIRECT_SELECT, {
      featureId
    });
  }

  // Shift-click on a selected feature
  if (isFeatureSelected && isShiftClick) {
    // Deselect it
    this.deselect(featureId);
    this.updateUIClasses({ mouse: _constants__WEBPACK_IMPORTED_MODULE_6__["cursors"].POINTER });
    if (selectedFeatureIds.length === 1) {
      _lib_double_click_zoom__WEBPACK_IMPORTED_MODULE_4__["default"].enable(this);
    }
  // Shift-click on an unselected feature
  } else if (!isFeatureSelected && isShiftClick) {
    // Add it to the selection
    this.select(featureId);
    this.updateUIClasses({ mouse: _constants__WEBPACK_IMPORTED_MODULE_6__["cursors"].MOVE });
  // Click (without shift) on an unselected feature
  } else if (!isFeatureSelected && !isShiftClick) {
    // Make it the only selected feature
    selectedFeatureIds.forEach(id => this.doRender(id));
    this.setSelected(featureId);
    this.updateUIClasses({ mouse: _constants__WEBPACK_IMPORTED_MODULE_6__["cursors"].MOVE });
  }

  // No matter what, re-render the clicked feature
  this.doRender(featureId);
};

SimpleSelect.onMouseDown = function(state, e) {
  if (_lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["isActiveFeature"](e)) return this.startOnActiveFeature(state, e);
  if (this.drawConfig.boxSelect && _lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["isShiftMousedown"](e)) return this.startBoxSelect(state, e);
};

SimpleSelect.startBoxSelect = function(state, e) {
  this.stopExtendedInteractions(state);
  this.map.dragPan.disable();
  // Enable box select
  state.boxSelectStartLocation = Object(_lib_mouse_event_point__WEBPACK_IMPORTED_MODULE_1__["default"])(e.originalEvent, this.map.getContainer());
  state.canBoxSelect = true;
};

SimpleSelect.onTouchStart = function(state, e) {
  if (_lib_common_selectors__WEBPACK_IMPORTED_MODULE_0__["isActiveFeature"](e)) return this.startOnActiveFeature(state, e);
};

SimpleSelect.onDrag = function(state, e) {
  if (state.canDragMove) return this.dragMove(state, e);
  if (this.drawConfig.boxSelect && state.canBoxSelect) return this.whileBoxSelect(state, e);
};

SimpleSelect.whileBoxSelect = function(state, e) {
  state.boxSelecting = true;
  this.updateUIClasses({ mouse: _constants__WEBPACK_IMPORTED_MODULE_6__["cursors"].ADD });

  // Create the box node if it doesn't exist
  if (!state.boxSelectElement) {
    state.boxSelectElement = document.createElement('div');
    state.boxSelectElement.classList.add(_constants__WEBPACK_IMPORTED_MODULE_6__["classes"].BOX_SELECT);
    this.map.getContainer().appendChild(state.boxSelectElement);
  }

  // Adjust the box node's width and xy position
  const current = Object(_lib_mouse_event_point__WEBPACK_IMPORTED_MODULE_1__["default"])(e.originalEvent, this.map.getContainer());
  const minX = Math.min(state.boxSelectStartLocation.x, current.x);
  const maxX = Math.max(state.boxSelectStartLocation.x, current.x);
  const minY = Math.min(state.boxSelectStartLocation.y, current.y);
  const maxY = Math.max(state.boxSelectStartLocation.y, current.y);
  const translateValue = `translate(${minX}px, ${minY}px)`;
  state.boxSelectElement.style.transform = translateValue;
  state.boxSelectElement.style.WebkitTransform = translateValue;
  state.boxSelectElement.style.width = `${maxX - minX}px`;
  state.boxSelectElement.style.height = `${maxY - minY}px`;
};

SimpleSelect.dragMove = function(state, e) {
  // Dragging when drag move is enabled
  state.dragMoving = true;
  e.originalEvent.stopPropagation();

  const delta = {
    lng: e.lngLat.lng - state.dragMoveLocation.lng,
    lat: e.lngLat.lat - state.dragMoveLocation.lat
  };

  Object(_lib_move_features__WEBPACK_IMPORTED_MODULE_5__["default"])(this.getSelected(), delta);

  state.dragMoveLocation = e.lngLat;
};

SimpleSelect.onMouseUp = function(state, e) {
  // End any extended interactions
  if (state.dragMoving) {
    this.fireUpdate();
  } else if (state.boxSelecting) {
    const bbox = [
      state.boxSelectStartLocation,
      Object(_lib_mouse_event_point__WEBPACK_IMPORTED_MODULE_1__["default"])(e.originalEvent, this.map.getContainer())
    ];
    const featuresInBox = this.featuresAt(null, bbox, 'click');
    const idsToSelect = this.getUniqueIds(featuresInBox)
      .filter(id => !this.isSelected(id));

    if (idsToSelect.length) {
      this.select(idsToSelect);
      idsToSelect.forEach(id => this.doRender(id));
      this.updateUIClasses({ mouse: _constants__WEBPACK_IMPORTED_MODULE_6__["cursors"].MOVE });
    }
  }
  this.stopExtendedInteractions(state);
};

SimpleSelect.toDisplayFeatures = function(state, geojson, display) {
  geojson.properties.active = (this.isSelected(geojson.properties.id)) ?
    _constants__WEBPACK_IMPORTED_MODULE_6__["activeStates"].ACTIVE : _constants__WEBPACK_IMPORTED_MODULE_6__["activeStates"].INACTIVE;
  display(geojson);
  this.fireActionable();
  if (geojson.properties.active !== _constants__WEBPACK_IMPORTED_MODULE_6__["activeStates"].ACTIVE ||
    geojson.geometry.type === _constants__WEBPACK_IMPORTED_MODULE_6__["geojsonTypes"].POINT) return;
  Object(_lib_create_supplementary_points__WEBPACK_IMPORTED_MODULE_2__["default"])(geojson).forEach(display);
};

SimpleSelect.onTrash = function() {
  this.deleteFeature(this.getSelectedIds());
  this.fireActionable();
};

SimpleSelect.onCombineFeatures = function() {
  const selectedFeatures = this.getSelected();

  if (selectedFeatures.length === 0 || selectedFeatures.length < 2) return;

  const coordinates = [], featuresCombined = [];
  const featureType = selectedFeatures[0].type.replace('Multi', '');

  for (let i = 0; i < selectedFeatures.length; i++) {
    const feature = selectedFeatures[i];

    if (feature.type.replace('Multi', '') !== featureType) {
      return;
    }
    if (feature.type.includes('Multi')) {
      feature.getCoordinates().forEach((subcoords) => {
        coordinates.push(subcoords);
      });
    } else {
      coordinates.push(feature.getCoordinates());
    }

    featuresCombined.push(feature.toGeoJSON());
  }

  if (featuresCombined.length > 1) {
    const multiFeature = this.newFeature({
      type: _constants__WEBPACK_IMPORTED_MODULE_6__["geojsonTypes"].FEATURE,
      properties: featuresCombined[0].properties,
      geometry: {
        type: `Multi${featureType}`,
        coordinates
      }
    });

    this.addFeature(multiFeature);
    this.deleteFeature(this.getSelectedIds(), { silent: true });
    this.setSelected([multiFeature.id]);

    this.map.fire(_constants__WEBPACK_IMPORTED_MODULE_6__["events"].COMBINE_FEATURES, {
      createdFeatures: [multiFeature.toGeoJSON()],
      deletedFeatures: featuresCombined
    });
  }
  this.fireActionable();
};

SimpleSelect.onUncombineFeatures = function() {
  const selectedFeatures = this.getSelected();
  if (selectedFeatures.length === 0) return;

  const createdFeatures = [];
  const featuresUncombined = [];

  for (let i = 0; i < selectedFeatures.length; i++) {
    const feature = selectedFeatures[i];

    if (this.isInstanceOf('MultiFeature', feature)) {
      feature.getFeatures().forEach((subFeature) => {
        this.addFeature(subFeature);
        subFeature.properties = feature.properties;
        createdFeatures.push(subFeature.toGeoJSON());
        this.select([subFeature.id]);
      });
      this.deleteFeature(feature.id, { silent: true });
      featuresUncombined.push(feature.toGeoJSON());
    }
  }

  if (createdFeatures.length > 1) {
    this.map.fire(_constants__WEBPACK_IMPORTED_MODULE_6__["events"].UNCOMBINE_FEATURES, {
      createdFeatures,
      deletedFeatures: featuresUncombined
    });
  }
  this.fireActionable();
};

/* harmony default export */ __webpack_exports__["default"] = (SimpleSelect);


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/options.js":
/*!************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/options.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var xtend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xtend */ "./node_modules/xtend/immutable.js");
/* harmony import */ var xtend__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(xtend__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "./node_modules/@mapbox/mapbox-gl-draw/src/constants.js");
/* harmony import */ var _lib_theme__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/theme */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/theme.js");
/* harmony import */ var _modes_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modes/index */ "./node_modules/@mapbox/mapbox-gl-draw/src/modes/index.js");






const defaultOptions = {
  defaultMode: _constants__WEBPACK_IMPORTED_MODULE_1__["modes"].SIMPLE_SELECT,
  keybindings: true,
  touchEnabled: true,
  clickBuffer: 2,
  touchBuffer: 25,
  boxSelect: true,
  displayControlsDefault: true,
  styles: _lib_theme__WEBPACK_IMPORTED_MODULE_2__["default"],
  modes: _modes_index__WEBPACK_IMPORTED_MODULE_3__["default"],
  controls: {},
  userProperties: false
};

const showControls = {
  point: true,
  line_string: true,
  polygon: true,
  trash: true,
  combine_features: true,
  uncombine_features: true
};

const hideControls = {
  point: false,
  line_string: false,
  polygon: false,
  trash: false,
  combine_features: false,
  uncombine_features: false
};

function addSources(styles, sourceBucket) {
  return styles.map((style) => {
    if (style.source) return style;
    return xtend__WEBPACK_IMPORTED_MODULE_0___default()(style, {
      id: `${style.id}.${sourceBucket}`,
      source: (sourceBucket === 'hot') ? _constants__WEBPACK_IMPORTED_MODULE_1__["sources"].HOT : _constants__WEBPACK_IMPORTED_MODULE_1__["sources"].COLD
    });
  });
}

/* harmony default export */ __webpack_exports__["default"] = (function(options = {}) {
  let withDefaults = xtend__WEBPACK_IMPORTED_MODULE_0___default()(options);

  if (!options.controls) {
    withDefaults.controls = {};
  }

  if (options.displayControlsDefault === false) {
    withDefaults.controls = xtend__WEBPACK_IMPORTED_MODULE_0___default()(hideControls, options.controls);
  } else {
    withDefaults.controls = xtend__WEBPACK_IMPORTED_MODULE_0___default()(showControls, options.controls);
  }

  withDefaults = xtend__WEBPACK_IMPORTED_MODULE_0___default()(defaultOptions, withDefaults);

  // Layers with a shared source should be adjacent for performance reasons
  withDefaults.styles = addSources(withDefaults.styles, 'cold').concat(addSources(withDefaults.styles, 'hot'));

  return withDefaults;
});


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/render.js":
/*!***********************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/render.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return render; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "./node_modules/@mapbox/mapbox-gl-draw/src/constants.js");


function render() {
  // eslint-disable-next-line no-invalid-this
  const store = this;
  const mapExists = store.ctx.map && store.ctx.map.getSource(_constants__WEBPACK_IMPORTED_MODULE_0__["sources"].HOT) !== undefined;
  if (!mapExists) return cleanup();

  const mode = store.ctx.events.currentModeName();

  store.ctx.ui.queueMapClasses({ mode });

  let newHotIds = [];
  let newColdIds = [];

  if (store.isDirty) {
    newColdIds = store.getAllIds();
  } else {
    newHotIds = store.getChangedIds().filter(id => store.get(id) !== undefined);
    newColdIds = store.sources.hot.filter(geojson => geojson.properties.id && newHotIds.indexOf(geojson.properties.id) === -1 && store.get(geojson.properties.id) !== undefined).map(geojson => geojson.properties.id);
  }

  store.sources.hot = [];
  const lastColdCount = store.sources.cold.length;
  store.sources.cold = store.isDirty ? [] : store.sources.cold.filter((geojson) => {
    const id = geojson.properties.id || geojson.properties.parent;
    return newHotIds.indexOf(id) === -1;
  });

  const coldChanged = lastColdCount !== store.sources.cold.length || newColdIds.length > 0;
  newHotIds.forEach(id => renderFeature(id, 'hot'));
  newColdIds.forEach(id => renderFeature(id, 'cold'));

  function renderFeature(id, source) {
    const feature = store.get(id);
    const featureInternal = feature.internal(mode);
    store.ctx.events.currentModeRender(featureInternal, (geojson) => {
      store.sources[source].push(geojson);
    });
  }

  if (coldChanged) {
    store.ctx.map.getSource(_constants__WEBPACK_IMPORTED_MODULE_0__["sources"].COLD).setData({
      type: _constants__WEBPACK_IMPORTED_MODULE_0__["geojsonTypes"].FEATURE_COLLECTION,
      features: store.sources.cold
    });
  }

  store.ctx.map.getSource(_constants__WEBPACK_IMPORTED_MODULE_0__["sources"].HOT).setData({
    type: _constants__WEBPACK_IMPORTED_MODULE_0__["geojsonTypes"].FEATURE_COLLECTION,
    features: store.sources.hot
  });

  if (store._emitSelectionChange) {
    store.ctx.map.fire(_constants__WEBPACK_IMPORTED_MODULE_0__["events"].SELECTION_CHANGE, {
      features: store.getSelected().map(feature => feature.toGeoJSON()),
      points: store.getSelectedCoordinates().map(coordinate => ({
        type: _constants__WEBPACK_IMPORTED_MODULE_0__["geojsonTypes"].FEATURE,
        properties: {},
        geometry: {
          type: _constants__WEBPACK_IMPORTED_MODULE_0__["geojsonTypes"].POINT,
          coordinates: coordinate.coordinates
        }
      }))
    });
    store._emitSelectionChange = false;
  }

  if (store._deletedFeaturesToEmit.length) {
    const geojsonToEmit = store._deletedFeaturesToEmit.map(feature => feature.toGeoJSON());

    store._deletedFeaturesToEmit = [];

    store.ctx.map.fire(_constants__WEBPACK_IMPORTED_MODULE_0__["events"].DELETE, {
      features: geojsonToEmit
    });
  }

  cleanup();
  store.ctx.map.fire(_constants__WEBPACK_IMPORTED_MODULE_0__["events"].RENDER, {});

  function cleanup() {
    store.isDirty = false;
    store.clearChangedIds();
  }
}


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/setup.js":
/*!**********************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/setup.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events */ "./node_modules/@mapbox/mapbox-gl-draw/src/events.js");
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./store */ "./node_modules/@mapbox/mapbox-gl-draw/src/store.js");
/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ui */ "./node_modules/@mapbox/mapbox-gl-draw/src/ui.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants */ "./node_modules/@mapbox/mapbox-gl-draw/src/constants.js");
/* harmony import */ var xtend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! xtend */ "./node_modules/xtend/immutable.js");
/* harmony import */ var xtend__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(xtend__WEBPACK_IMPORTED_MODULE_4__);






/* harmony default export */ __webpack_exports__["default"] = (function(ctx) {

  let controlContainer = null;
  let mapLoadedInterval = null;

  const setup = {
    onRemove() {
      // Stop connect attempt in the event that control is removed before map is loaded
      ctx.map.off('load', setup.connect);
      clearInterval(mapLoadedInterval);

      setup.removeLayers();
      ctx.store.restoreMapConfig();
      ctx.ui.removeButtons();
      ctx.events.removeEventListeners();
      ctx.ui.clearMapClasses();
      ctx.map = null;
      ctx.container = null;
      ctx.store = null;

      if (controlContainer && controlContainer.parentNode) controlContainer.parentNode.removeChild(controlContainer);
      controlContainer = null;

      return this;
    },
    connect() {
      ctx.map.off('load', setup.connect);
      clearInterval(mapLoadedInterval);
      setup.addLayers();
      ctx.store.storeMapConfig();
      ctx.events.addEventListeners();
    },
    onAdd(map) {
      if (true) {
        // Monkey patch to resolve breaking change to `fire` introduced by
        // mapbox-gl-js. See mapbox/mapbox-gl-draw/issues/766.
        const _fire = map.fire;
        map.fire = function(type, event) {
          // eslint-disable-next-line
          let args = arguments;

          if (_fire.length === 1 && arguments.length !== 1) {
            args = [xtend__WEBPACK_IMPORTED_MODULE_4___default()({}, { type }, event)];
          }

          return _fire.apply(map, args);
        };
      }

      ctx.map = map;
      ctx.events = Object(_events__WEBPACK_IMPORTED_MODULE_0__["default"])(ctx);
      ctx.ui = Object(_ui__WEBPACK_IMPORTED_MODULE_2__["default"])(ctx);
      ctx.container = map.getContainer();
      ctx.store = new _store__WEBPACK_IMPORTED_MODULE_1__["default"](ctx);


      controlContainer = ctx.ui.addButtons();

      if (ctx.options.boxSelect) {
        map.boxZoom.disable();
        // Need to toggle dragPan on and off or else first
        // dragPan disable attempt in simple_select doesn't work
        map.dragPan.disable();
        map.dragPan.enable();
      }

      if (map.loaded()) {
        setup.connect();
      } else {
        map.on('load', setup.connect);
        mapLoadedInterval = setInterval(() => { if (map.loaded()) setup.connect(); }, 16);
      }

      ctx.events.start();
      return controlContainer;
    },
    addLayers() {
      // drawn features style
      ctx.map.addSource(_constants__WEBPACK_IMPORTED_MODULE_3__["sources"].COLD, {
        data: {
          type: _constants__WEBPACK_IMPORTED_MODULE_3__["geojsonTypes"].FEATURE_COLLECTION,
          features: []
        },
        type: 'geojson'
      });

      // hot features style
      ctx.map.addSource(_constants__WEBPACK_IMPORTED_MODULE_3__["sources"].HOT, {
        data: {
          type: _constants__WEBPACK_IMPORTED_MODULE_3__["geojsonTypes"].FEATURE_COLLECTION,
          features: []
        },
        type: 'geojson'
      });

      ctx.options.styles.forEach((style) => {
        ctx.map.addLayer(style);
      });

      ctx.store.setDirty(true);
      ctx.store.render();
    },
    // Check for layers and sources before attempting to remove
    // If user adds draw control and removes it before the map is loaded, layers and sources will be missing
    removeLayers() {
      ctx.options.styles.forEach((style) => {
        if (ctx.map.getLayer(style.id)) {
          ctx.map.removeLayer(style.id);
        }
      });

      if (ctx.map.getSource(_constants__WEBPACK_IMPORTED_MODULE_3__["sources"].COLD)) {
        ctx.map.removeSource(_constants__WEBPACK_IMPORTED_MODULE_3__["sources"].COLD);
      }

      if (ctx.map.getSource(_constants__WEBPACK_IMPORTED_MODULE_3__["sources"].HOT)) {
        ctx.map.removeSource(_constants__WEBPACK_IMPORTED_MODULE_3__["sources"].HOT);
      }
    }
  };

  ctx.setup = setup;

  return setup;
});


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/store.js":
/*!**********************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/store.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Store; });
/* harmony import */ var _lib_to_dense_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/to_dense_array */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/to_dense_array.js");
/* harmony import */ var _lib_string_set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/string_set */ "./node_modules/@mapbox/mapbox-gl-draw/src/lib/string_set.js");
/* harmony import */ var _render__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./render */ "./node_modules/@mapbox/mapbox-gl-draw/src/render.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants */ "./node_modules/@mapbox/mapbox-gl-draw/src/constants.js");





function Store(ctx) {
  this._features = {};
  this._featureIds = new _lib_string_set__WEBPACK_IMPORTED_MODULE_1__["default"]();
  this._selectedFeatureIds = new _lib_string_set__WEBPACK_IMPORTED_MODULE_1__["default"]();
  this._selectedCoordinates = [];
  this._changedFeatureIds = new _lib_string_set__WEBPACK_IMPORTED_MODULE_1__["default"]();
  this._deletedFeaturesToEmit = [];
  this._emitSelectionChange = false;
  this._mapInitialConfig = {};
  this.ctx = ctx;
  this.sources = {
    hot: [],
    cold: []
  };

  // Deduplicate requests to render and tie them to animation frames.
  let renderRequest;
  this.render = () => {
    if (!renderRequest) {
      renderRequest = requestAnimationFrame(() => {
        renderRequest = null;
        _render__WEBPACK_IMPORTED_MODULE_2__["default"].call(this);
      });
    }
  };
  this.isDirty = false;
}


/**
 * Delays all rendering until the returned function is invoked
 * @return {Function} renderBatch
 */
Store.prototype.createRenderBatch = function() {
  const holdRender = this.render;
  let numRenders = 0;
  this.render = function() {
    numRenders++;
  };

  return () => {
    this.render = holdRender;
    if (numRenders > 0) {
      this.render();
    }
  };
};

/**
 * Sets the store's state to dirty.
 * @return {Store} this
 */
Store.prototype.setDirty = function() {
  this.isDirty = true;
  return this;
};

/**
 * Sets a feature's state to changed.
 * @param {string} featureId
 * @return {Store} this
 */
Store.prototype.featureChanged = function(featureId) {
  this._changedFeatureIds.add(featureId);
  return this;
};

/**
 * Gets the ids of all features currently in changed state.
 * @return {Store} this
 */
Store.prototype.getChangedIds = function() {
  return this._changedFeatureIds.values();
};

/**
 * Sets all features to unchanged state.
 * @return {Store} this
 */
Store.prototype.clearChangedIds = function() {
  this._changedFeatureIds.clear();
  return this;
};

/**
 * Gets the ids of all features in the store.
 * @return {Store} this
 */
Store.prototype.getAllIds = function() {
  return this._featureIds.values();
};

/**
 * Adds a feature to the store.
 * @param {Object} feature
 *
 * @return {Store} this
 */
Store.prototype.add = function(feature) {
  this.featureChanged(feature.id);
  this._features[feature.id] = feature;
  this._featureIds.add(feature.id);
  return this;
};

/**
 * Deletes a feature or array of features from the store.
 * Cleans up after the deletion by deselecting the features.
 * If changes were made, sets the state to the dirty
 * and fires an event.
 * @param {string | Array<string>} featureIds
 * @param {Object} [options]
 * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.
 * @return {Store} this
 */
Store.prototype.delete = function(featureIds, options = {}) {
  Object(_lib_to_dense_array__WEBPACK_IMPORTED_MODULE_0__["default"])(featureIds).forEach((id) => {
    if (!this._featureIds.has(id)) return;
    this._featureIds.delete(id);
    this._selectedFeatureIds.delete(id);
    if (!options.silent) {
      if (this._deletedFeaturesToEmit.indexOf(this._features[id]) === -1) {
        this._deletedFeaturesToEmit.push(this._features[id]);
      }
    }
    delete this._features[id];
    this.isDirty = true;
  });
  refreshSelectedCoordinates(this, options);
  return this;
};

/**
 * Returns a feature in the store matching the specified value.
 * @return {Object | undefined} feature
 */
Store.prototype.get = function(id) {
  return this._features[id];
};

/**
 * Returns all features in the store.
 * @return {Array<Object>}
 */
Store.prototype.getAll = function() {
  return Object.keys(this._features).map(id => this._features[id]);
};

/**
 * Adds features to the current selection.
 * @param {string | Array<string>} featureIds
 * @param {Object} [options]
 * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.
 * @return {Store} this
 */
Store.prototype.select = function(featureIds, options = {}) {
  Object(_lib_to_dense_array__WEBPACK_IMPORTED_MODULE_0__["default"])(featureIds).forEach((id) => {
    if (this._selectedFeatureIds.has(id)) return;
    this._selectedFeatureIds.add(id);
    this._changedFeatureIds.add(id);
    if (!options.silent) {
      this._emitSelectionChange = true;
    }
  });
  return this;
};

/**
 * Deletes features from the current selection.
 * @param {string | Array<string>} featureIds
 * @param {Object} [options]
 * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.
 * @return {Store} this
 */
Store.prototype.deselect = function(featureIds, options = {}) {
  Object(_lib_to_dense_array__WEBPACK_IMPORTED_MODULE_0__["default"])(featureIds).forEach((id) => {
    if (!this._selectedFeatureIds.has(id)) return;
    this._selectedFeatureIds.delete(id);
    this._changedFeatureIds.add(id);
    if (!options.silent) {
      this._emitSelectionChange = true;
    }
  });
  refreshSelectedCoordinates(this, options);
  return this;
};

/**
 * Clears the current selection.
 * @param {Object} [options]
 * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.
 * @return {Store} this
 */
Store.prototype.clearSelected = function(options = {}) {
  this.deselect(this._selectedFeatureIds.values(), { silent: options.silent });
  return this;
};

/**
 * Sets the store's selection, clearing any prior values.
 * If no feature ids are passed, the store is just cleared.
 * @param {string | Array<string> | undefined} featureIds
 * @param {Object} [options]
 * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.
 * @return {Store} this
 */
Store.prototype.setSelected = function(featureIds, options = {}) {
  featureIds = Object(_lib_to_dense_array__WEBPACK_IMPORTED_MODULE_0__["default"])(featureIds);

  // Deselect any features not in the new selection
  this.deselect(this._selectedFeatureIds.values().filter(id => featureIds.indexOf(id) === -1), { silent: options.silent });

  // Select any features in the new selection that were not already selected
  this.select(featureIds.filter(id => !this._selectedFeatureIds.has(id)), { silent: options.silent });

  return this;
};

/**
 * Sets the store's coordinates selection, clearing any prior values.
 * @param {Array<Array<string>>} coordinates
 * @return {Store} this
 */
Store.prototype.setSelectedCoordinates = function(coordinates) {
  this._selectedCoordinates = coordinates;
  this._emitSelectionChange = true;
  return this;
};

/**
 * Clears the current coordinates selection.
 * @param {Object} [options]
 * @return {Store} this
 */
Store.prototype.clearSelectedCoordinates = function() {
  this._selectedCoordinates = [];
  this._emitSelectionChange = true;
  return this;
};

/**
 * Returns the ids of features in the current selection.
 * @return {Array<string>} Selected feature ids.
 */
Store.prototype.getSelectedIds = function() {
  return this._selectedFeatureIds.values();
};

/**
 * Returns features in the current selection.
 * @return {Array<Object>} Selected features.
 */
Store.prototype.getSelected = function() {
  return this._selectedFeatureIds.values().map(id => this.get(id));
};

/**
 * Returns selected coordinates in the currently selected feature.
 * @return {Array<Object>} Selected coordinates.
 */
Store.prototype.getSelectedCoordinates = function() {
  const selected = this._selectedCoordinates.map((coordinate) => {
    const feature = this.get(coordinate.feature_id);
    return {
      coordinates: feature.getCoordinate(coordinate.coord_path)
    };
  });
  return selected;
};

/**
 * Indicates whether a feature is selected.
 * @param {string} featureId
 * @return {boolean} `true` if the feature is selected, `false` if not.
 */
Store.prototype.isSelected = function(featureId) {
  return this._selectedFeatureIds.has(featureId);
};

/**
 * Sets a property on the given feature
 * @param {string} featureId
 * @param {string} property property
 * @param {string} property value
*/
Store.prototype.setFeatureProperty = function(featureId, property, value) {
  this.get(featureId).setProperty(property, value);
  this.featureChanged(featureId);
};

function refreshSelectedCoordinates(store, options) {
  const newSelectedCoordinates = store._selectedCoordinates.filter(point => store._selectedFeatureIds.has(point.feature_id));
  if (store._selectedCoordinates.length !== newSelectedCoordinates.length && !options.silent) {
    store._emitSelectionChange = true;
  }
  store._selectedCoordinates = newSelectedCoordinates;
}

/**
 * Stores the initial config for a map, so that we can set it again after we're done.
*/
Store.prototype.storeMapConfig = function() {
  _constants__WEBPACK_IMPORTED_MODULE_3__["interactions"].forEach((interaction) => {
    const interactionSet = this.ctx.map[interaction];
    if (interactionSet) {
      this._mapInitialConfig[interaction] = this.ctx.map[interaction].isEnabled();
    }
  });
};

/**
 * Restores the initial config for a map, ensuring all is well.
*/
Store.prototype.restoreMapConfig = function() {
  Object.keys(this._mapInitialConfig).forEach((key) => {
    const value = this._mapInitialConfig[key];
    if (value) {
      this.ctx.map[key].enable();
    } else {
      this.ctx.map[key].disable();
    }
  });
};

/**
 * Returns the initial state of an interaction setting.
 * @param {string} interaction
 * @return {boolean} `true` if the interaction is enabled, `false` if not.
 * Defaults to `true`. (Todo: include defaults.)
*/
Store.prototype.getInitialConfigValue = function(interaction) {
  if (this._mapInitialConfig[interaction] !== undefined) {
    return this._mapInitialConfig[interaction];
  } else {
    // This needs to be set to whatever the default is for that interaction
    // It seems to be true for all cases currently, so let's send back `true`.
    return true;
  }
};


/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-draw/src/ui.js":
/*!*******************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-draw/src/ui.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var xtend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xtend */ "./node_modules/xtend/immutable.js");
/* harmony import */ var xtend__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(xtend__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "./node_modules/@mapbox/mapbox-gl-draw/src/constants.js");



const classTypes = ['mode', 'feature', 'mouse'];

/* harmony default export */ __webpack_exports__["default"] = (function(ctx) {


  const buttonElements = {};
  let activeButton = null;

  let currentMapClasses = {
    mode: null, // e.g. mode-direct_select
    feature: null, // e.g. feature-vertex
    mouse: null // e.g. mouse-move
  };

  let nextMapClasses = {
    mode: null,
    feature: null,
    mouse: null
  };

  function clearMapClasses() {
    queueMapClasses({mode:null, feature:null, mouse:null});
    updateMapClasses();
  }

  function queueMapClasses(options) {
    nextMapClasses = xtend__WEBPACK_IMPORTED_MODULE_0___default()(nextMapClasses, options);
  }

  function updateMapClasses() {
    if (!ctx.container) return;

    const classesToRemove = [];
    const classesToAdd = [];

    classTypes.forEach((type) => {
      if (nextMapClasses[type] === currentMapClasses[type]) return;

      classesToRemove.push(`${type}-${currentMapClasses[type]}`);
      if (nextMapClasses[type] !== null) {
        classesToAdd.push(`${type}-${nextMapClasses[type]}`);
      }
    });

    if (classesToRemove.length > 0) {
      ctx.container.classList.remove(...classesToRemove);
    }

    if (classesToAdd.length > 0) {
      ctx.container.classList.add(...classesToAdd);
    }

    currentMapClasses = xtend__WEBPACK_IMPORTED_MODULE_0___default()(currentMapClasses, nextMapClasses);
  }

  function createControlButton(id, options = {}) {
    const button = document.createElement('button');
    button.className = `${_constants__WEBPACK_IMPORTED_MODULE_1__["classes"].CONTROL_BUTTON} ${options.className}`;
    button.setAttribute('title', options.title);
    options.container.appendChild(button);

    button.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();

      const clickedButton = e.target;
      if (clickedButton === activeButton) {
        deactivateButtons();
        options.onDeactivate();
        return;
      }

      setActiveButton(id);
      options.onActivate();
    }, true);

    return button;
  }

  function deactivateButtons() {
    if (!activeButton) return;
    activeButton.classList.remove(_constants__WEBPACK_IMPORTED_MODULE_1__["classes"].ACTIVE_BUTTON);
    activeButton = null;
  }

  function setActiveButton(id) {
    deactivateButtons();

    const button = buttonElements[id];
    if (!button) return;

    if (button && id !== 'trash') {
      button.classList.add(_constants__WEBPACK_IMPORTED_MODULE_1__["classes"].ACTIVE_BUTTON);
      activeButton = button;
    }
  }

  function addButtons() {
    const controls = ctx.options.controls;
    const controlGroup = document.createElement('div');
    controlGroup.className = `${_constants__WEBPACK_IMPORTED_MODULE_1__["classes"].CONTROL_GROUP} ${_constants__WEBPACK_IMPORTED_MODULE_1__["classes"].CONTROL_BASE}`;

    if (!controls) return controlGroup;

    if (controls[_constants__WEBPACK_IMPORTED_MODULE_1__["types"].LINE]) {
      buttonElements[_constants__WEBPACK_IMPORTED_MODULE_1__["types"].LINE] = createControlButton(_constants__WEBPACK_IMPORTED_MODULE_1__["types"].LINE, {
        container: controlGroup,
        className: _constants__WEBPACK_IMPORTED_MODULE_1__["classes"].CONTROL_BUTTON_LINE,
        title: `LineString tool ${ctx.options.keybindings ? '(l)' : ''}`,
        onActivate: () => ctx.events.changeMode(_constants__WEBPACK_IMPORTED_MODULE_1__["modes"].DRAW_LINE_STRING),
        onDeactivate: () => ctx.events.trash()
      });
    }

    if (controls[_constants__WEBPACK_IMPORTED_MODULE_1__["types"].POLYGON]) {
      buttonElements[_constants__WEBPACK_IMPORTED_MODULE_1__["types"].POLYGON] = createControlButton(_constants__WEBPACK_IMPORTED_MODULE_1__["types"].POLYGON, {
        container: controlGroup,
        className: _constants__WEBPACK_IMPORTED_MODULE_1__["classes"].CONTROL_BUTTON_POLYGON,
        title: `Polygon tool ${ctx.options.keybindings ? '(p)' : ''}`,
        onActivate: () => ctx.events.changeMode(_constants__WEBPACK_IMPORTED_MODULE_1__["modes"].DRAW_POLYGON),
        onDeactivate: () => ctx.events.trash()
      });
    }

    if (controls[_constants__WEBPACK_IMPORTED_MODULE_1__["types"].POINT]) {
      buttonElements[_constants__WEBPACK_IMPORTED_MODULE_1__["types"].POINT] = createControlButton(_constants__WEBPACK_IMPORTED_MODULE_1__["types"].POINT, {
        container: controlGroup,
        className: _constants__WEBPACK_IMPORTED_MODULE_1__["classes"].CONTROL_BUTTON_POINT,
        title: `Marker tool ${ctx.options.keybindings ? '(m)' : ''}`,
        onActivate: () => ctx.events.changeMode(_constants__WEBPACK_IMPORTED_MODULE_1__["modes"].DRAW_POINT),
        onDeactivate: () => ctx.events.trash()
      });
    }

    if (controls.trash) {
      buttonElements.trash = createControlButton('trash', {
        container: controlGroup,
        className: _constants__WEBPACK_IMPORTED_MODULE_1__["classes"].CONTROL_BUTTON_TRASH,
        title: 'Delete',
        onActivate: () => {
          ctx.events.trash();
        }
      });
    }

    if (controls.combine_features) {
      buttonElements.combine_features = createControlButton('combineFeatures', {
        container: controlGroup,
        className: _constants__WEBPACK_IMPORTED_MODULE_1__["classes"].CONTROL_BUTTON_COMBINE_FEATURES,
        title: 'Combine',
        onActivate: () => {
          ctx.events.combineFeatures();
        }
      });
    }

    if (controls.uncombine_features) {
      buttonElements.uncombine_features = createControlButton('uncombineFeatures', {
        container: controlGroup,
        className: _constants__WEBPACK_IMPORTED_MODULE_1__["classes"].CONTROL_BUTTON_UNCOMBINE_FEATURES,
        title: 'Uncombine',
        onActivate: () => {
          ctx.events.uncombineFeatures();
        }
      });
    }

    return controlGroup;
  }

  function removeButtons() {
    Object.keys(buttonElements).forEach((buttonId) => {
      const button = buttonElements[buttonId];
      if (button.parentNode) {
        button.parentNode.removeChild(button);
      }
      delete buttonElements[buttonId];
    });
  }

  return {
    setActiveButton,
    queueMapClasses,
    updateMapClasses,
    clearMapClasses,
    addButtons,
    removeButtons
  };
});


/***/ }),

/***/ "./node_modules/@mapbox/point-geometry/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@mapbox/point-geometry/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Point;

/**
 * A standalone point geometry with useful accessor, comparison, and
 * modification methods.
 *
 * @class Point
 * @param {Number} x the x-coordinate. this could be longitude or screen
 * pixels, or any other sort of unit.
 * @param {Number} y the y-coordinate. this could be latitude or screen
 * pixels, or any other sort of unit.
 * @example
 * var point = new Point(-77, 38);
 */
function Point(x, y) {
    this.x = x;
    this.y = y;
}

Point.prototype = {

    /**
     * Clone this point, returning a new point that can be modified
     * without affecting the old one.
     * @return {Point} the clone
     */
    clone: function() { return new Point(this.x, this.y); },

    /**
     * Add this point's x & y coordinates to another point,
     * yielding a new point.
     * @param {Point} p the other point
     * @return {Point} output point
     */
    add:     function(p) { return this.clone()._add(p); },

    /**
     * Subtract this point's x & y coordinates to from point,
     * yielding a new point.
     * @param {Point} p the other point
     * @return {Point} output point
     */
    sub:     function(p) { return this.clone()._sub(p); },

    /**
     * Multiply this point's x & y coordinates by point,
     * yielding a new point.
     * @param {Point} p the other point
     * @return {Point} output point
     */
    multByPoint:    function(p) { return this.clone()._multByPoint(p); },

    /**
     * Divide this point's x & y coordinates by point,
     * yielding a new point.
     * @param {Point} p the other point
     * @return {Point} output point
     */
    divByPoint:     function(p) { return this.clone()._divByPoint(p); },

    /**
     * Multiply this point's x & y coordinates by a factor,
     * yielding a new point.
     * @param {Point} k factor
     * @return {Point} output point
     */
    mult:    function(k) { return this.clone()._mult(k); },

    /**
     * Divide this point's x & y coordinates by a factor,
     * yielding a new point.
     * @param {Point} k factor
     * @return {Point} output point
     */
    div:     function(k) { return this.clone()._div(k); },

    /**
     * Rotate this point around the 0, 0 origin by an angle a,
     * given in radians
     * @param {Number} a angle to rotate around, in radians
     * @return {Point} output point
     */
    rotate:  function(a) { return this.clone()._rotate(a); },

    /**
     * Rotate this point around p point by an angle a,
     * given in radians
     * @param {Number} a angle to rotate around, in radians
     * @param {Point} p Point to rotate around
     * @return {Point} output point
     */
    rotateAround:  function(a,p) { return this.clone()._rotateAround(a,p); },

    /**
     * Multiply this point by a 4x1 transformation matrix
     * @param {Array<Number>} m transformation matrix
     * @return {Point} output point
     */
    matMult: function(m) { return this.clone()._matMult(m); },

    /**
     * Calculate this point but as a unit vector from 0, 0, meaning
     * that the distance from the resulting point to the 0, 0
     * coordinate will be equal to 1 and the angle from the resulting
     * point to the 0, 0 coordinate will be the same as before.
     * @return {Point} unit vector point
     */
    unit:    function() { return this.clone()._unit(); },

    /**
     * Compute a perpendicular point, where the new y coordinate
     * is the old x coordinate and the new x coordinate is the old y
     * coordinate multiplied by -1
     * @return {Point} perpendicular point
     */
    perp:    function() { return this.clone()._perp(); },

    /**
     * Return a version of this point with the x & y coordinates
     * rounded to integers.
     * @return {Point} rounded point
     */
    round:   function() { return this.clone()._round(); },

    /**
     * Return the magitude of this point: this is the Euclidean
     * distance from the 0, 0 coordinate to this point's x and y
     * coordinates.
     * @return {Number} magnitude
     */
    mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },

    /**
     * Judge whether this point is equal to another point, returning
     * true or false.
     * @param {Point} other the other point
     * @return {boolean} whether the points are equal
     */
    equals: function(other) {
        return this.x === other.x &&
               this.y === other.y;
    },

    /**
     * Calculate the distance from this point to another point
     * @param {Point} p the other point
     * @return {Number} distance
     */
    dist: function(p) {
        return Math.sqrt(this.distSqr(p));
    },

    /**
     * Calculate the distance from this point to another point,
     * without the square root step. Useful if you're comparing
     * relative distances.
     * @param {Point} p the other point
     * @return {Number} distance
     */
    distSqr: function(p) {
        var dx = p.x - this.x,
            dy = p.y - this.y;
        return dx * dx + dy * dy;
    },

    /**
     * Get the angle from the 0, 0 coordinate to this point, in radians
     * coordinates.
     * @return {Number} angle
     */
    angle: function() {
        return Math.atan2(this.y, this.x);
    },

    /**
     * Get the angle from this point to another point, in radians
     * @param {Point} b the other point
     * @return {Number} angle
     */
    angleTo: function(b) {
        return Math.atan2(this.y - b.y, this.x - b.x);
    },

    /**
     * Get the angle between this point and another point, in radians
     * @param {Point} b the other point
     * @return {Number} angle
     */
    angleWith: function(b) {
        return this.angleWithSep(b.x, b.y);
    },

    /*
     * Find the angle of the two vectors, solving the formula for
     * the cross product a x b = |a||b|sin() for .
     * @param {Number} x the x-coordinate
     * @param {Number} y the y-coordinate
     * @return {Number} the angle in radians
     */
    angleWithSep: function(x, y) {
        return Math.atan2(
            this.x * y - this.y * x,
            this.x * x + this.y * y);
    },

    _matMult: function(m) {
        var x = m[0] * this.x + m[1] * this.y,
            y = m[2] * this.x + m[3] * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _add: function(p) {
        this.x += p.x;
        this.y += p.y;
        return this;
    },

    _sub: function(p) {
        this.x -= p.x;
        this.y -= p.y;
        return this;
    },

    _mult: function(k) {
        this.x *= k;
        this.y *= k;
        return this;
    },

    _div: function(k) {
        this.x /= k;
        this.y /= k;
        return this;
    },

    _multByPoint: function(p) {
        this.x *= p.x;
        this.y *= p.y;
        return this;
    },

    _divByPoint: function(p) {
        this.x /= p.x;
        this.y /= p.y;
        return this;
    },

    _unit: function() {
        this._div(this.mag());
        return this;
    },

    _perp: function() {
        var y = this.y;
        this.y = this.x;
        this.x = -y;
        return this;
    },

    _rotate: function(angle) {
        var cos = Math.cos(angle),
            sin = Math.sin(angle),
            x = cos * this.x - sin * this.y,
            y = sin * this.x + cos * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _rotateAround: function(angle, p) {
        var cos = Math.cos(angle),
            sin = Math.sin(angle),
            x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y),
            y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);
        this.x = x;
        this.y = y;
        return this;
    },

    _round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
};

/**
 * Construct a point from an array if necessary, otherwise if the input
 * is already a Point, or an unknown type, return it unchanged
 * @param {Array<Number>|Point|*} a any kind of input value
 * @return {Point} constructed point, or passed-through value.
 * @example
 * // this
 * var point = Point.convert([0, 1]);
 * // is equivalent to
 * var point = new Point(0, 1);
 */
Point.convert = function (a) {
    if (a instanceof Point) {
        return a;
    }
    if (Array.isArray(a)) {
        return new Point(a[0], a[1]);
    }
    return a;
};


/***/ }),

/***/ "./node_modules/geojson-flatten/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/geojson-flatten/dist/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports=function e(t){switch(t&&t.type||null){case"FeatureCollection":return t.features=t.features.reduce(function(t,r){return t.concat(e(r))},[]),t;case"Feature":return t.geometry?e(t.geometry).map(function(e){var r={type:"Feature",properties:JSON.parse(JSON.stringify(t.properties)),geometry:e};return void 0!==t.id&&(r.id=t.id),r}):t;case"MultiPoint":return t.coordinates.map(function(e){return{type:"Point",coordinates:e}});case"MultiPolygon":return t.coordinates.map(function(e){return{type:"Polygon",coordinates:e}});case"MultiLineString":return t.coordinates.map(function(e){return{type:"LineString",coordinates:e}});case"GeometryCollection":return t.geometries.map(e).reduce(function(e,t){return e.concat(t)},[]);case"Point":case"Polygon":case"LineString":return[t]}};
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/hat/index.js":
/*!***********************************!*\
  !*** ./node_modules/hat/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hat = module.exports = function (bits, base) {
    if (!base) base = 16;
    if (bits === undefined) bits = 128;
    if (bits <= 0) return '0';
    
    var digits = Math.log(Math.pow(2, bits)) / Math.log(base);
    for (var i = 2; digits === Infinity; i *= 2) {
        digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;
    }
    
    var rem = digits - Math.floor(digits);
    
    var res = '';
    
    for (var i = 0; i < Math.floor(digits); i++) {
        var x = Math.floor(Math.random() * base).toString(base);
        res = x + res;
    }
    
    if (rem) {
        var b = Math.pow(base, rem);
        var x = Math.floor(Math.random() * b).toString(base);
        res = x + res;
    }
    
    var parsed = parseInt(res, base);
    if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {
        return hat(bits, base)
    }
    else return res;
};

hat.rack = function (bits, base, expandBy) {
    var fn = function (data) {
        var iters = 0;
        do {
            if (iters ++ > 10) {
                if (expandBy) bits += expandBy;
                else throw new Error('too many ID collisions, use more bits')
            }
            
            var id = hat(bits, base);
        } while (Object.hasOwnProperty.call(hats, id));
        
        hats[id] = data;
        return id;
    };
    var hats = fn.hats = {};
    
    fn.get = function (id) {
        return fn.hats[id];
    };
    
    fn.set = function (id, value) {
        fn.hats[id] = value;
        return fn;
    };
    
    fn.bits = bits || 128;
    fn.base = base || 16;
    return fn;
};


/***/ }),

/***/ "./node_modules/jsonlint-lines/lib/jsonlint.js":
/*!*****************************************************!*\
  !*** ./node_modules/jsonlint-lines/lib/jsonlint.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {/* parser generated by jison 0.4.17 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var jsonlint = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,12],$V1=[1,13],$V2=[1,9],$V3=[1,10],$V4=[1,11],$V5=[1,14],$V6=[1,15],$V7=[14,18,22,24],$V8=[18,22],$V9=[22,24];
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"JSONString":3,"STRING":4,"JSONNumber":5,"NUMBER":6,"JSONNullLiteral":7,"NULL":8,"JSONBooleanLiteral":9,"TRUE":10,"FALSE":11,"JSONText":12,"JSONValue":13,"EOF":14,"JSONObject":15,"JSONArray":16,"{":17,"}":18,"JSONMemberList":19,"JSONMember":20,":":21,",":22,"[":23,"]":24,"JSONElementList":25,"$accept":0,"$end":1},
terminals_: {2:"error",4:"STRING",6:"NUMBER",8:"NULL",10:"TRUE",11:"FALSE",14:"EOF",17:"{",18:"}",21:":",22:",",23:"[",24:"]"},
productions_: [0,[3,1],[5,1],[7,1],[9,1],[9,1],[12,2],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[15,2],[15,3],[20,3],[19,1],[19,3],[16,2],[16,3],[25,1],[25,3]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
 // replace escaped characters with actual character
          this.$ = yytext.replace(/\\(\\|")/g, "$"+"1")
                     .replace(/\\n/g,'\n')
                     .replace(/\\r/g,'\r')
                     .replace(/\\t/g,'\t')
                     .replace(/\\v/g,'\v')
                     .replace(/\\f/g,'\f')
                     .replace(/\\b/g,'\b');
        
break;
case 2:
this.$ = Number(yytext);
break;
case 3:
this.$ = null;
break;
case 4:
this.$ = true;
break;
case 5:
this.$ = false;
break;
case 6:
return this.$ = $$[$0-1];
break;
case 13:
this.$ = {}; Object.defineProperty(this.$, '__line__', {
            value: this._$.first_line,
            enumerable: false
        })
break;
case 14: case 19:
this.$ = $$[$0-1]; Object.defineProperty(this.$, '__line__', {
            value: this._$.first_line,
            enumerable: false
        })
break;
case 15:
this.$ = [$$[$0-2], $$[$0]];
break;
case 16:
this.$ = {}; this.$[$$[$0][0]] = $$[$0][1];
break;
case 17:

            this.$ = $$[$0-2];
            if ($$[$0-2][$$[$0][0]] !== undefined) {
                if (!this.$.__duplicateProperties__) {
                    Object.defineProperty(this.$, '__duplicateProperties__', {
                        value: [],
                        enumerable: false
                    });
                }
                this.$.__duplicateProperties__.push($$[$0][0]);
            }
            $$[$0-2][$$[$0][0]] = $$[$0][1];
        
break;
case 18:
this.$ = []; Object.defineProperty(this.$, '__line__', {
            value: this._$.first_line,
            enumerable: false
        })
break;
case 20:
this.$ = [$$[$0]];
break;
case 21:
this.$ = $$[$0-2]; $$[$0-2].push($$[$0]);
break;
}
},
table: [{3:5,4:$V0,5:6,6:$V1,7:3,8:$V2,9:4,10:$V3,11:$V4,12:1,13:2,15:7,16:8,17:$V5,23:$V6},{1:[3]},{14:[1,16]},o($V7,[2,7]),o($V7,[2,8]),o($V7,[2,9]),o($V7,[2,10]),o($V7,[2,11]),o($V7,[2,12]),o($V7,[2,3]),o($V7,[2,4]),o($V7,[2,5]),o([14,18,21,22,24],[2,1]),o($V7,[2,2]),{3:20,4:$V0,18:[1,17],19:18,20:19},{3:5,4:$V0,5:6,6:$V1,7:3,8:$V2,9:4,10:$V3,11:$V4,13:23,15:7,16:8,17:$V5,23:$V6,24:[1,21],25:22},{1:[2,6]},o($V7,[2,13]),{18:[1,24],22:[1,25]},o($V8,[2,16]),{21:[1,26]},o($V7,[2,18]),{22:[1,28],24:[1,27]},o($V9,[2,20]),o($V7,[2,14]),{3:20,4:$V0,20:29},{3:5,4:$V0,5:6,6:$V1,7:3,8:$V2,9:4,10:$V3,11:$V4,13:30,15:7,16:8,17:$V5,23:$V6},o($V7,[2,19]),{3:5,4:$V0,5:6,6:$V1,7:3,8:$V2,9:4,10:$V3,11:$V4,13:31,15:7,16:8,17:$V5,23:$V6},o($V8,[2,17]),o($V8,[2,15]),o($V9,[2,21])],
defaultActions: {16:[2,6]},
parseError: function parseError(str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        function _parseError (msg, hash) {
            this.message = msg;
            this.hash = hash;
        }
        _parseError.prototype = Error;

        throw new _parseError(str, hash);
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    _token_stack:
        var lex = function () {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        };
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};
/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function (match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex() {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState(condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0:/* skip whitespace */
break;
case 1:return 6
break;
case 2:yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2); return 4
break;
case 3:return 17
break;
case 4:return 18
break;
case 5:return 23
break;
case 6:return 24
break;
case 7:return 22
break;
case 8:return 21
break;
case 9:return 10
break;
case 10:return 11
break;
case 11:return 8
break;
case 12:return 14
break;
case 13:return 'INVALID'
break;
}
},
rules: [/^(?:\s+)/,/^(?:(-?([0-9]|[1-9][0-9]+))(\.[0-9]+)?([eE][-+]?[0-9]+)?\b)/,/^(?:"(?:\\[\\"bfnrt\/]|\\u[a-fA-F0-9]{4}|[^\\\0-\x09\x0a-\x1f"])*")/,/^(?:\{)/,/^(?:\})/,/^(?:\[)/,/^(?:\])/,/^(?:,)/,/^(?::)/,/^(?:true\b)/,/^(?:false\b)/,/^(?:null\b)/,/^(?:$)/,/^(?:.)/],
conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (true) {
exports.parser = jsonlint;
exports.Parser = jsonlint.Parser;
exports.parse = function () { return jsonlint.parse.apply(jsonlint, arguments); };
exports.main = function commonjsMain(args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = __webpack_require__(/*! fs */ 4).readFileSync(__webpack_require__(/*! path */ 5).normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if ( true && __webpack_require__.c[__webpack_require__.s] === module) {
  exports.main(process.argv.slice(1));
}
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash.isequal/index.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash.isequal/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    asyncTag = '[object AsyncFunction]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    nullTag = '[object Null]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    proxyTag = '[object Proxy]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    undefinedTag = '[object Undefined]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice,
    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = isEqual;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/index.js ***!
  \*****************************************************/
/*! exports provided: CircleMode, DragCircleMode, DirectMode, SimpleSelectMode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CircleMode", function() { return CircleMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DragCircleMode", function() { return DragCircleMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectMode", function() { return DirectMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SimpleSelectMode", function() { return SimpleSelectMode; });
const CircleMode = __webpack_require__(/*! ./lib/modes/CircleMode */ "./node_modules/mapbox-gl-draw-circle/lib/modes/CircleMode.js");
const DragCircleMode = __webpack_require__(/*! ./lib/modes/DragCircleMode */ "./node_modules/mapbox-gl-draw-circle/lib/modes/DragCircleMode.js");
const DirectMode = __webpack_require__(/*! ./lib/modes/DirectModeOverride */ "./node_modules/mapbox-gl-draw-circle/lib/modes/DirectModeOverride.js");
const SimpleSelectMode = __webpack_require__(/*! ./lib/modes/SimpleSelectModeOverride */ "./node_modules/mapbox-gl-draw-circle/lib/modes/SimpleSelectModeOverride.js");


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/lib/modes/CircleMode.js":
/*!********************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/lib/modes/CircleMode.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const MapboxDraw = __webpack_require__(/*! @mapbox/mapbox-gl-draw */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/index.js");
const Constants = __webpack_require__(/*! @mapbox/mapbox-gl-draw/src/constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");
const doubleClickZoom = __webpack_require__(/*! @mapbox/mapbox-gl-draw/src/lib/double_click_zoom */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/double_click_zoom.js");
const circle = __webpack_require__(/*! @turf/circle */ "./node_modules/mapbox-gl-draw-circle/node_modules/@turf/circle/dist/es/index.js").default;

const CircleMode = {...MapboxDraw.modes.draw_polygon};
const DEFAULT_RADIUS_IN_KM = 2;

CircleMode.onSetup = function(opts) {
  const polygon = this.newFeature({
    type: Constants.geojsonTypes.FEATURE,
    properties: {
      isCircle: true,
      center: []
    },
    geometry: {
      type: Constants.geojsonTypes.POLYGON,
      coordinates: [[]]
    }
  });

  this.addFeature(polygon);

  this.clearSelectedFeatures();
  doubleClickZoom.disable(this);
  this.updateUIClasses({ mouse: Constants.cursors.ADD });
  this.activateUIButton(Constants.types.POLYGON);
  this.setActionableState({
    trash: true
  });

  return {
    initialRadiusInKm: opts.initialRadiusInKm || DEFAULT_RADIUS_IN_KM,
    polygon,
    currentVertexPosition: 0
  };
};

CircleMode.clickAnywhere = function(state, e) {
  if (state.currentVertexPosition === 0) {
    state.currentVertexPosition++;
    const center = [e.lngLat.lng, e.lngLat.lat];
    const circleFeature = circle(center, state.initialRadiusInKm);
    state.polygon.incomingCoords(circleFeature.geometry.coordinates);
    state.polygon.properties.center = center;
    state.polygon.properties.radiusInKm = state.initialRadiusInKm;
  }
  return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.polygon.id] });
};

module.exports = CircleMode;

/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/lib/modes/DirectModeOverride.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/lib/modes/DirectModeOverride.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const MapboxDraw = __webpack_require__(/*! @mapbox/mapbox-gl-draw */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/index.js");
const createSupplementaryPoints = __webpack_require__(/*! @mapbox/mapbox-gl-draw/src/lib/create_supplementary_points */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/create_supplementary_points.js");
const moveFeatures = __webpack_require__(/*! @mapbox/mapbox-gl-draw/src/lib/move_features */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/move_features.js");
const Constants = __webpack_require__(/*! @mapbox/mapbox-gl-draw/src/constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");
const constrainFeatureMovement = __webpack_require__(/*! @mapbox/mapbox-gl-draw/src/lib/constrain_feature_movement */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/constrain_feature_movement.js");
const distance = __webpack_require__(/*! @turf/distance */ "./node_modules/mapbox-gl-draw-circle/node_modules/@turf/distance/dist/es/index.js").default;
const turfHelpers = __webpack_require__(/*! @turf/helpers */ "./node_modules/mapbox-gl-draw-circle/node_modules/@turf/helpers/dist/es/index.js");
const circle = __webpack_require__(/*! @turf/circle */ "./node_modules/mapbox-gl-draw-circle/node_modules/@turf/circle/dist/es/index.js").default;
const createSupplementaryPointsForCircle = __webpack_require__(/*! ../utils/create_supplementary_points_circle */ "./node_modules/mapbox-gl-draw-circle/lib/utils/create_supplementary_points_circle.js");


const DirectModeOverride = MapboxDraw.modes.direct_select;

DirectModeOverride.dragFeature = function(state, e, delta) {
  moveFeatures(this.getSelected(), delta);
  this.getSelected()
    .filter(feature => feature.properties.isCircle)
    .map(circle => circle.properties.center)
    .forEach(center => {
      center[0] += delta.lng;
      center[1] += delta.lat;
    });
  state.dragMoveLocation = e.lngLat;
};

DirectModeOverride.dragVertex = function(state, e, delta) {
  if (state.feature.properties.isCircle) {
    const center = state.feature.properties.center;
    const movedVertex = [e.lngLat.lng, e.lngLat.lat];
    const radius = distance(turfHelpers.point(center), turfHelpers.point(movedVertex), {units: 'kilometers'});
    const circleFeature = circle(center, radius);
    state.feature.incomingCoords(circleFeature.geometry.coordinates);
    state.feature.properties.radiusInKm = radius;
  } else {
    const selectedCoords = state.selectedCoordPaths.map(coord_path => state.feature.getCoordinate(coord_path));
    const selectedCoordPoints = selectedCoords.map(coords => ({
      type: Constants.geojsonTypes.FEATURE,
      properties: {},
      geometry: {
        type: Constants.geojsonTypes.POINT,
        coordinates: coords
      }
    }));

    const constrainedDelta = constrainFeatureMovement(selectedCoordPoints, delta);
    for (let i = 0; i < selectedCoords.length; i++) {
      const coord = selectedCoords[i];
      state.feature.updateCoordinate(state.selectedCoordPaths[i], coord[0] + constrainedDelta.lng, coord[1] + constrainedDelta.lat);
    }
  }
};

DirectModeOverride.toDisplayFeatures = function (state, geojson, push) {
  if (state.featureId === geojson.properties.id) {
    geojson.properties.active = Constants.activeStates.ACTIVE;
    push(geojson);
    const supplementaryPoints = geojson.properties.user_isCircle ? createSupplementaryPointsForCircle(geojson)
      : createSupplementaryPoints(geojson, {
        map: this.map,
        midpoints: true,
        selectedPaths: state.selectedCoordPaths
      });
    supplementaryPoints.forEach(push);
  } else {
    geojson.properties.active = Constants.activeStates.INACTIVE;
    push(geojson);
  }
  this.fireActionable(state);

}

module.exports = DirectModeOverride;

/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/lib/modes/DragCircleMode.js":
/*!************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/lib/modes/DragCircleMode.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const MapboxDraw = __webpack_require__(/*! @mapbox/mapbox-gl-draw */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/index.js");
const Constants = __webpack_require__(/*! @mapbox/mapbox-gl-draw/src/constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");
const doubleClickZoom = __webpack_require__(/*! @mapbox/mapbox-gl-draw/src/lib/double_click_zoom */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/double_click_zoom.js");
const dragPan = __webpack_require__(/*! ../utils/drag_pan */ "./node_modules/mapbox-gl-draw-circle/lib/utils/drag_pan.js");
const circle = __webpack_require__(/*! @turf/circle */ "./node_modules/mapbox-gl-draw-circle/node_modules/@turf/circle/dist/es/index.js").default;
const distance = __webpack_require__(/*! @turf/distance */ "./node_modules/mapbox-gl-draw-circle/node_modules/@turf/distance/dist/es/index.js").default;
const turfHelpers = __webpack_require__(/*! @turf/helpers */ "./node_modules/mapbox-gl-draw-circle/node_modules/@turf/helpers/dist/es/index.js");

const DragCircleMode = {...MapboxDraw.modes.draw_polygon};

DragCircleMode.onSetup = function(opts) {
  const polygon = this.newFeature({
    type: Constants.geojsonTypes.FEATURE,
    properties: {
      isCircle: true,
      center: []
    },
    geometry: {
      type: Constants.geojsonTypes.POLYGON,
      coordinates: [[]]
    }
  });

  this.addFeature(polygon);

  this.clearSelectedFeatures();
  doubleClickZoom.disable(this);
  dragPan.disable(this);
  this.updateUIClasses({ mouse: Constants.cursors.ADD });
  this.activateUIButton(Constants.types.POLYGON);
  this.setActionableState({
    trash: true
  });

  return {
    polygon,
    currentVertexPosition: 0
  };
};

DragCircleMode.onMouseDown = DragCircleMode.onTouchStart = function (state, e) {
  const currentCenter = state.polygon.properties.center;
  if (currentCenter.length === 0) {
    state.polygon.properties.center = [e.lngLat.lng, e.lngLat.lat];
  }
};

DragCircleMode.onDrag = DragCircleMode.onMouseMove = function (state, e) {
  const center = state.polygon.properties.center;
  if (center.length > 0) {
    const distanceInKm = distance(
      turfHelpers.point(center),
      turfHelpers.point([e.lngLat.lng, e.lngLat.lat]),
      { units : 'kilometers'});
    const circleFeature = circle(center, distanceInKm);
    state.polygon.incomingCoords(circleFeature.geometry.coordinates);
    state.polygon.properties.radiusInKm = distanceInKm;
  }
};

DragCircleMode.onMouseUp = DragCircleMode.onTouchEnd = function (state, e) {
  dragPan.enable(this);
  return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.polygon.id] });
};

DragCircleMode.onClick = DragCircleMode.onTap = function (state, e) {
  // don't draw the circle if its a tap or click event
  state.polygon.properties.center = [];
};

DragCircleMode.toDisplayFeatures = function(state, geojson, display) {
  const isActivePolygon = geojson.properties.id === state.polygon.id;
  geojson.properties.active = (isActivePolygon) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;
  return display(geojson);
};

module.exports = DragCircleMode;

/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/lib/modes/SimpleSelectModeOverride.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/lib/modes/SimpleSelectModeOverride.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const MapboxDraw = __webpack_require__(/*! @mapbox/mapbox-gl-draw */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/index.js");
const createSupplementaryPoints = __webpack_require__(/*! @mapbox/mapbox-gl-draw/src/lib/create_supplementary_points */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/create_supplementary_points.js");
const moveFeatures = __webpack_require__(/*! @mapbox/mapbox-gl-draw/src/lib/move_features */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/move_features.js");
const Constants = __webpack_require__(/*! @mapbox/mapbox-gl-draw/src/constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");
const createSupplementaryPointsForCircle = __webpack_require__(/*! ../utils/create_supplementary_points_circle */ "./node_modules/mapbox-gl-draw-circle/lib/utils/create_supplementary_points_circle.js");


const SimpleSelectModeOverride = MapboxDraw.modes.simple_select;

SimpleSelectModeOverride.dragMove = function(state, e) {
  // Dragging when drag move is enabled
  state.dragMoving = true;
  e.originalEvent.stopPropagation();

  const delta = {
    lng: e.lngLat.lng - state.dragMoveLocation.lng,
    lat: e.lngLat.lat - state.dragMoveLocation.lat
  };

  moveFeatures(this.getSelected(), delta);

  this.getSelected()
    .filter(feature => feature.properties.isCircle)
    .map(circle => circle.properties.center)
    .forEach(center => {
      center[0] += delta.lng;
      center[1] += delta.lat;
    });

  state.dragMoveLocation = e.lngLat;
};

SimpleSelectModeOverride.toDisplayFeatures = function(state, geojson, display) {
    geojson.properties.active = (this.isSelected(geojson.properties.id)) ?
      Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;
    display(geojson);
    this.fireActionable();
    if (geojson.properties.active !== Constants.activeStates.ACTIVE ||
      geojson.geometry.type === Constants.geojsonTypes.POINT) return;
    const supplementaryPoints = geojson.properties.user_isCircle ?
      createSupplementaryPointsForCircle(geojson) : createSupplementaryPoints(geojson);
    supplementaryPoints.forEach(display);
};
  
module.exports = SimpleSelectModeOverride;

/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/lib/utils/create_supplementary_points_circle.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/lib/utils/create_supplementary_points_circle.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const createVertex = __webpack_require__(/*! @mapbox/mapbox-gl-draw/src/lib/create_vertex */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/create_vertex.js");

function createSupplementaryPointsForCircle(geojson) {
  const { properties, geometry } = geojson;

  if (!properties.user_isCircle) return null;

  const supplementaryPoints = [];
  const vertices = geometry.coordinates[0].slice(0, -1);
  for (let index = 0; index < vertices.length; index += Math.round((vertices.length / 4))) {
    supplementaryPoints.push(createVertex(properties.id, vertices[index], `0.${index}`, false));
  }
  return supplementaryPoints;
}

module.exports = createSupplementaryPointsForCircle;

/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/lib/utils/drag_pan.js":
/*!******************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/lib/utils/drag_pan.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
    enable(ctx) {
        setTimeout(() => {
            // First check we've got a map and some context.
            if (!ctx.map || !ctx.map.dragPan || !ctx._ctx || !ctx._ctx.store || !ctx._ctx.store.getInitialConfigValue) return;
            // Now check initial state wasn't false (we leave it disabled if so)
            if (!ctx._ctx.store.getInitialConfigValue('dragPan')) return;
            ctx.map.dragPan.enable();
        }, 0);
    },
    disable(ctx) {
        setTimeout(() => {
            if (!ctx.map || !ctx.map.doubleClickZoom) return;
            // Always disable here, as it's necessary in some cases.
            ctx.map.dragPan.disable();
        }, 0);
    }
};


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/geojsonhint/lib/index.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/geojsonhint/lib/index.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var jsonlint = __webpack_require__(/*! jsonlint-lines */ "./node_modules/jsonlint-lines/lib/jsonlint.js"),
  geojsonHintObject = __webpack_require__(/*! ./object */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/geojsonhint/lib/object.js");

/**
 * @alias geojsonhint
 * @param {(string|object)} GeoJSON given as a string or as an object
 * @param {Object} options
 * @param {boolean} [options.noDuplicateMembers=true] forbid repeated
 * properties. This is only available for string input, becaused parsed
 * Objects cannot have duplicate properties.
 * @param {boolean} [options.precisionWarning=true] warn if GeoJSON contains
 * unnecessary coordinate precision.
 * @returns {Array<Object>} an array of errors
 */
function hint(str, options) {

    var gj, errors = [];

    if (typeof str === 'object') {
        gj = str;
    } else if (typeof str === 'string') {
        try {
            gj = jsonlint.parse(str);
        } catch(e) {
            var match = e.message.match(/line (\d+)/);
            var lineNumber = parseInt(match[1], 10);
            return [{
                line: lineNumber - 1,
                message: e.message,
                error: e
            }];
        }
    } else {
        return [{
            message: 'Expected string or object as input',
            line: 0
        }];
    }

    errors = errors.concat(geojsonHintObject.hint(gj, options));

    return errors;
}

module.exports.hint = hint;


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/geojsonhint/lib/object.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/geojsonhint/lib/object.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rightHandRule = __webpack_require__(/*! ./rhr */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/geojsonhint/lib/rhr.js");

/**
 * @alias geojsonhint
 * @param {(string|object)} GeoJSON given as a string or as an object
 * @param {Object} options
 * @param {boolean} [options.noDuplicateMembers=true] forbid repeated
 * properties. This is only available for string input, becaused parsed
 * Objects cannot have duplicate properties.
 * @param {boolean} [options.precisionWarning=true] warn if GeoJSON contains
 * unnecessary coordinate precision.
 * @returns {Array<Object>} an array of errors
 */
function hint(gj, options) {

    var errors = [];
    var precisionWarningCount = 0;
    var maxPrecisionWarnings = 10;
    var maxPrecision = 6;

    function root(_) {

        if ((!options || options.noDuplicateMembers !== false) &&
           _.__duplicateProperties__) {
            errors.push({
                message: 'An object contained duplicate members, making parsing ambigous: ' + _.__duplicateProperties__.join(', '),
                line: _.__line__
            });
        }

        if (requiredProperty(_, 'type', 'string')) {
            return;
        }

        if (!types[_.type]) {
            var expectedType = typesLower[_.type.toLowerCase()];
            if (expectedType !== undefined) {
                errors.push({
                    message: 'Expected ' + expectedType + ' but got ' + _.type + ' (case sensitive)',
                    line: _.__line__
                });
            } else {
                errors.push({
                    message: 'The type ' + _.type + ' is unknown',
                    line: _.__line__
                });
            }
        } else if (_) {
            types[_.type](_);
        }
    }

    function everyIs(_, type) {
        // make a single exception because typeof null === 'object'
        return _.every(function(x) {
            return x !== null && typeof x === type;
        });
    }

    function requiredProperty(_, name, type) {
        if (typeof _[name] === 'undefined') {
            return errors.push({
                message: '"' + name + '" member required',
                line: _.__line__
            });
        } else if (type === 'array') {
            if (!Array.isArray(_[name])) {
                return errors.push({
                    message: '"' + name +
                        '" member should be an array, but is an ' +
                        (typeof _[name]) + ' instead',
                    line: _.__line__
                });
            }
        } else if (type === 'object' && _[name] && _[name].constructor !== Object) {
            return errors.push({
                message: '"' + name +
                    '" member should be ' + (type) +
                    ', but is an ' + (_[name].constructor.name) + ' instead',
                line: _.__line__
            });
        } else if (type && typeof _[name] !== type) {
            return errors.push({
                message: '"' + name +
                    '" member should be ' + (type) +
                    ', but is an ' + (typeof _[name]) + ' instead',
                line: _.__line__
            });
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.3
    function FeatureCollection(featureCollection) {
        crs(featureCollection);
        bbox(featureCollection);
        if (featureCollection.properties !== undefined) {
            errors.push({
                message: 'FeatureCollection object cannot contain a "properties" member',
                line: featureCollection.__line__
            });
        }
        if (featureCollection.coordinates !== undefined) {
            errors.push({
                message: 'FeatureCollection object cannot contain a "coordinates" member',
                line: featureCollection.__line__
            });
        }
        if (!requiredProperty(featureCollection, 'features', 'array')) {
            if (!everyIs(featureCollection.features, 'object')) {
                return errors.push({
                    message: 'Every feature must be an object',
                    line: featureCollection.__line__
                });
            }
            featureCollection.features.forEach(Feature);
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.1.1
    function position(_, line) {
        if (!Array.isArray(_)) {
            return errors.push({
                message: 'position should be an array, is a ' + (typeof _) +
                    ' instead',
                line: _.__line__ || line
            });
        }
        if (_.length < 2) {
            return errors.push({
                message: 'position must have 2 or more elements',
                line: _.__line__ || line
            });
        }
        if (_.length > 3) {
            return errors.push({
                message: 'position should not have more than 3 elements',
                level: 'message',
                line: _.__line__ || line
            });
        }
        if (!everyIs(_, 'number')) {
            return errors.push({
                message: 'each element in a position must be a number',
                line: _.__line__ || line
            });
        }

        if (options && options.precisionWarning) {
            if (precisionWarningCount === maxPrecisionWarnings) {
                precisionWarningCount += 1;
                return errors.push({
                    message: 'truncated warnings: we\'ve encountered coordinate precision warning ' + maxPrecisionWarnings + ' times, no more warnings will be reported',
                    level: 'message',
                    line: _.__line__ || line
                });
            } else if (precisionWarningCount < maxPrecisionWarnings) {
                _.forEach(function(num) {
                    var precision = 0;
                    var decimalStr = String(num).split('.')[1];
                    if (decimalStr !== undefined)
                        precision = decimalStr.length;
                    if (precision > maxPrecision) {
                        precisionWarningCount += 1;
                        return errors.push({
                            message: 'precision of coordinates should be reduced',
                            level: 'message',
                            line: _.__line__ || line
                        });
                    }
                });
            }
        }
    }

    function positionArray(coords, type, depth, line) {
        if (line === undefined && coords.__line__ !== undefined) {
            line = coords.__line__;
        }
        if (depth === 0) {
            return position(coords, line);
        }
        if (depth === 1 && type) {
            if (type === 'LinearRing') {
                if (!Array.isArray(coords[coords.length - 1])) {
                    errors.push({
                        message: 'a number was found where a coordinate array should have been found: this needs to be nested more deeply',
                        line: line
                    });
                    return true;
                }
                if (coords.length < 4) {
                    errors.push({
                        message: 'a LinearRing of coordinates needs to have four or more positions',
                        line: line
                    });
                }
                if (coords.length &&
                    (coords[coords.length - 1].length !== coords[0].length ||
                    !coords[coords.length - 1].every(function(pos, index) {
                        return coords[0][index] === pos;
                }))) {
                    errors.push({
                        message: 'the first and last positions in a LinearRing of coordinates must be the same',
                        line: line
                    });
                    return true;
                }
            } else if (type === 'Line' && coords.length < 2) {
                return errors.push({
                    message: 'a line needs to have two or more coordinates to be valid',
                    line: line
                });
            }
        }
        if (!Array.isArray(coords)) {
            errors.push({
                message: 'a number was found where a coordinate array should have been found: this needs to be nested more deeply',
                line: line
            });
        } else {
            var results = coords.map(function(c) {
                return positionArray(c, type, depth - 1, c.__line__ || line);
            });
            return results.some(function(r) {
                return r;
            });
        }
    }

    function crs(_) {
        if (!_.crs) return;
        var defaultCRSName = 'urn:ogc:def:crs:OGC:1.3:CRS84';
        if (typeof _.crs === 'object' && _.crs.properties && _.crs.properties.name === defaultCRSName) {
            errors.push({
                message: 'old-style crs member is not recommended, this object is equivalent to the default and should be removed',
                line: _.__line__
            });
        } else {
            errors.push({
                message: 'old-style crs member is not recommended',
                line: _.__line__
            });
        }
    }

    function bbox(_) {
        if (!_.bbox) {
            return;
        }
        if (Array.isArray(_.bbox)) {
            if (!everyIs(_.bbox, 'number')) {
                errors.push({
                    message: 'each element in a bbox member must be a number',
                    line: _.bbox.__line__
                });
            }
            if (!(_.bbox.length === 4 || _.bbox.length === 6)) {
                errors.push({
                    message: 'bbox must contain 4 elements (for 2D) or 6 elements (for 3D)',
                    line: _.bbox.__line__
                });
            }
            return errors.length;
        }
        errors.push({
            message: 'bbox member must be an array of numbers, but is a ' + (typeof _.bbox),
            line: _.__line__
        });
    }

    function geometrySemantics(geom) {
        if (geom.properties !== undefined) {
            errors.push({
                message: 'geometry object cannot contain a "properties" member',
                line: geom.__line__
            });
        }
        if (geom.geometry !== undefined) {
            errors.push({
                message: 'geometry object cannot contain a "geometry" member',
                line: geom.__line__
            });
        }
        if (geom.features !== undefined) {
            errors.push({
                message: 'geometry object cannot contain a "features" member',
                line: geom.__line__
            });
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.1.2
    function Point(point) {
        crs(point);
        bbox(point);
        geometrySemantics(point);
        if (!requiredProperty(point, 'coordinates', 'array')) {
            position(point.coordinates);
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.1.6
    function Polygon(polygon) {
        crs(polygon);
        bbox(polygon);
        if (!requiredProperty(polygon, 'coordinates', 'array')) {
            if (!positionArray(polygon.coordinates, 'LinearRing', 2)) {
                rightHandRule(polygon, errors);
            }
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.1.7
    function MultiPolygon(multiPolygon) {
        crs(multiPolygon);
        bbox(multiPolygon);
        if (!requiredProperty(multiPolygon, 'coordinates', 'array')) {
            if (!positionArray(multiPolygon.coordinates, 'LinearRing', 3)) {
                rightHandRule(multiPolygon, errors);
            }
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.1.4
    function LineString(lineString) {
        crs(lineString);
        bbox(lineString);
        if (!requiredProperty(lineString, 'coordinates', 'array')) {
            positionArray(lineString.coordinates, 'Line', 1);
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.1.5
    function MultiLineString(multiLineString) {
        crs(multiLineString);
        bbox(multiLineString);
        if (!requiredProperty(multiLineString, 'coordinates', 'array')) {
            positionArray(multiLineString.coordinates, 'Line', 2);
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.1.3
    function MultiPoint(multiPoint) {
        crs(multiPoint);
        bbox(multiPoint);
        if (!requiredProperty(multiPoint, 'coordinates', 'array')) {
            positionArray(multiPoint.coordinates, '', 1);
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.1.8
    function GeometryCollection(geometryCollection) {
        crs(geometryCollection);
        bbox(geometryCollection);
        if (!requiredProperty(geometryCollection, 'geometries', 'array')) {
            if (!everyIs(geometryCollection.geometries, 'object')) {
                errors.push({
                    message: 'The geometries array in a GeometryCollection must contain only geometry objects',
                    line: geometryCollection.__line__
                });
            }
            if (geometryCollection.geometries.length === 1) {
                errors.push({
                    message: 'GeometryCollection with a single geometry should be avoided in favor of single part or a single object of multi-part type',
                    line: geometryCollection.geometries.__line__
                });
            }
            geometryCollection.geometries.forEach(function(geometry) {
                if (geometry) {
                    if (geometry.type === 'GeometryCollection') {
                        errors.push({
                            message: 'GeometryCollection should avoid nested geometry collections',
                            line: geometryCollection.geometries.__line__
                        });
                    }
                    root(geometry);
                }
            });
        }
    }

    // https://tools.ietf.org/html/rfc7946#section-3.2
    function Feature(feature) {
        crs(feature);
        bbox(feature);
        // https://github.com/geojson/draft-geojson/blob/master/middle.mkd#feature-object
        if (feature.id !== undefined &&
            typeof feature.id !== 'string' &&
            typeof feature.id !== 'number') {
            errors.push({
                message: 'Feature "id" member must have a string or number value',
                line: feature.__line__
            });
        }
        if (feature.features !== undefined) {
            errors.push({
                message: 'Feature object cannot contain a "features" member',
                line: feature.__line__
            });
        }
        if (feature.coordinates !== undefined) {
            errors.push({
                message: 'Feature object cannot contain a "coordinates" member',
                line: feature.__line__
            });
        }
        if (feature.type !== 'Feature') {
            errors.push({
                message: 'GeoJSON features must have a type=feature member',
                line: feature.__line__
            });
        }
        requiredProperty(feature, 'properties', 'object');
        if (!requiredProperty(feature, 'geometry', 'object')) {
            // https://tools.ietf.org/html/rfc7946#section-3.2
            // tolerate null geometry
            if (feature.geometry) root(feature.geometry);
        }
    }

    var types = {
        Point: Point,
        Feature: Feature,
        MultiPoint: MultiPoint,
        LineString: LineString,
        MultiLineString: MultiLineString,
        FeatureCollection: FeatureCollection,
        GeometryCollection: GeometryCollection,
        Polygon: Polygon,
        MultiPolygon: MultiPolygon
    };

    var typesLower = Object.keys(types).reduce(function(prev, curr) {
        prev[curr.toLowerCase()] = curr;
        return prev;
    }, {});

    if (typeof gj !== 'object' ||
        gj === null ||
        gj === undefined) {
        errors.push({
            message: 'The root of a GeoJSON object must be an object.',
            line: 0
        });
        return errors;
    }

    root(gj);

    errors.forEach(function(err) {
        if ({}.hasOwnProperty.call(err, 'line') && err.line === undefined) {
            delete err.line;
        }
    });

    return errors;
}

module.exports.hint = hint;


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/geojsonhint/lib/rhr.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/geojsonhint/lib/rhr.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function rad(x) {
    return x * Math.PI / 180;
}

function isRingClockwise (coords) {
    var area = 0;
    if (coords.length > 2) {
        var p1, p2;
        for (var i = 0; i < coords.length - 1; i++) {
            p1 = coords[i];
            p2 = coords[i + 1];
            area += rad(p2[0] - p1[0]) * (2 + Math.sin(rad(p1[1])) + Math.sin(rad(p2[1])));
        }
    }

    return area >= 0;
}

function isPolyRHR (coords) {
    if (coords && coords.length > 0) {
        if (isRingClockwise(coords[0]))
            return false;
        var interiorCoords = coords.slice(1, coords.length);
        if (!interiorCoords.every(isRingClockwise))
            return false;
    }
    return true;
}

function rightHandRule (geometry) {
    if (geometry.type === 'Polygon') {
        return isPolyRHR(geometry.coordinates);
    } else if (geometry.type === 'MultiPolygon') {
        return geometry.coordinates.every(isPolyRHR);
    }
}

module.exports = function validateRightHandRule(geometry, errors) {
    if (!rightHandRule(geometry)) {
        errors.push({
            message: 'Polygons and MultiPolygons should follow the right-hand rule',
            level: 'message',
            line: geometry.__line__
        });
    }
};


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/index.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const runSetup = __webpack_require__(/*! ./src/setup */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/setup.js");
const setupOptions = __webpack_require__(/*! ./src/options */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/options.js");
const setupAPI = __webpack_require__(/*! ./src/api */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/api.js");
const Constants = __webpack_require__(/*! ./src/constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");

const setupDraw = function(options, api) {
  options = setupOptions(options);

  const ctx = {
    options: options
  };

  api = setupAPI(ctx, api);
  ctx.api = api;

  const setup = runSetup(ctx);

  api.onAdd = setup.onAdd;
  api.onRemove = setup.onRemove;
  api.types = Constants.types;
  api.options = options;

  return api;
};

module.exports = function(options) {
  setupDraw(options, this);
};

module.exports.modes = __webpack_require__(/*! ./src/modes */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/index.js");


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/api.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/api.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const isEqual = __webpack_require__(/*! lodash.isequal */ "./node_modules/lodash.isequal/index.js");
const normalize = __webpack_require__(/*! @mapbox/geojson-normalize */ "./node_modules/@mapbox/geojson-normalize/index.js");
const hat = __webpack_require__(/*! hat */ "./node_modules/hat/index.js");
const featuresAt = __webpack_require__(/*! ./lib/features_at */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/features_at.js");
const stringSetsAreEqual = __webpack_require__(/*! ./lib/string_sets_are_equal */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/string_sets_are_equal.js");
const geojsonhint = __webpack_require__(/*! @mapbox/geojsonhint */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/geojsonhint/lib/index.js");
const Constants = __webpack_require__(/*! ./constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");
const StringSet = __webpack_require__(/*! ./lib/string_set */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/string_set.js");

const featureTypes = {
  Polygon: __webpack_require__(/*! ./feature_types/polygon */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/polygon.js"),
  LineString: __webpack_require__(/*! ./feature_types/line_string */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/line_string.js"),
  Point: __webpack_require__(/*! ./feature_types/point */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/point.js"),
  MultiPolygon: __webpack_require__(/*! ./feature_types/multi_feature */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/multi_feature.js"),
  MultiLineString: __webpack_require__(/*! ./feature_types/multi_feature */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/multi_feature.js"),
  MultiPoint: __webpack_require__(/*! ./feature_types/multi_feature */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/multi_feature.js")
};

module.exports = function(ctx, api) {

  api.modes = Constants.modes;

  api.getFeatureIdsAt = function(point) {
    const features = featuresAt.click({ point }, null, ctx);
    return features.map(feature => feature.properties.id);
  };

  api.getSelectedIds = function () {
    return ctx.store.getSelectedIds();
  };

  api.getSelected = function () {
    return {
      type: Constants.geojsonTypes.FEATURE_COLLECTION,
      features: ctx.store.getSelectedIds().map(id => ctx.store.get(id)).map(feature => feature.toGeoJSON())
    };
  };

  api.getSelectedPoints = function () {
    return {
      type: Constants.geojsonTypes.FEATURE_COLLECTION,
      features: ctx.store.getSelectedCoordinates().map(coordinate => {
        return {
          type: Constants.geojsonTypes.FEATURE,
          properties: {},
          geometry: {
            type: Constants.geojsonTypes.POINT,
            coordinates: coordinate.coordinates
          }
        };
      })
    };
  };

  api.set = function(featureCollection) {
    if (featureCollection.type === undefined || featureCollection.type !== Constants.geojsonTypes.FEATURE_COLLECTION || !Array.isArray(featureCollection.features)) {
      throw new Error('Invalid FeatureCollection');
    }
    const renderBatch = ctx.store.createRenderBatch();
    let toDelete = ctx.store.getAllIds().slice();
    const newIds = api.add(featureCollection);
    const newIdsLookup = new StringSet(newIds);

    toDelete = toDelete.filter(id => !newIdsLookup.has(id));
    if (toDelete.length) {
      api.delete(toDelete);
    }

    renderBatch();
    return newIds;
  };

  api.add = function (geojson) {
    const errors = geojsonhint.hint(geojson, { precisionWarning: false }).filter(e => e.level !== 'message');
    if (errors.length) {
      throw new Error(errors[0].message);
    }
    const featureCollection = JSON.parse(JSON.stringify(normalize(geojson)));

    const ids = featureCollection.features.map(feature => {
      feature.id = feature.id || hat();

      if (feature.geometry === null) {
        throw new Error('Invalid geometry: null');
      }

      if (ctx.store.get(feature.id) === undefined || ctx.store.get(feature.id).type !== feature.geometry.type) {
        // If the feature has not yet been created ...
        const Model = featureTypes[feature.geometry.type];
        if (Model === undefined) {
          throw new Error(`Invalid geometry type: ${feature.geometry.type}.`);
        }
        const internalFeature = new Model(ctx, feature);
        ctx.store.add(internalFeature);
      } else {
        // If a feature of that id has already been created, and we are swapping it out ...
        const internalFeature = ctx.store.get(feature.id);
        internalFeature.properties = feature.properties;
        if (!isEqual(internalFeature.getCoordinates(), feature.geometry.coordinates)) {
          internalFeature.incomingCoords(feature.geometry.coordinates);
        }
      }
      return feature.id;
    });

    ctx.store.render();
    return ids;
  };


  api.get = function (id) {
    const feature = ctx.store.get(id);
    if (feature) {
      return feature.toGeoJSON();
    }
  };

  api.getAll = function() {
    return {
      type: Constants.geojsonTypes.FEATURE_COLLECTION,
      features: ctx.store.getAll().map(feature => feature.toGeoJSON())
    };
  };

  api.delete = function(featureIds) {
    ctx.store.delete(featureIds, { silent: true });
    // If we were in direct select mode and our selected feature no longer exists
    // (because it was deleted), we need to get out of that mode.
    if (api.getMode() === Constants.modes.DIRECT_SELECT && !ctx.store.getSelectedIds().length) {
      ctx.events.changeMode(Constants.modes.SIMPLE_SELECT, undefined, { silent: true });
    } else {
      ctx.store.render();
    }

    return api;
  };

  api.deleteAll = function() {
    ctx.store.delete(ctx.store.getAllIds(), { silent: true });
    // If we were in direct select mode, now our selected feature no longer exists,
    // so escape that mode.
    if (api.getMode() === Constants.modes.DIRECT_SELECT) {
      ctx.events.changeMode(Constants.modes.SIMPLE_SELECT, undefined, { silent: true });
    } else {
      ctx.store.render();
    }

    return api;
  };

  api.changeMode = function(mode, modeOptions = {}) {
    // Avoid changing modes just to re-select what's already selected
    if (mode === Constants.modes.SIMPLE_SELECT && api.getMode() === Constants.modes.SIMPLE_SELECT) {
      if (stringSetsAreEqual((modeOptions.featureIds || []), ctx.store.getSelectedIds())) return api;
      // And if we are changing the selection within simple_select mode, just change the selection,
      // instead of stopping and re-starting the mode
      ctx.store.setSelected(modeOptions.featureIds, { silent: true });
      ctx.store.render();
      return api;
    }

    if (mode === Constants.modes.DIRECT_SELECT && api.getMode() === Constants.modes.DIRECT_SELECT &&
      modeOptions.featureId === ctx.store.getSelectedIds()[0]) {
      return api;
    }

    ctx.events.changeMode(mode, modeOptions, { silent: true });
    return api;
  };

  api.getMode = function() {
    return ctx.events.getMode();
  };

  api.trash = function() {
    ctx.events.trash({ silent: true });
    return api;
  };

  api.combineFeatures = function() {
    ctx.events.combineFeatures({ silent: true });
    return api;
  };

  api.uncombineFeatures = function() {
    ctx.events.uncombineFeatures({ silent: true });
    return api;
  };

  api.setFeatureProperty = function(featureId, property, value) {
    ctx.store.setFeatureProperty(featureId, property, value);
    return api;
  };

  return api;
};


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  classes: {
    CONTROL_BASE: 'mapboxgl-ctrl',
    CONTROL_PREFIX: 'mapboxgl-ctrl-',
    CONTROL_BUTTON: 'mapbox-gl-draw_ctrl-draw-btn',
    CONTROL_BUTTON_LINE: 'mapbox-gl-draw_line',
    CONTROL_BUTTON_POLYGON: 'mapbox-gl-draw_polygon',
    CONTROL_BUTTON_POINT: 'mapbox-gl-draw_point',
    CONTROL_BUTTON_TRASH: 'mapbox-gl-draw_trash',
    CONTROL_BUTTON_COMBINE_FEATURES: 'mapbox-gl-draw_combine',
    CONTROL_BUTTON_UNCOMBINE_FEATURES: 'mapbox-gl-draw_uncombine',
    CONTROL_GROUP: 'mapboxgl-ctrl-group',
    ATTRIBUTION: 'mapboxgl-ctrl-attrib',
    ACTIVE_BUTTON: 'active',
    BOX_SELECT: 'mapbox-gl-draw_boxselect'
  },
  sources: {
    HOT: 'mapbox-gl-draw-hot',
    COLD: 'mapbox-gl-draw-cold'
  },
  cursors: {
    ADD: 'add',
    MOVE: 'move',
    DRAG: 'drag',
    POINTER: 'pointer',
    NONE: 'none'
  },
  types: {
    POLYGON: 'polygon',
    LINE: 'line_string',
    POINT: 'point'
  },
  geojsonTypes: {
    FEATURE: 'Feature',
    POLYGON: 'Polygon',
    LINE_STRING: 'LineString',
    POINT: 'Point',
    FEATURE_COLLECTION: 'FeatureCollection',
    MULTI_PREFIX: 'Multi',
    MULTI_POINT: 'MultiPoint',
    MULTI_LINE_STRING: 'MultiLineString',
    MULTI_POLYGON: 'MultiPolygon'
  },
  modes: {
    DRAW_LINE_STRING: 'draw_line_string',
    DRAW_POLYGON: 'draw_polygon',
    DRAW_POINT: 'draw_point',
    SIMPLE_SELECT: 'simple_select',
    DIRECT_SELECT: 'direct_select',
    STATIC: 'static'
  },
  events: {
    CREATE: 'draw.create',
    DELETE: 'draw.delete',
    UPDATE: 'draw.update',
    SELECTION_CHANGE: 'draw.selectionchange',
    MODE_CHANGE: 'draw.modechange',
    ACTIONABLE: 'draw.actionable',
    RENDER: 'draw.render',
    COMBINE_FEATURES: 'draw.combine',
    UNCOMBINE_FEATURES: 'draw.uncombine'
  },
  updateActions: {
    MOVE: 'move',
    CHANGE_COORDINATES: 'change_coordinates'
  },
  meta: {
    FEATURE: 'feature',
    MIDPOINT: 'midpoint',
    VERTEX: 'vertex'
  },
  activeStates: {
    ACTIVE: 'true',
    INACTIVE: 'false'
  },
  interactions: [
    'scrollZoom',
    'boxZoom',
    'dragRotate',
    'dragPan',
    'keyboard',
    'doubleClickZoom',
    'touchZoomRotate'
  ],
  LAT_MIN: -90,
  LAT_RENDERED_MIN: -85,
  LAT_MAX: 90,
  LAT_RENDERED_MAX: 85,
  LNG_MIN: -270,
  LNG_MAX: 270
};


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/events.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/events.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const setupModeHandler = __webpack_require__(/*! ./lib/mode_handler */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/mode_handler.js");
const getFeaturesAndSetCursor = __webpack_require__(/*! ./lib/get_features_and_set_cursor */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/get_features_and_set_cursor.js");
const featuresAt = __webpack_require__(/*! ./lib/features_at */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/features_at.js");
const isClick = __webpack_require__(/*! ./lib/is_click */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/is_click.js");
const isTap = __webpack_require__(/*! ./lib/is_tap */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/is_tap.js");
const Constants = __webpack_require__(/*! ./constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");
const objectToMode = __webpack_require__(/*! ./modes/object_to_mode */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/object_to_mode.js");

module.exports = function(ctx) {

  const modes = Object.keys(ctx.options.modes).reduce((m, k) => {
    m[k] = objectToMode(ctx.options.modes[k]);
    return m;
  }, {});

  let mouseDownInfo = {};
  let touchStartInfo = {};
  const events = {};
  let currentModeName = null;
  let currentMode = null;

  events.drag = function(event, isDrag) {
    if (isDrag({
      point: event.point,
      time: new Date().getTime()
    })) {
      ctx.ui.queueMapClasses({ mouse: Constants.cursors.DRAG });
      currentMode.drag(event);
    } else {
      event.originalEvent.stopPropagation();
    }
  };

  events.mousedrag = function(event) {
    events.drag(event, (endInfo) => !isClick(mouseDownInfo, endInfo));
  };

  events.touchdrag = function(event) {
    events.drag(event, (endInfo) => !isTap(touchStartInfo, endInfo));
  };

  events.mousemove = function(event) {
    const button = event.originalEvent.buttons !== undefined ? event.originalEvent.buttons : event.originalEvent.which;
    if (button === 1) {
      return events.mousedrag(event);
    }
    const target = getFeaturesAndSetCursor(event, ctx);
    event.featureTarget = target;
    currentMode.mousemove(event);
  };

  events.mousedown = function(event) {
    mouseDownInfo = {
      time: new Date().getTime(),
      point: event.point
    };
    const target = getFeaturesAndSetCursor(event, ctx);
    event.featureTarget = target;
    currentMode.mousedown(event);
  };

  events.mouseup = function(event) {
    const target = getFeaturesAndSetCursor(event, ctx);
    event.featureTarget = target;

    if (isClick(mouseDownInfo, {
      point: event.point,
      time: new Date().getTime()
    })) {
      currentMode.click(event);
    } else {
      currentMode.mouseup(event);
    }
  };

  events.mouseout = function(event) {
    currentMode.mouseout(event);
  };

  events.touchstart = function(event) {
    // Prevent emulated mouse events because we will fully handle the touch here.
    // This does not stop the touch events from propogating to mapbox though.
    event.originalEvent.preventDefault();
    if (!ctx.options.touchEnabled) {
      return;
    }

    touchStartInfo = {
      time: new Date().getTime(),
      point: event.point
    };
    const target = featuresAt.touch(event, null, ctx)[0];
    event.featureTarget = target;
    currentMode.touchstart(event);
  };

  events.touchmove = function(event) {
    event.originalEvent.preventDefault();
    if (!ctx.options.touchEnabled) {
      return;
    }

    currentMode.touchmove(event);
    return events.touchdrag(event);
  };

  events.touchend = function(event) {
    event.originalEvent.preventDefault();
    if (!ctx.options.touchEnabled) {
      return;
    }

    const target = featuresAt.touch(event, null, ctx)[0];
    event.featureTarget = target;
    if (isTap(touchStartInfo, {
      time: new Date().getTime(),
      point: event.point
    })) {
      currentMode.tap(event);
    } else {
      currentMode.touchend(event);
    }
  };

  // 8 - Backspace
  // 46 - Delete
  const isKeyModeValid = (code) => !(code === 8 || code === 46 || (code >= 48 && code <= 57));

  events.keydown = function(event) {
    if ((event.srcElement || event.target).classList[0] !== 'mapboxgl-canvas') return; // we only handle events on the map

    if ((event.keyCode === 8 || event.keyCode === 46) && ctx.options.controls.trash) {
      event.preventDefault();
      currentMode.trash();
    } else if (isKeyModeValid(event.keyCode)) {
      currentMode.keydown(event);
    } else if (event.keyCode === 49 && ctx.options.controls.point) {
      changeMode(Constants.modes.DRAW_POINT);
    } else if (event.keyCode === 50 && ctx.options.controls.line_string) {
      changeMode(Constants.modes.DRAW_LINE_STRING);
    } else if (event.keyCode === 51 && ctx.options.controls.polygon) {
      changeMode(Constants.modes.DRAW_POLYGON);
    }
  };

  events.keyup = function(event) {
    if (isKeyModeValid(event.keyCode)) {
      currentMode.keyup(event);
    }
  };

  events.zoomend = function() {
    ctx.store.changeZoom();
  };

  events.data = function(event) {
    if (event.dataType === 'style') {
      const { setup, map, options, store } = ctx;
      const hasLayers = options.styles.some(style => map.getLayer(style.id));
      if (!hasLayers) {
        setup.addLayers();
        store.setDirty();
        store.render();
      }
    }
  };

  function changeMode(modename, nextModeOptions, eventOptions = {}) {
    currentMode.stop();

    const modebuilder = modes[modename];
    if (modebuilder === undefined) {
      throw new Error(`${modename} is not valid`);
    }
    currentModeName = modename;
    const mode = modebuilder(ctx, nextModeOptions);
    currentMode = setupModeHandler(mode, ctx);

    if (!eventOptions.silent) {
      ctx.map.fire(Constants.events.MODE_CHANGE, { mode: modename});
    }

    ctx.store.setDirty();
    ctx.store.render();
  }

  const actionState = {
    trash: false,
    combineFeatures: false,
    uncombineFeatures: false
  };

  function actionable(actions) {
    let changed = false;
    Object.keys(actions).forEach(action => {
      if (actionState[action] === undefined) throw new Error('Invalid action type');
      if (actionState[action] !== actions[action]) changed = true;
      actionState[action] = actions[action];
    });
    if (changed) ctx.map.fire(Constants.events.ACTIONABLE, { actions: actionState });
  }

  const api = {
    start: function() {
      currentModeName = ctx.options.defaultMode;
      currentMode = setupModeHandler(modes[currentModeName](ctx), ctx);
    },
    changeMode,
    actionable,
    currentModeName: function() {
      return currentModeName;
    },
    currentModeRender: function(geojson, push) {
      return currentMode.render(geojson, push);
    },
    fire: function(name, event) {
      if (events[name]) {
        events[name](event);
      }
    },
    addEventListeners: function() {
      ctx.map.on('mousemove', events.mousemove);
      ctx.map.on('mousedown', events.mousedown);
      ctx.map.on('mouseup', events.mouseup);
      ctx.map.on('data', events.data);

      ctx.map.on('touchmove', events.touchmove);
      ctx.map.on('touchstart', events.touchstart);
      ctx.map.on('touchend', events.touchend);

      ctx.container.addEventListener('mouseout', events.mouseout);

      if (ctx.options.keybindings) {
        ctx.container.addEventListener('keydown', events.keydown);
        ctx.container.addEventListener('keyup', events.keyup);
      }
    },
    removeEventListeners: function() {
      ctx.map.off('mousemove', events.mousemove);
      ctx.map.off('mousedown', events.mousedown);
      ctx.map.off('mouseup', events.mouseup);
      ctx.map.off('data', events.data);

      ctx.map.off('touchmove', events.touchmove);
      ctx.map.off('touchstart', events.touchstart);
      ctx.map.off('touchend', events.touchend);

      ctx.container.removeEventListener('mouseout', events.mouseout);

      if (ctx.options.keybindings) {
        ctx.container.removeEventListener('keydown', events.keydown);
        ctx.container.removeEventListener('keyup', events.keyup);
      }
    },
    trash: function(options) {
      currentMode.trash(options);
    },
    combineFeatures: function() {
      currentMode.combineFeatures();
    },
    uncombineFeatures: function() {
      currentMode.uncombineFeatures();
    },
    getMode: function() {
      return currentModeName;
    }
  };

  return api;
};


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/feature.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/feature.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const hat = __webpack_require__(/*! hat */ "./node_modules/hat/index.js");
const Constants = __webpack_require__(/*! ../constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");

const Feature = function(ctx, geojson) {
  this.ctx = ctx;
  this.properties = geojson.properties || {};
  this.coordinates = geojson.geometry.coordinates;
  this.id = geojson.id || hat();
  this.type = geojson.geometry.type;
};

Feature.prototype.changed = function() {
  this.ctx.store.featureChanged(this.id);
};

Feature.prototype.incomingCoords = function(coords) {
  this.setCoordinates(coords);
};

Feature.prototype.setCoordinates = function(coords) {
  this.coordinates = coords;
  this.changed();
};

Feature.prototype.getCoordinates = function() {
  return JSON.parse(JSON.stringify(this.coordinates));
};

Feature.prototype.setProperty = function(property, value) {
  this.properties[property] = value;
};

Feature.prototype.toGeoJSON = function() {
  return JSON.parse(JSON.stringify({
    id: this.id,
    type: Constants.geojsonTypes.FEATURE,
    properties: this.properties,
    geometry: {
      coordinates: this.getCoordinates(),
      type: this.type
    }
  }));
};

Feature.prototype.internal = function(mode) {
  const properties = {
    id: this.id,
    meta: Constants.meta.FEATURE,
    'meta:type': this.type,
    active: Constants.activeStates.INACTIVE,
    mode: mode
  };

  if (this.ctx.options.userProperties) {
    for (const name in this.properties) {
      properties[`user_${name}`] = this.properties[name];
    }
  }

  return {
    type: Constants.geojsonTypes.FEATURE,
    properties: properties,
    geometry: {
      coordinates: this.getCoordinates(),
      type: this.type
    }
  };
};

module.exports = Feature;


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/line_string.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/line_string.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Feature = __webpack_require__(/*! ./feature */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/feature.js");

const LineString = function(ctx, geojson) {
  Feature.call(this, ctx, geojson);
};

LineString.prototype = Object.create(Feature.prototype);

LineString.prototype.isValid = function() {
  return this.coordinates.length > 1;
};

LineString.prototype.addCoordinate = function(path, lng, lat) {
  this.changed();
  const id = parseInt(path, 10);
  this.coordinates.splice(id, 0, [lng, lat]);
};

LineString.prototype.getCoordinate = function(path) {
  const id = parseInt(path, 10);
  return JSON.parse(JSON.stringify(this.coordinates[id]));
};

LineString.prototype.removeCoordinate = function(path) {
  this.changed();
  this.coordinates.splice(parseInt(path, 10), 1);
};

LineString.prototype.updateCoordinate = function(path, lng, lat) {
  const id = parseInt(path, 10);
  this.coordinates[id] = [lng, lat];
  this.changed();
};

module.exports = LineString;


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/multi_feature.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/multi_feature.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Feature = __webpack_require__(/*! ./feature */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/feature.js");
const Constants = __webpack_require__(/*! ../constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");
const hat = __webpack_require__(/*! hat */ "./node_modules/hat/index.js");

const models = {
  MultiPoint: __webpack_require__(/*! ./point */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/point.js"),
  MultiLineString: __webpack_require__(/*! ./line_string */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/line_string.js"),
  MultiPolygon: __webpack_require__(/*! ./polygon */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/polygon.js")
};

const takeAction = (features, action, path, lng, lat) => {
  const parts = path.split('.');
  const idx = parseInt(parts[0], 10);
  const tail = (!parts[1]) ? null : parts.slice(1).join('.');
  return features[idx][action](tail, lng, lat);
};

const MultiFeature = function(ctx, geojson) {
  Feature.call(this, ctx, geojson);

  delete this.coordinates;
  this.model = models[geojson.geometry.type];
  if (this.model === undefined) throw new TypeError(`${geojson.geometry.type} is not a valid type`);
  this.features = this._coordinatesToFeatures(geojson.geometry.coordinates);
};

MultiFeature.prototype = Object.create(Feature.prototype);

MultiFeature.prototype._coordinatesToFeatures = function(coordinates) {
  const Model = this.model.bind(this);
  return coordinates.map(coords => new Model(this.ctx, {
    id: hat(),
    type: Constants.geojsonTypes.FEATURE,
    properties: {},
    geometry: {
      coordinates: coords,
      type: this.type.replace('Multi', '')
    }
  }));
};

MultiFeature.prototype.isValid = function() {
  return this.features.every(f => f.isValid());
};

MultiFeature.prototype.setCoordinates = function(coords) {
  this.features = this._coordinatesToFeatures(coords);
  this.changed();
};

MultiFeature.prototype.getCoordinate = function(path) {
  return takeAction(this.features, 'getCoordinate', path);
};

MultiFeature.prototype.getCoordinates = function() {
  return JSON.parse(JSON.stringify(this.features.map(f => {
    if (f.type === Constants.geojsonTypes.POLYGON) return f.getCoordinates();
    return f.coordinates;
  })));
};

MultiFeature.prototype.updateCoordinate = function(path, lng, lat) {
  takeAction(this.features, 'updateCoordinate', path, lng, lat);
  this.changed();
};

MultiFeature.prototype.addCoordinate = function(path, lng, lat) {
  takeAction(this.features, 'addCoordinate', path, lng, lat);
  this.changed();
};

MultiFeature.prototype.removeCoordinate = function(path) {
  takeAction(this.features, 'removeCoordinate', path);
  this.changed();
};

MultiFeature.prototype.getFeatures = function() {
  return this.features;
};

module.exports = MultiFeature;


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/point.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/point.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Feature = __webpack_require__(/*! ./feature */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/feature.js");

const Point = function(ctx, geojson) {
  Feature.call(this, ctx, geojson);
};

Point.prototype = Object.create(Feature.prototype);

Point.prototype.isValid = function() {
  return typeof this.coordinates[0] === 'number' &&
    typeof this.coordinates[1] === 'number';
};

Point.prototype.updateCoordinate = function(pathOrLng, lngOrLat, lat) {
  if (arguments.length === 3) {
    this.coordinates = [lngOrLat, lat];
  } else {
    this.coordinates = [pathOrLng, lngOrLat];
  }
  this.changed();
};

Point.prototype.getCoordinate = function() {
  return this.getCoordinates();
};

module.exports = Point;


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/polygon.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/polygon.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Feature = __webpack_require__(/*! ./feature */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/feature.js");

const Polygon = function(ctx, geojson) {
  Feature.call(this, ctx, geojson);
  this.coordinates = this.coordinates.map(ring => ring.slice(0, -1));
};

Polygon.prototype = Object.create(Feature.prototype);

Polygon.prototype.isValid = function() {
  if (this.coordinates.length === 0) return false;
  return this.coordinates.every(ring => ring.length > 2);
};

// Expects valid geoJSON polygon geometry: first and last positions must be equivalent.
Polygon.prototype.incomingCoords = function(coords) {
  this.coordinates = coords.map(ring => ring.slice(0, -1));
  this.changed();
};

// Does NOT expect valid geoJSON polygon geometry: first and last positions should not be equivalent.
Polygon.prototype.setCoordinates = function(coords) {
  this.coordinates = coords;
  this.changed();
};

Polygon.prototype.addCoordinate = function(path, lng, lat) {
  this.changed();
  const ids = path.split('.').map(x => parseInt(x, 10));

  const ring = this.coordinates[ids[0]];

  ring.splice(ids[1], 0, [lng, lat]);
};

Polygon.prototype.removeCoordinate = function(path) {
  this.changed();
  const ids = path.split('.').map(x => parseInt(x, 10));
  const ring = this.coordinates[ids[0]];
  if (ring) {
    ring.splice(ids[1], 1);
    if (ring.length < 3) {
      this.coordinates.splice(ids[0], 1);
    }
  }
};

Polygon.prototype.getCoordinate = function(path) {
  const ids = path.split('.').map(x => parseInt(x, 10));
  const ring = this.coordinates[ids[0]];
  return JSON.parse(JSON.stringify(ring[ids[1]]));
};

Polygon.prototype.getCoordinates = function() {
  return this.coordinates.map(coords => coords.concat([coords[0]]));
};

Polygon.prototype.updateCoordinate = function(path, lng, lat) {
  this.changed();
  const parts = path.split('.');
  const ringId = parseInt(parts[0], 10);
  const coordId = parseInt(parts[1], 10);

  if (this.coordinates[ringId] === undefined) {
    this.coordinates[ringId] = [];
  }

  this.coordinates[ringId][coordId] = [lng, lat];
};

module.exports = Polygon;


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/common_selectors.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/common_selectors.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Constants = __webpack_require__(/*! ../constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");

module.exports = {
  isOfMetaType: function(type) {
    return function(e) {
      const featureTarget = e.featureTarget;
      if (!featureTarget) return false;
      if (!featureTarget.properties) return false;
      return featureTarget.properties.meta === type;
    };
  },
  isShiftMousedown: function(e) {
    if (!e.originalEvent) return false;
    if (!e.originalEvent.shiftKey) return false;
    return e.originalEvent.button === 0;
  },
  isActiveFeature: function(e) {
    if (!e.featureTarget) return false;
    if (!e.featureTarget.properties) return false;
    return e.featureTarget.properties.active === Constants.activeStates.ACTIVE &&
      e.featureTarget.properties.meta === Constants.meta.FEATURE;
  },
  isInactiveFeature: function(e) {
    if (!e.featureTarget) return false;
    if (!e.featureTarget.properties) return false;
    return e.featureTarget.properties.active === Constants.activeStates.INACTIVE &&
      e.featureTarget.properties.meta === Constants.meta.FEATURE;
  },
  noTarget: function(e) {
    return e.featureTarget === undefined;
  },
  isFeature: function(e) {
    if (!e.featureTarget) return false;
    if (!e.featureTarget.properties) return false;
    return e.featureTarget.properties.meta === Constants.meta.FEATURE;
  },
  isVertex: function(e) {
    const featureTarget = e.featureTarget;
    if (!featureTarget) return false;
    if (!featureTarget.properties) return false;
    return featureTarget.properties.meta === Constants.meta.VERTEX;
  },
  isShiftDown: function(e) {
    if (!e.originalEvent) return false;
    return e.originalEvent.shiftKey === true;
  },
  isEscapeKey: function(e) {
    return e.keyCode === 27;
  },
  isEnterKey: function(e) {
    return e.keyCode === 13;
  },
  true: function() {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/constrain_feature_movement.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/constrain_feature_movement.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const extent = __webpack_require__(/*! @mapbox/geojson-extent */ "./node_modules/@mapbox/geojson-extent/index.js");
const Constants = __webpack_require__(/*! ../constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");

const {
  LAT_MIN,
  LAT_MAX,
  LAT_RENDERED_MIN,
  LAT_RENDERED_MAX,
  LNG_MIN,
  LNG_MAX
} = Constants;

// Ensure that we do not drag north-south far enough for
// - any part of any feature to exceed the poles
// - any feature to be completely lost in the space between the projection's
//   edge and the poles, such that it couldn't be re-selected and moved back
module.exports = function(geojsonFeatures, delta) {
  // "inner edge" = a feature's latitude closest to the equator
  let northInnerEdge = LAT_MIN;
  let southInnerEdge = LAT_MAX;
  // "outer edge" = a feature's latitude furthest from the equator
  let northOuterEdge = LAT_MIN;
  let southOuterEdge = LAT_MAX;

  let westEdge = LNG_MAX;
  let eastEdge = LNG_MIN;

  geojsonFeatures.forEach(feature => {
    const bounds = extent(feature);
    const featureSouthEdge = bounds[1];
    const featureNorthEdge = bounds[3];
    const featureWestEdge = bounds[0];
    const featureEastEdge = bounds[2];
    if (featureSouthEdge > northInnerEdge) northInnerEdge = featureSouthEdge;
    if (featureNorthEdge < southInnerEdge) southInnerEdge = featureNorthEdge;
    if (featureNorthEdge > northOuterEdge) northOuterEdge = featureNorthEdge;
    if (featureSouthEdge < southOuterEdge) southOuterEdge = featureSouthEdge;
    if (featureWestEdge < westEdge) westEdge = featureWestEdge;
    if (featureEastEdge > eastEdge) eastEdge = featureEastEdge;
  });


  // These changes are not mutually exclusive: we might hit the inner
  // edge but also have hit the outer edge and therefore need
  // another readjustment
  const constrainedDelta = delta;
  if (northInnerEdge + constrainedDelta.lat > LAT_RENDERED_MAX) {
    constrainedDelta.lat = LAT_RENDERED_MAX - northInnerEdge;
  }
  if (northOuterEdge + constrainedDelta.lat > LAT_MAX) {
    constrainedDelta.lat = LAT_MAX - northOuterEdge;
  }
  if (southInnerEdge + constrainedDelta.lat < LAT_RENDERED_MIN) {
    constrainedDelta.lat = LAT_RENDERED_MIN - southInnerEdge;
  }
  if (southOuterEdge + constrainedDelta.lat < LAT_MIN) {
    constrainedDelta.lat = LAT_MIN - southOuterEdge;
  }
  if (westEdge + constrainedDelta.lng <= LNG_MIN) {
    constrainedDelta.lng += Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;
  }
  if (eastEdge + constrainedDelta.lng >= LNG_MAX) {
    constrainedDelta.lng -= Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;
  }

  return constrainedDelta;
};


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/create_midpoint.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/create_midpoint.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Constants = __webpack_require__(/*! ../constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");

module.exports = function(parent, startVertex, endVertex, map) {
  const startCoord = startVertex.geometry.coordinates;
  const endCoord = endVertex.geometry.coordinates;

  // If a coordinate exceeds the projection, we can't calculate a midpoint,
  // so run away
  if (startCoord[1] > Constants.LAT_RENDERED_MAX ||
    startCoord[1] < Constants.LAT_RENDERED_MIN ||
    endCoord[1] > Constants.LAT_RENDERED_MAX ||
    endCoord[1] < Constants.LAT_RENDERED_MIN) {
    return null;
  }

  const ptA = map.project([ startCoord[0], startCoord[1] ]);
  const ptB = map.project([ endCoord[0], endCoord[1] ]);
  const mid = map.unproject([ (ptA.x + ptB.x) / 2, (ptA.y + ptB.y) / 2 ]);

  return {
    type: Constants.geojsonTypes.FEATURE,
    properties: {
      meta: Constants.meta.MIDPOINT,
      parent: parent,
      lng: mid.lng,
      lat: mid.lat,
      coord_path: endVertex.properties.coord_path
    },
    geometry: {
      type: Constants.geojsonTypes.POINT,
      coordinates: [mid.lng, mid.lat]
    }
  };
};


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/create_supplementary_points.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/create_supplementary_points.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const createVertex = __webpack_require__(/*! ./create_vertex */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/create_vertex.js");
const createMidpoint = __webpack_require__(/*! ./create_midpoint */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/create_midpoint.js");
const Constants = __webpack_require__(/*! ../constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");

function createSupplementaryPoints(geojson, options = {}, basePath = null) {
  const { type, coordinates } = geojson.geometry;
  const featureId = geojson.properties && geojson.properties.id;

  let supplementaryPoints = [];

  if (type === Constants.geojsonTypes.POINT) {
    // For points, just create a vertex
    supplementaryPoints.push(createVertex(featureId, coordinates, basePath, isSelectedPath(basePath)));
  } else if (type === Constants.geojsonTypes.POLYGON) {
    // Cycle through a Polygon's rings and
    // process each line
    coordinates.forEach((line, lineIndex) => {
      processLine(line, (basePath !== null) ? `${basePath}.${lineIndex}` : String(lineIndex));
    });
  } else if (type === Constants.geojsonTypes.LINE_STRING) {
    processLine(coordinates, basePath);
  } else if (type.indexOf(Constants.geojsonTypes.MULTI_PREFIX) === 0) {
    processMultiGeometry();
  }

  function processLine(line, lineBasePath) {
    let firstPointString = '';
    let lastVertex = null;
    line.forEach((point, pointIndex) => {
      const pointPath = (lineBasePath !== undefined && lineBasePath !== null) ? `${lineBasePath}.${pointIndex}` : String(pointIndex);
      const vertex = createVertex(featureId, point, pointPath, isSelectedPath(pointPath));

      // If we're creating midpoints, check if there was a
      // vertex before this one. If so, add a midpoint
      // between that vertex and this one.
      if (options.midpoints && lastVertex) {
        const midpoint = createMidpoint(featureId, lastVertex, vertex, options.map);
        if (midpoint) {
          supplementaryPoints.push(midpoint);
        }
      }
      lastVertex = vertex;

      // A Polygon line's last point is the same as the first point. If we're on the last
      // point, we want to draw a midpoint before it but not another vertex on it
      // (since we already a vertex there, from the first point).
      const stringifiedPoint = JSON.stringify(point);
      if (firstPointString !== stringifiedPoint) {
        supplementaryPoints.push(vertex);
      }
      if (pointIndex === 0) {
        firstPointString = stringifiedPoint;
      }
    });
  }

  function isSelectedPath(path) {
    if (!options.selectedPaths) return false;
    return options.selectedPaths.indexOf(path) !== -1;
  }

  // Split a multi-geometry into constituent
  // geometries, and accumulate the supplementary points
  // for each of those constituents
  function processMultiGeometry() {
    const subType = type.replace(Constants.geojsonTypes.MULTI_PREFIX, '');
    coordinates.forEach((subCoordinates, index) => {
      const subFeature = {
        type: Constants.geojsonTypes.FEATURE,
        properties: geojson.properties,
        geometry: {
          type: subType,
          coordinates: subCoordinates
        }
      };
      supplementaryPoints = supplementaryPoints.concat(createSupplementaryPoints(subFeature, options, index));
    });
  }

  return supplementaryPoints;
}

module.exports = createSupplementaryPoints;


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/create_vertex.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/create_vertex.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Constants = __webpack_require__(/*! ../constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");

/**
 * Returns GeoJSON for a Point representing the
 * vertex of another feature.
 *
 * @param {string} parentId
 * @param {Array<number>} coordinates
 * @param {string} path - Dot-separated numbers indicating exactly
 *   where the point exists within its parent feature's coordinates.
 * @param {boolean} selected
 * @return {GeoJSON} Point
 */
module.exports = function(parentId, coordinates, path, selected) {
  return {
    type: Constants.geojsonTypes.FEATURE,
    properties: {
      meta: Constants.meta.VERTEX,
      parent: parentId,
      coord_path: path,
      active: (selected) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE
    },
    geometry: {
      type: Constants.geojsonTypes.POINT,
      coordinates: coordinates
    }
  };
};


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/double_click_zoom.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/double_click_zoom.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  enable(ctx) {
    setTimeout(() => {
      // First check we've got a map and some context.
      if (!ctx.map || !ctx.map.doubleClickZoom || !ctx._ctx || !ctx._ctx.store || !ctx._ctx.store.getInitialConfigValue) return;
      // Now check initial state wasn't false (we leave it disabled if so)
      if (!ctx._ctx.store.getInitialConfigValue('doubleClickZoom')) return;
      ctx.map.doubleClickZoom.enable();
    }, 0);
  },
  disable(ctx) {
    setTimeout(() => {
      if (!ctx.map || !ctx.map.doubleClickZoom) return;
      // Always disable here, as it's necessary in some cases.
      ctx.map.doubleClickZoom.disable();
    }, 0);
  }
};


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/euclidean_distance.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/euclidean_distance.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(a, b) {
  const x = a.x - b.x;
  const y = a.y - b.y;
  return Math.sqrt((x * x) + (y * y));
};


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/features_at.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/features_at.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const sortFeatures = __webpack_require__(/*! ./sort_features */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/sort_features.js");
const mapEventToBoundingBox = __webpack_require__(/*! ./map_event_to_bounding_box */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/map_event_to_bounding_box.js");
const Constants = __webpack_require__(/*! ../constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");
const StringSet = __webpack_require__(/*! ./string_set */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/string_set.js");

const META_TYPES = [
  Constants.meta.FEATURE,
  Constants.meta.MIDPOINT,
  Constants.meta.VERTEX
];

// Requires either event or bbox
module.exports = {
  click: featuresAtClick,
  touch: featuresAtTouch
};

function featuresAtClick(event, bbox, ctx) {
  return featuresAt(event, bbox, ctx, ctx.options.clickBuffer);
}

function featuresAtTouch(event, bbox, ctx) {
  return featuresAt(event, bbox, ctx, ctx.options.touchBuffer);
}

function featuresAt(event, bbox, ctx, buffer) {
  if (ctx.map === null) return [];

  const box = (event) ? mapEventToBoundingBox(event, buffer) : bbox;

  const queryParams = {};
  if (ctx.options.styles) queryParams.layers = ctx.options.styles.map(s => s.id);

  const features = ctx.map.queryRenderedFeatures(box, queryParams)
    .filter((feature) => {
      return META_TYPES.indexOf(feature.properties.meta) !== -1;
    });

  const featureIds = new StringSet();
  const uniqueFeatures = [];
  features.forEach((feature) => {
    const featureId = feature.properties.id;
    if (featureIds.has(featureId)) return;
    featureIds.add(featureId);
    uniqueFeatures.push(feature);
  });

  return sortFeatures(uniqueFeatures);
}


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/get_features_and_set_cursor.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/get_features_and_set_cursor.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const featuresAt = __webpack_require__(/*! ./features_at */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/features_at.js");
const Constants = __webpack_require__(/*! ../constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");

module.exports = function getFeatureAtAndSetCursors(event, ctx) {
  const features = featuresAt.click(event, null, ctx);
  const classes = { mouse: Constants.cursors.NONE };

  if (features[0]) {
    classes.mouse = (features[0].properties.active === Constants.activeStates.ACTIVE) ?
      Constants.cursors.MOVE : Constants.cursors.POINTER;
    classes.feature = features[0].properties.meta;
  }

  if (ctx.events.currentModeName().indexOf('draw') !== -1) {
    classes.mouse = Constants.cursors.ADD;
  }

  ctx.ui.queueMapClasses(classes);
  ctx.ui.updateMapClasses();

  return features[0];
};


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/is_click.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/is_click.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const euclideanDistance = __webpack_require__(/*! ./euclidean_distance */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/euclidean_distance.js");

const FINE_TOLERANCE = 4;
const GROSS_TOLERANCE = 12;
const INTERVAL = 500;

module.exports = function isClick(start, end, options = {}) {
  const fineTolerance = (options.fineTolerance != null) ? options.fineTolerance : FINE_TOLERANCE;
  const grossTolerance = (options.grossTolerance != null) ? options.grossTolerance : GROSS_TOLERANCE;
  const interval = (options.interval != null) ? options.interval : INTERVAL;

  start.point = start.point || end.point;
  start.time = start.time || end.time;
  const moveDistance = euclideanDistance(start.point, end.point);

  return moveDistance < fineTolerance ||
    (moveDistance < grossTolerance && (end.time - start.time) < interval);
};


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/is_event_at_coordinates.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/is_event_at_coordinates.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function isEventAtCoordinates(event, coordinates) {
  if (!event.lngLat) return false;
  return event.lngLat.lng === coordinates[0] && event.lngLat.lat === coordinates[1];
}

module.exports = isEventAtCoordinates;


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/is_tap.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/is_tap.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const euclideanDistance = __webpack_require__(/*! ./euclidean_distance */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/euclidean_distance.js");

const TOLERANCE = 25;
const INTERVAL = 250;

module.exports = function isTap(start, end, options = {}) {
  const tolerance = (options.tolerance != null) ? options.tolerance : TOLERANCE;
  const interval = (options.interval != null) ? options.interval : INTERVAL;

  start.point = start.point || end.point;
  start.time = start.time || end.time;
  const moveDistance = euclideanDistance(start.point, end.point);

  return moveDistance < tolerance && (end.time - start.time) < interval;
};


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/map_event_to_bounding_box.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/map_event_to_bounding_box.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Returns a bounding box representing the event's location.
 *
 * @param {Event} mapEvent - Mapbox GL JS map event, with a point properties.
 * @return {Array<Array<number>>} Bounding box.
 */
function mapEventToBoundingBox(mapEvent, buffer = 0) {
  return [
    [mapEvent.point.x - buffer, mapEvent.point.y - buffer],
    [mapEvent.point.x + buffer, mapEvent.point.y + buffer]
  ];
}

module.exports = mapEventToBoundingBox;


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/mode_handler.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/mode_handler.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


const ModeHandler = function(mode, DrawContext) {

  const handlers = {
    drag: [],
    click: [],
    mousemove: [],
    mousedown: [],
    mouseup: [],
    mouseout: [],
    keydown: [],
    keyup: [],
    touchstart: [],
    touchmove: [],
    touchend: [],
    tap: []
  };

  const ctx = {
    on: function(event, selector, fn) {
      if (handlers[event] === undefined) {
        throw new Error(`Invalid event type: ${event}`);
      }
      handlers[event].push({
        selector: selector,
        fn: fn
      });
    },
    render: function(id) {
      DrawContext.store.featureChanged(id);
    }
  };

  const delegate = function (eventName, event) {
    const handles = handlers[eventName];
    let iHandle = handles.length;
    while (iHandle--) {
      const handle = handles[iHandle];
      if (handle.selector(event)) {
        handle.fn.call(ctx, event);
        DrawContext.store.render();
        DrawContext.ui.updateMapClasses();

        // ensure an event is only handled once
        // we do this to let modes have multiple overlapping selectors
        // and relay on order of oppertations to filter
        break;
      }
    }
  };

  mode.start.call(ctx);

  return {
    render: mode.render,
    stop: function() {
      if (mode.stop) mode.stop();
    },
    trash: function() {
      if (mode.trash) {
        mode.trash();
        DrawContext.store.render();
      }
    },
    combineFeatures: function() {
      if (mode.combineFeatures) {
        mode.combineFeatures();
      }
    },
    uncombineFeatures: function() {
      if (mode.uncombineFeatures) {
        mode.uncombineFeatures();
      }
    },
    drag: function(event) {
      delegate('drag', event);
    },
    click: function(event) {
      delegate('click', event);
    },
    mousemove: function(event) {
      delegate('mousemove', event);
    },
    mousedown: function(event) {
      delegate('mousedown', event);
    },
    mouseup: function(event) {
      delegate('mouseup', event);
    },
    mouseout: function(event) {
      delegate('mouseout', event);
    },
    keydown: function(event) {
      delegate('keydown', event);
    },
    keyup: function(event) {
      delegate('keyup', event);
    },
    touchstart: function(event) {
      delegate('touchstart', event);
    },
    touchmove: function(event) {
      delegate('touchmove', event);
    },
    touchend: function(event) {
      delegate('touchend', event);
    },
    tap: function(event) {
      delegate('tap', event);
    }
  };
};

module.exports = ModeHandler;


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/mouse_event_point.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/mouse_event_point.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Point = __webpack_require__(/*! @mapbox/point-geometry */ "./node_modules/@mapbox/point-geometry/index.js");

/**
 * Returns a Point representing a mouse event's position
 * relative to a containing element.
 *
 * @param {MouseEvent} mouseEvent
 * @param {Node} container
 * @returns {Point}
 */
function mouseEventPoint(mouseEvent, container) {
  const rect = container.getBoundingClientRect();
  return new Point(
    mouseEvent.clientX - rect.left - (container.clientLeft || 0),
    mouseEvent.clientY - rect.top - (container.clientTop || 0)
  );
}

module.exports = mouseEventPoint;


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/move_features.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/move_features.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const constrainFeatureMovement = __webpack_require__(/*! ./constrain_feature_movement */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/constrain_feature_movement.js");
const Constants = __webpack_require__(/*! ../constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");

module.exports = function(features, delta) {
  const constrainedDelta = constrainFeatureMovement(features.map(feature => feature.toGeoJSON()), delta);

  features.forEach(feature => {
    const currentCoordinates = feature.getCoordinates();

    const moveCoordinate = (coord) => {
      const point = {
        lng: coord[0] + constrainedDelta.lng,
        lat: coord[1] + constrainedDelta.lat
      };
      return [point.lng, point.lat];
    };
    const moveRing = (ring) => ring.map(coord => moveCoordinate(coord));
    const moveMultiPolygon = (multi) => multi.map(ring => moveRing(ring));

    let nextCoordinates;
    if (feature.type === Constants.geojsonTypes.POINT) {
      nextCoordinates = moveCoordinate(currentCoordinates);
    } else if (feature.type === Constants.geojsonTypes.LINE_STRING || feature.type === Constants.geojsonTypes.MULTI_POINT) {
      nextCoordinates = currentCoordinates.map(moveCoordinate);
    } else if (feature.type === Constants.geojsonTypes.POLYGON || feature.type === Constants.geojsonTypes.MULTI_LINE_STRING) {
      nextCoordinates = currentCoordinates.map(moveRing);
    } else if (feature.type === Constants.geojsonTypes.MULTI_POLYGON) {
      nextCoordinates = currentCoordinates.map(moveMultiPolygon);
    }

    feature.incomingCoords(nextCoordinates);
  });
};


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/sort_features.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/sort_features.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const area = __webpack_require__(/*! @mapbox/geojson-area */ "./node_modules/@mapbox/geojson-area/index.js");
const Constants = __webpack_require__(/*! ../constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");

const FEATURE_SORT_RANKS = {
  Point: 0,
  LineString: 1,
  Polygon: 2
};

function comparator(a, b) {
  const score = FEATURE_SORT_RANKS[a.geometry.type] - FEATURE_SORT_RANKS[b.geometry.type];

  if (score === 0 && a.geometry.type === Constants.geojsonTypes.POLYGON) {
    return a.area - b.area;
  }

  return score;
}

// Sort in the order above, then sort polygons by area ascending.
function sortFeatures(features) {
  return features.map(feature => {
    if (feature.geometry.type === Constants.geojsonTypes.POLYGON) {
      feature.area = area.geometry({
        type: Constants.geojsonTypes.FEATURE,
        property: {},
        geometry: feature.geometry
      });
    }
    return feature;
  }).sort(comparator).map(feature => {
    delete feature.area;
    return feature;
  });
}

module.exports = sortFeatures;


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/string_set.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/string_set.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function StringSet(items) {
  this._items = {};
  this._nums = {};
  this._length = items ? items.length : 0;
  if (!items) return;
  for (let i = 0, l = items.length; i < l; i++) {
    this.add(items[i]);
    if (items[i] === undefined) continue;
    if (typeof items[i] === 'string') this._items[items[i]] = i;
    else this._nums[items[i]] = i;

  }
}

StringSet.prototype.add = function(x) {
  if (this.has(x)) return this;
  this._length++;
  if (typeof x === 'string') this._items[x] = this._length;
  else this._nums[x] = this._length;
  return this;
};

StringSet.prototype.delete = function(x) {
  if (this.has(x) === false) return this;
  this._length--;
  delete this._items[x];
  delete this._nums[x];
  return this;
};

StringSet.prototype.has = function(x) {
  if (typeof x !== 'string' && typeof x !== 'number') return false;
  return this._items[x] !== undefined || this._nums[x] !== undefined;
};

StringSet.prototype.values = function() {
  const values = [];
  Object.keys(this._items).forEach(k => {
    values.push({ k: k, v: this._items[k] });
  });
  Object.keys(this._nums).forEach(k => {
    values.push({ k: JSON.parse(k), v: this._nums[k] });
  });

  return values.sort((a, b) => a.v - b.v).map(a => a.k);
};

StringSet.prototype.clear = function() {
  this._length = 0;
  this._items = {};
  this._nums = {};
  return this;
};

module.exports = StringSet;


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/string_sets_are_equal.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/string_sets_are_equal.js ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(a, b) {
  if (a.length !== b.length) return false;
  return JSON.stringify(a.map(id => id).sort()) === JSON.stringify(b.map(id => id).sort());
};


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/theme.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/theme.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = [
  {
    'id': 'gl-draw-polygon-fill-inactive',
    'type': 'fill',
    'filter': ['all',
      ['==', 'active', 'false'],
      ['==', '$type', 'Polygon'],
      ['!=', 'mode', 'static']
    ],
    'paint': {
      'fill-color': '#3bb2d0',
      'fill-outline-color': '#3bb2d0',
      'fill-opacity': 0.1
    }
  },
  {
    'id': 'gl-draw-polygon-fill-active',
    'type': 'fill',
    'filter': ['all', ['==', 'active', 'true'], ['==', '$type', 'Polygon']],
    'paint': {
      'fill-color': '#fbb03b',
      'fill-outline-color': '#fbb03b',
      'fill-opacity': 0.1
    }
  },
  {
    'id': 'gl-draw-polygon-midpoint',
    'type': 'circle',
    'filter': ['all',
      ['==', '$type', 'Point'],
      ['==', 'meta', 'midpoint']],
    'paint': {
      'circle-radius': 3,
      'circle-color': '#fbb03b'
    }
  },
  {
    'id': 'gl-draw-polygon-stroke-inactive',
    'type': 'line',
    'filter': ['all',
      ['==', 'active', 'false'],
      ['==', '$type', 'Polygon'],
      ['!=', 'mode', 'static']
    ],
    'layout': {
      'line-cap': 'round',
      'line-join': 'round'
    },
    'paint': {
      'line-color': '#3bb2d0',
      'line-width': 2
    }
  },
  {
    'id': 'gl-draw-polygon-stroke-active',
    'type': 'line',
    'filter': ['all', ['==', 'active', 'true'], ['==', '$type', 'Polygon']],
    'layout': {
      'line-cap': 'round',
      'line-join': 'round'
    },
    'paint': {
      'line-color': '#fbb03b',
      'line-dasharray': [0.2, 2],
      'line-width': 2
    }
  },
  {
    'id': 'gl-draw-line-inactive',
    'type': 'line',
    'filter': ['all',
      ['==', 'active', 'false'],
      ['==', '$type', 'LineString'],
      ['!=', 'mode', 'static']
    ],
    'layout': {
      'line-cap': 'round',
      'line-join': 'round'
    },
    'paint': {
      'line-color': '#3bb2d0',
      'line-width': 2
    }
  },
  {
    'id': 'gl-draw-line-active',
    'type': 'line',
    'filter': ['all',
      ['==', '$type', 'LineString'],
      ['==', 'active', 'true']
    ],
    'layout': {
      'line-cap': 'round',
      'line-join': 'round'
    },
    'paint': {
      'line-color': '#fbb03b',
      'line-dasharray': [0.2, 2],
      'line-width': 2
    }
  },
  {
    'id': 'gl-draw-polygon-and-line-vertex-stroke-inactive',
    'type': 'circle',
    'filter': ['all',
      ['==', 'meta', 'vertex'],
      ['==', '$type', 'Point'],
      ['!=', 'mode', 'static']
    ],
    'paint': {
      'circle-radius': 5,
      'circle-color': '#fff'
    }
  },
  {
    'id': 'gl-draw-polygon-and-line-vertex-inactive',
    'type': 'circle',
    'filter': ['all',
      ['==', 'meta', 'vertex'],
      ['==', '$type', 'Point'],
      ['!=', 'mode', 'static']
    ],
    'paint': {
      'circle-radius': 3,
      'circle-color': '#fbb03b'
    }
  },
  {
    'id': 'gl-draw-point-point-stroke-inactive',
    'type': 'circle',
    'filter': ['all',
      ['==', 'active', 'false'],
      ['==', '$type', 'Point'],
      ['==', 'meta', 'feature'],
      ['!=', 'mode', 'static']
    ],
    'paint': {
      'circle-radius': 5,
      'circle-opacity': 1,
      'circle-color': '#fff'
    }
  },
  {
    'id': 'gl-draw-point-inactive',
    'type': 'circle',
    'filter': ['all',
      ['==', 'active', 'false'],
      ['==', '$type', 'Point'],
      ['==', 'meta', 'feature'],
      ['!=', 'mode', 'static']
    ],
    'paint': {
      'circle-radius': 3,
      'circle-color': '#3bb2d0'
    }
  },
  {
    'id': 'gl-draw-point-stroke-active',
    'type': 'circle',
    'filter': ['all',
      ['==', '$type', 'Point'],
      ['==', 'active', 'true'],
      ['!=', 'meta', 'midpoint']
    ],
    'paint': {
      'circle-radius': 7,
      'circle-color': '#fff'
    }
  },
  {
    'id': 'gl-draw-point-active',
    'type': 'circle',
    'filter': ['all',
      ['==', '$type', 'Point'],
      ['!=', 'meta', 'midpoint'],
      ['==', 'active', 'true']],
    'paint': {
      'circle-radius': 5,
      'circle-color': '#fbb03b'
    }
  },
  {
    'id': 'gl-draw-polygon-fill-static',
    'type': 'fill',
    'filter': ['all', ['==', 'mode', 'static'], ['==', '$type', 'Polygon']],
    'paint': {
      'fill-color': '#404040',
      'fill-outline-color': '#404040',
      'fill-opacity': 0.1
    }
  },
  {
    'id': 'gl-draw-polygon-stroke-static',
    'type': 'line',
    'filter': ['all', ['==', 'mode', 'static'], ['==', '$type', 'Polygon']],
    'layout': {
      'line-cap': 'round',
      'line-join': 'round'
    },
    'paint': {
      'line-color': '#404040',
      'line-width': 2
    }
  },
  {
    'id': 'gl-draw-line-static',
    'type': 'line',
    'filter': ['all', ['==', 'mode', 'static'], ['==', '$type', 'LineString']],
    'layout': {
      'line-cap': 'round',
      'line-join': 'round'
    },
    'paint': {
      'line-color': '#404040',
      'line-width': 2
    }
  },
  {
    'id': 'gl-draw-point-static',
    'type': 'circle',
    'filter': ['all', ['==', 'mode', 'static'], ['==', '$type', 'Point']],
    'paint': {
      'circle-radius': 5,
      'circle-color': '#404040'
    }
  }
];


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/throttle.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/throttle.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function throttle(fn, time, context) {
  let lock, args;

  function later () {
    // reset lock and call if queued
    lock = false;
    if (args) {
      wrapperFn.apply(context, args);
      args = false;
    }
  }

  function wrapperFn () {
    if (lock) {
      // called too soon, queue to call later
      args = arguments;

    } else {
      // lock until later then call
      lock = true;
      fn.apply(context, arguments);
      setTimeout(later, time);
    }
  }

  return wrapperFn;
}

module.exports = throttle;


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/to_dense_array.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/to_dense_array.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Derive a dense array (no `undefined`s) from a single value or array.
 *
 * @param {any} x
 * @return {Array<any>}
 */
function toDenseArray(x) {
  return [].concat(x).filter(y => y !== undefined);
}

module.exports = toDenseArray;


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/direct_select.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/direct_select.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {noTarget, isOfMetaType, isInactiveFeature, isShiftDown} = __webpack_require__(/*! ../lib/common_selectors */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/common_selectors.js");
const createSupplementaryPoints = __webpack_require__(/*! ../lib/create_supplementary_points */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/create_supplementary_points.js");
const constrainFeatureMovement = __webpack_require__(/*! ../lib/constrain_feature_movement */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/constrain_feature_movement.js");
const doubleClickZoom = __webpack_require__(/*! ../lib/double_click_zoom */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/double_click_zoom.js");
const Constants = __webpack_require__(/*! ../constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");
const CommonSelectors = __webpack_require__(/*! ../lib/common_selectors */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/common_selectors.js");
const moveFeatures = __webpack_require__(/*! ../lib/move_features */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/move_features.js");

const isVertex = isOfMetaType(Constants.meta.VERTEX);
const isMidpoint = isOfMetaType(Constants.meta.MIDPOINT);

const DirectSelect = {};

// INTERNAL FUCNTIONS

DirectSelect.fireUpdate = function() {
  this.map.fire(Constants.events.UPDATE, {
    action: Constants.updateActions.CHANGE_COORDINATES,
    features: this.getSelected().map(f => f.toGeoJSON())
  });
};

DirectSelect.fireActionable = function(state) {
  this.setActionableState({
    combineFeatures: false,
    uncombineFeatures: false,
    trash: state.selectedCoordPaths.length > 0
  });
};

DirectSelect.startDragging = function(state, e) {
  this.map.dragPan.disable();
  state.canDragMove = true;
  state.dragMoveLocation = e.lngLat;
};

DirectSelect.stopDragging = function(state) {
  this.map.dragPan.enable();
  state.dragMoving = false;
  state.canDragMove = false;
  state.dragMoveLocation = null;
};

DirectSelect.onVertex = function (state, e) {
  this.startDragging(state, e);
  const about = e.featureTarget.properties;
  const selectedIndex = state.selectedCoordPaths.indexOf(about.coord_path);
  if (!isShiftDown(e) && selectedIndex === -1) {
    state.selectedCoordPaths = [about.coord_path];
  } else if (isShiftDown(e) && selectedIndex === -1) {
    state.selectedCoordPaths.push(about.coord_path);
  }

  const selectedCoordinates = this.pathsToCoordinates(state.featureId, state.selectedCoordPaths);
  this.setSelectedCoordinates(selectedCoordinates);
};

DirectSelect.onMidpoint = function(state, e) {
  this.startDragging(state, e);
  const about = e.featureTarget.properties;
  state.feature.addCoordinate(about.coord_path, about.lng, about.lat);
  this.fireUpdate();
  state.selectedCoordPaths = [about.coord_path];
};

DirectSelect.pathsToCoordinates = function(featureId, paths) {
  return paths.map(coord_path => { return { feature_id: featureId, coord_path }; });
};

DirectSelect.onFeature = function(state, e) {
  if (state.selectedCoordPaths.length === 0) this.startDragging(state, e);
  else this.stopDragging(state);
};

DirectSelect.dragFeature = function(state, e, delta) {
  moveFeatures(this.getSelected(), delta);
  state.dragMoveLocation = e.lngLat;
};

DirectSelect.dragVertex = function(state, e, delta) {
  const selectedCoords = state.selectedCoordPaths.map(coord_path => state.feature.getCoordinate(coord_path));
  const selectedCoordPoints = selectedCoords.map(coords => ({
    type: Constants.geojsonTypes.FEATURE,
    properties: {},
    geometry: {
      type: Constants.geojsonTypes.POINT,
      coordinates: coords
    }
  }));

  const constrainedDelta = constrainFeatureMovement(selectedCoordPoints, delta);
  for (let i = 0; i < selectedCoords.length; i++) {
    const coord = selectedCoords[i];
    state.feature.updateCoordinate(state.selectedCoordPaths[i], coord[0] + constrainedDelta.lng, coord[1] + constrainedDelta.lat);
  }
};

DirectSelect.clickNoTarget = function () {
  this.changeMode(Constants.modes.SIMPLE_SELECT);
};

DirectSelect.clickInactive = function () {
  this.changeMode(Constants.modes.SIMPLE_SELECT);
};

DirectSelect.clickActiveFeature = function (state) {
  state.selectedCoordPaths = [];
  this.clearSelectedCoordinates();
  state.feature.changed();
};

// EXTERNAL FUNCTIONS

DirectSelect.onSetup = function(opts) {
  const featureId = opts.featureId;
  const feature = this.getFeature(featureId);

  if (!feature) {
    throw new Error('You must provide a featureId to enter direct_select mode');
  }

  if (feature.type === Constants.geojsonTypes.POINT) {
    throw new TypeError('direct_select mode doesn\'t handle point features');
  }

  const state = {
    featureId,
    feature,
    dragMoveLocation: opts.startPos || null,
    dragMoving: false,
    canDragMove: false,
    selectedCoordPaths: opts.coordPath ? [opts.coordPath] : []
  };

  this.setSelectedCoordinates(this.pathsToCoordinates(featureId, state.selectedCoordPaths));
  this.setSelected(featureId);
  doubleClickZoom.disable(this);

  this.setActionableState({
    trash: true
  });

  return state;
};

DirectSelect.onStop = function() {
  doubleClickZoom.enable(this);
  this.clearSelectedCoordinates();
};

DirectSelect.toDisplayFeatures = function(state, geojson, push) {
  if (state.featureId === geojson.properties.id) {
    geojson.properties.active = Constants.activeStates.ACTIVE;
    push(geojson);
    createSupplementaryPoints(geojson, {
      map: this.map,
      midpoints: true,
      selectedPaths: state.selectedCoordPaths
    }).forEach(push);
  } else {
    geojson.properties.active = Constants.activeStates.INACTIVE;
    push(geojson);
  }
  this.fireActionable(state);
};

DirectSelect.onTrash = function(state) {
  state.selectedCoordPaths.sort().reverse().forEach(id => state.feature.removeCoordinate(id));
  this.fireUpdate();
  state.selectedCoordPaths = [];
  this.clearSelectedCoordinates();
  this.fireActionable(state);
  if (state.feature.isValid() === false) {
    this.deleteFeature([state.featureId]);
    this.changeMode(Constants.modes.SIMPLE_SELECT, {});
  }
};

DirectSelect.onMouseMove = function(state, e) {
  // On mousemove that is not a drag, stop vertex movement.
  const isFeature = CommonSelectors.isActiveFeature(e);
  const onVertex = isVertex(e);
  const noCoords = state.selectedCoordPaths.length === 0;
  if (isFeature && noCoords) this.updateUIClasses({ mouse: Constants.cursors.MOVE });
  else if (onVertex && !noCoords) this.updateUIClasses({ mouse: Constants.cursors.MOVE });
  else this.updateUIClasses({ mouse: Constants.cursors.NONE });
  this.stopDragging(state);
};

DirectSelect.onMouseOut = function(state) {
  // As soon as you mouse leaves the canvas, update the feature
  if (state.dragMoving) this.fireUpdate();
};

DirectSelect.onTouchStart = DirectSelect.onMouseDown = function(state, e) {
  if (isVertex(e)) return this.onVertex(state, e);
  if (CommonSelectors.isActiveFeature(e)) return this.onFeature(state, e);
  if (isMidpoint(e)) return this.onMidpoint(state, e);
};

DirectSelect.onDrag = function(state, e) {
  if (state.canDragMove !== true) return;
  state.dragMoving = true;
  e.originalEvent.stopPropagation();

  const delta = {
    lng: e.lngLat.lng - state.dragMoveLocation.lng,
    lat: e.lngLat.lat - state.dragMoveLocation.lat
  };
  if (state.selectedCoordPaths.length > 0) this.dragVertex(state, e, delta);
  else this.dragFeature(state, e, delta);

  state.dragMoveLocation = e.lngLat;
};

DirectSelect.onClick = function(state, e) {
  if (noTarget(e)) return this.clickNoTarget(state, e);
  if (CommonSelectors.isActiveFeature(e)) return this.clickActiveFeature(state, e);
  if (isInactiveFeature(e)) return this.clickInactive(state, e);
  this.stopDragging(state);
};

DirectSelect.onTap = function(state, e) {
  if (noTarget(e)) return this.clickNoTarget(state, e);
  if (CommonSelectors.isActiveFeature(e)) return this.clickActiveFeature(state, e);
  if (isInactiveFeature(e)) return this.clickInactive(state, e);
};

DirectSelect.onTouchEnd = DirectSelect.onMouseUp = function(state) {
  if (state.dragMoving) {
    this.fireUpdate();
  }
  this.stopDragging(state);
};

module.exports = DirectSelect;



/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_line_string.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_line_string.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const CommonSelectors = __webpack_require__(/*! ../lib/common_selectors */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/common_selectors.js");
const isEventAtCoordinates = __webpack_require__(/*! ../lib/is_event_at_coordinates */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/is_event_at_coordinates.js");
const doubleClickZoom = __webpack_require__(/*! ../lib/double_click_zoom */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/double_click_zoom.js");
const Constants = __webpack_require__(/*! ../constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");
const createVertex = __webpack_require__(/*! ../lib/create_vertex */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/create_vertex.js");

const DrawLineString = {};

DrawLineString.onSetup = function(opts) {
  opts = opts || {};
  const featureId = opts.featureId;

  let line, currentVertexPosition;
  let direction = 'forward';
  if (featureId) {
    line = this.getFeature(featureId);
    if (!line) {
      throw new Error('Could not find a feature with the provided featureId');
    }
    let from = opts.from;
    if (from && from.type === 'Feature' && from.geometry && from.geometry.type === 'Point') {
      from = from.geometry;
    }
    if (from && from.type === 'Point' && from.coordinates && from.coordinates.length === 2) {
      from = from.coordinates;
    }
    if (!from || !Array.isArray(from)) {
      throw new Error('Please use the `from` property to indicate which point to continue the line from');
    }
    const lastCoord = line.coordinates.length - 1;
    if (line.coordinates[lastCoord][0] === from[0] && line.coordinates[lastCoord][1] === from[1]) {
      currentVertexPosition = lastCoord + 1;
      // add one new coordinate to continue from
      line.addCoordinate(currentVertexPosition, ...line.coordinates[lastCoord]);
    } else if (line.coordinates[0][0] === from[0] && line.coordinates[0][1] === from[1]) {
      direction = 'backwards';
      currentVertexPosition = 0;
      // add one new coordinate to continue from
      line.addCoordinate(currentVertexPosition, ...line.coordinates[0]);
    } else {
      throw new Error('`from` should match the point at either the start or the end of the provided LineString');
    }
  } else {
    line = this.newFeature({
      type: Constants.geojsonTypes.FEATURE,
      properties: {},
      geometry: {
        type: Constants.geojsonTypes.LINE_STRING,
        coordinates: []
      }
    });
    currentVertexPosition = 0;
    this.addFeature(line);
  }

  this.clearSelectedFeatures();
  doubleClickZoom.disable(this);
  this.updateUIClasses({ mouse: Constants.cursors.ADD });
  this.activateUIButton(Constants.types.LINE);
  this.setActionableState({
    trash: true
  });

  return {
    line,
    currentVertexPosition,
    direction
  };
};

DrawLineString.clickAnywhere = function(state, e) {
  if (state.currentVertexPosition > 0 && isEventAtCoordinates(e, state.line.coordinates[state.currentVertexPosition - 1]) ||
      state.direction === 'backwards' && isEventAtCoordinates(e, state.line.coordinates[state.currentVertexPosition + 1])) {
    return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.line.id] });
  }
  this.updateUIClasses({ mouse: Constants.cursors.ADD });
  state.line.updateCoordinate(state.currentVertexPosition, e.lngLat.lng, e.lngLat.lat);
  if (state.direction === 'forward') {
    state.currentVertexPosition++;
    state.line.updateCoordinate(state.currentVertexPosition, e.lngLat.lng, e.lngLat.lat);
  } else {
    state.line.addCoordinate(0, e.lngLat.lng, e.lngLat.lat);
  }
};

DrawLineString.clickOnVertex = function(state) {
  return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.line.id] });
};

DrawLineString.onMouseMove = function(state, e) {
  state.line.updateCoordinate(state.currentVertexPosition, e.lngLat.lng, e.lngLat.lat);
  if (CommonSelectors.isVertex(e)) {
    this.updateUIClasses({ mouse: Constants.cursors.POINTER });
  }
};

DrawLineString.onTap = DrawLineString.onClick = function(state, e) {
  if (CommonSelectors.isVertex(e)) return this.clickOnVertex(state, e);
  this.clickAnywhere(state, e);
};

DrawLineString.onKeyUp = function(state, e) {
  if (CommonSelectors.isEnterKey(e)) {
    this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.line.id] });
  } else if (CommonSelectors.isEscapeKey(e)) {
    this.deleteFeature([state.line.id], { silent: true });
    this.changeMode(Constants.modes.SIMPLE_SELECT);
  }
};

DrawLineString.onStop = function(state) {
  doubleClickZoom.enable(this);
  this.activateUIButton();

  // check to see if we've deleted this feature
  if (this.getFeature(state.line.id) === undefined) return;

  //remove last added coordinate
  state.line.removeCoordinate(`${state.currentVertexPosition}`);
  if (state.line.isValid()) {
    this.map.fire(Constants.events.CREATE, {
      features: [state.line.toGeoJSON()]
    });
  } else {
    this.deleteFeature([state.line.id], { silent: true });
    this.changeMode(Constants.modes.SIMPLE_SELECT, {}, { silent: true });
  }
};

DrawLineString.onTrash = function(state) {
  this.deleteFeature([state.line.id], { silent: true });
  this.changeMode(Constants.modes.SIMPLE_SELECT);
};

DrawLineString.toDisplayFeatures = function(state, geojson, display) {
  const isActiveLine = geojson.properties.id === state.line.id;
  geojson.properties.active = (isActiveLine) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;
  if (!isActiveLine) return display(geojson);
  // Only render the line if it has at least one real coordinate
  if (geojson.geometry.coordinates.length < 2) return;
  geojson.properties.meta = Constants.meta.FEATURE;
  display(createVertex(
    state.line.id,
    geojson.geometry.coordinates[state.direction === 'forward' ? geojson.geometry.coordinates.length - 2 : 1],
    `${state.direction === 'forward' ? geojson.geometry.coordinates.length - 2 : 1}`,
    false
  ));

  display(geojson);
};

module.exports = DrawLineString;


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_point.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_point.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const CommonSelectors = __webpack_require__(/*! ../lib/common_selectors */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/common_selectors.js");
const Constants = __webpack_require__(/*! ../constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");

const DrawPoint = {};

DrawPoint.onSetup = function() {
  const point = this.newFeature({
    type: Constants.geojsonTypes.FEATURE,
    properties: {},
    geometry: {
      type: Constants.geojsonTypes.POINT,
      coordinates: []
    }
  });

  this.addFeature(point);

  this.clearSelectedFeatures();
  this.updateUIClasses({ mouse: Constants.cursors.ADD });
  this.activateUIButton(Constants.types.POINT);

  this.setActionableState({
    trash: true
  });

  return { point };
};

DrawPoint.stopDrawingAndRemove = function(state) {
  this.deleteFeature([state.point.id], { silent: true });
  this.changeMode(Constants.modes.SIMPLE_SELECT);
};

DrawPoint.onTap = DrawPoint.onClick = function(state, e) {
  this.updateUIClasses({ mouse: Constants.cursors.MOVE });
  state.point.updateCoordinate('', e.lngLat.lng, e.lngLat.lat);
  this.map.fire(Constants.events.CREATE, {
    features: [state.point.toGeoJSON()]
  });
  this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.point.id] });
};

DrawPoint.onStop = function(state) {
  this.activateUIButton();
  if (!state.point.getCoordinate().length) {
    this.deleteFeature([state.point.id], { silent: true });
  }
};

DrawPoint.toDisplayFeatures = function(state, geojson, display) {
  // Never render the point we're drawing
  const isActivePoint = geojson.properties.id === state.point.id;
  geojson.properties.active = (isActivePoint) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;
  if (!isActivePoint) return display(geojson);
};

DrawPoint.onTrash = DrawPoint.stopDrawingAndRemove;

DrawPoint.onKeyUp = function(state, e) {
  if (CommonSelectors.isEscapeKey(e) || CommonSelectors.isEnterKey(e)) {
    return this.stopDrawingAndRemove(state, e);
  }
};

module.exports = DrawPoint;


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_polygon.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_polygon.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const CommonSelectors = __webpack_require__(/*! ../lib/common_selectors */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/common_selectors.js");
const doubleClickZoom = __webpack_require__(/*! ../lib/double_click_zoom */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/double_click_zoom.js");
const Constants = __webpack_require__(/*! ../constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");
const isEventAtCoordinates = __webpack_require__(/*! ../lib/is_event_at_coordinates */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/is_event_at_coordinates.js");
const createVertex = __webpack_require__(/*! ../lib/create_vertex */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/create_vertex.js");

const DrawPolygon = {};

DrawPolygon.onSetup = function() {
  const polygon = this.newFeature({
    type: Constants.geojsonTypes.FEATURE,
    properties: {},
    geometry: {
      type: Constants.geojsonTypes.POLYGON,
      coordinates: [[]]
    }
  });

  this.addFeature(polygon);

  this.clearSelectedFeatures();
  doubleClickZoom.disable(this);
  this.updateUIClasses({ mouse: Constants.cursors.ADD });
  this.activateUIButton(Constants.types.POLYGON);
  this.setActionableState({
    trash: true
  });

  return {
    polygon,
    currentVertexPosition: 0
  };
};

DrawPolygon.clickAnywhere = function(state, e) {
  if (state.currentVertexPosition > 0 && isEventAtCoordinates(e, state.polygon.coordinates[0][state.currentVertexPosition - 1])) {
    return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.polygon.id] });
  }
  this.updateUIClasses({ mouse: Constants.cursors.ADD });
  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, e.lngLat.lng, e.lngLat.lat);
  state.currentVertexPosition++;
  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, e.lngLat.lng, e.lngLat.lat);
};

DrawPolygon.clickOnVertex = function(state) {
  return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.polygon.id] });
};

DrawPolygon.onMouseMove = function(state, e) {
  state.polygon.updateCoordinate(`0.${state.currentVertexPosition}`, e.lngLat.lng, e.lngLat.lat);
  if (CommonSelectors.isVertex(e)) {
    this.updateUIClasses({ mouse: Constants.cursors.POINTER });
  }
};

DrawPolygon.onTap = DrawPolygon.onClick = function(state, e) {
  if (CommonSelectors.isVertex(e)) return this.clickOnVertex(state, e);
  return this.clickAnywhere(state, e);
};

DrawPolygon.onKeyUp = function(state, e) {
  if (CommonSelectors.isEscapeKey(e)) {
    this.deleteFeature([state.polygon.id], { silent: true });
    this.changeMode(Constants.modes.SIMPLE_SELECT);
  } else if (CommonSelectors.isEnterKey(e)) {
    this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.polygon.id] });
  }
};

DrawPolygon.onStop = function(state) {
  this.updateUIClasses({ mouse: Constants.cursors.NONE });
  doubleClickZoom.enable(this);
  this.activateUIButton();

  // check to see if we've deleted this feature
  if (this.getFeature(state.polygon.id) === undefined) return;

  //remove last added coordinate
  state.polygon.removeCoordinate(`0.${state.currentVertexPosition}`);
  if (state.polygon.isValid()) {
    this.map.fire(Constants.events.CREATE, {
      features: [state.polygon.toGeoJSON()]
    });
  } else {
    this.deleteFeature([state.polygon.id], { silent: true });
    this.changeMode(Constants.modes.SIMPLE_SELECT, {}, { silent: true });
  }
};

DrawPolygon.toDisplayFeatures = function(state, geojson, display) {
  const isActivePolygon = geojson.properties.id === state.polygon.id;
  geojson.properties.active = (isActivePolygon) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;
  if (!isActivePolygon) return display(geojson);

  // Don't render a polygon until it has two positions
  // (and a 3rd which is just the first repeated)
  if (geojson.geometry.coordinates.length === 0) return;

  const coordinateCount = geojson.geometry.coordinates[0].length;
  // 2 coordinates after selecting a draw type
  // 3 after creating the first point
  if (coordinateCount < 3) {
    return;
  }
  geojson.properties.meta = Constants.meta.FEATURE;
  display(createVertex(state.polygon.id, geojson.geometry.coordinates[0][0], '0.0', false));
  if (coordinateCount > 3) {
    // Add a start position marker to the map, clicking on this will finish the feature
    // This should only be shown when we're in a valid spot
    const endPos = geojson.geometry.coordinates[0].length - 3;
    display(createVertex(state.polygon.id, geojson.geometry.coordinates[0][endPos], `0.${endPos}`, false));
  }
  if (coordinateCount <= 4) {
    // If we've only drawn two positions (plus the closer),
    // make a LineString instead of a Polygon
    const lineCoordinates = [
      [geojson.geometry.coordinates[0][0][0], geojson.geometry.coordinates[0][0][1]], [geojson.geometry.coordinates[0][1][0], geojson.geometry.coordinates[0][1][1]]
    ];
    // create an initial vertex so that we can track the first point on mobile devices
    display({
      type: Constants.geojsonTypes.FEATURE,
      properties: geojson.properties,
      geometry: {
        coordinates: lineCoordinates,
        type: Constants.geojsonTypes.LINE_STRING
      }
    });
    if (coordinateCount === 3) {
      return;
    }
  }
  // render the Polygon
  return display(geojson);
};

DrawPolygon.onTrash = function(state) {
  this.deleteFeature([state.polygon.id], { silent: true });
  this.changeMode(Constants.modes.SIMPLE_SELECT);
};

module.exports = DrawPolygon;


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/index.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/index.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  simple_select: __webpack_require__(/*! ./simple_select */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/simple_select.js"),
  direct_select: __webpack_require__(/*! ./direct_select */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/direct_select.js"),
  draw_point: __webpack_require__(/*! ./draw_point */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_point.js"),
  draw_polygon: __webpack_require__(/*! ./draw_polygon */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_polygon.js"),
  draw_line_string: __webpack_require__(/*! ./draw_line_string */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/draw_line_string.js"),
};


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/mode_interface.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/mode_interface.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const ModeInterface = module.exports = __webpack_require__(/*! ./mode_interface_accessors */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/mode_interface_accessors.js");

/**
 * Triggered while a mode is being transitioned into.
 * @param opts {Object} - this is the object passed via `draw.changeMode('mode', opts)`;
 * @name MODE.onSetup
 * @returns {Object} - this object will be passed to all other life cycle functions
 */
ModeInterface.prototype.onSetup = function() {};

/**
 * Triggered when a drag event is detected on the map
 * @name MODE.onDrag
 * @param state {Object} - a mutible state object created by onSetup
 * @param e {Object} - the captured event that is triggering this life cycle event
 */
ModeInterface.prototype.onDrag = function() {};

/**
 * Triggered when the mouse is clicked
 * @name MODE.onClick
 * @param state {Object} - a mutible state object created by onSetup
 * @param e {Object} - the captured event that is triggering this life cycle event
 */
ModeInterface.prototype.onClick = function() {};

/**
 * Triggered with the mouse is moved
 * @name MODE.onMouseMove
 * @param state {Object} - a mutible state object created by onSetup
 * @param e {Object} - the captured event that is triggering this life cycle event
 */
ModeInterface.prototype.onMouseMove = function() {};

/**
 * Triggered when the mouse button is pressed down
 * @name MODE.onMouseDown
 * @param state {Object} - a mutible state object created by onSetup
 * @param e {Object} - the captured event that is triggering this life cycle event
 */
ModeInterface.prototype.onMouseDown = function() {};

/**
 * Triggered when the mouse button is released
 * @name MODE.onMouseUp
 * @param state {Object} - a mutible state object created by onSetup
 * @param e {Object} - the captured event that is triggering this life cycle event
 */
ModeInterface.prototype.onMouseUp = function() {};

/**
 * Triggered when the mouse leaves the map's container
 * @name MODE.onMouseOut
 * @param state {Object} - a mutible state object created by onSetup
 * @param e {Object} - the captured event that is triggering this life cycle event
 */
ModeInterface.prototype.onMouseOut = function() {};

/**
 * Triggered when a key up event is detected
 * @name MODE.onKeyUp
 * @param state {Object} - a mutible state object created by onSetup
 * @param e {Object} - the captured event that is triggering this life cycle event
 */
ModeInterface.prototype.onKeyUp = function() {};

/**
 * Triggered when a key down event is detected
 * @name MODE.onKeyDown
 * @param state {Object} - a mutible state object created by onSetup
 * @param e {Object} - the captured event that is triggering this life cycle event
 */
ModeInterface.prototype.onKeyDown = function() {};

/**
 * Triggered when a touch event is started
 * @name MODE.onTouchStart
 * @param state {Object} - a mutible state object created by onSetup
 * @param e {Object} - the captured event that is triggering this life cycle event
 */
ModeInterface.prototype.onTouchStart = function() {};

/**
 * Triggered when one drags thier finger on a mobile device
 * @name MODE.onTouchMove
 * @param state {Object} - a mutible state object created by onSetup
 * @param e {Object} - the captured event that is triggering this life cycle event
 */
ModeInterface.prototype.onTouchMove = function() {};

/**
 * Triggered when one removes their finger from the map
 * @name MODE.onTouchEnd
 * @param state {Object} - a mutible state object created by onSetup
 * @param e {Object} - the captured event that is triggering this life cycle event
 */
ModeInterface.prototype.onTouchEnd = function() {};

/**
 * Triggered when one quicly taps the map
 * @name MODE.onTap
 * @param state {Object} - a mutible state object created by onSetup
 * @param e {Object} - the captured event that is triggering this life cycle event
 */
ModeInterface.prototype.onTap = function() {};

/**
 * Triggered when the mode is being exited, to be used for cleaning up artifacts such as invalid features
 * @name MODE.onStop
 * @param state {Object} - a mutible state object created by onSetup
 */
ModeInterface.prototype.onStop = function() {};

/**
 * Triggered when [draw.trash()](https://github.com/mapbox/mapbox-gl-draw/blob/master/API.md#trash-draw) is called.
 * @name MODE.onTrash
 * @param state {Object} - a mutible state object created by onSetup
 */
ModeInterface.prototype.onTrash = function() {};

/**
 * Triggered when [draw.combineFeatures()](https://github.com/mapbox/mapbox-gl-draw/blob/master/API.md#combinefeatures-draw) is called.
 * @name MODE.onCombineFeature
 * @param state {Object} - a mutible state object created by onSetup
 */
ModeInterface.prototype.onCombineFeature = function() {};

/**
 * Triggered when [draw.uncombineFeatures()](https://github.com/mapbox/mapbox-gl-draw/blob/master/API.md#uncombinefeatures-draw) is called.
 * @name MODE.onUncombineFeature
 * @param state {Object} - a mutible state object created by onSetup
 */
ModeInterface.prototype.onUncombineFeature = function() {};

/**
 * Triggered per feature on render to convert raw features into set of features for display on the map
 * See [styling draw](https://github.com/mapbox/mapbox-gl-draw/blob/master/API.md#styling-draw) for information about what geojson properties Draw uses as part of rendering.
 * @name MODE.toDisplayFeatures
 * @param state {Object} - a mutible state object created by onSetup
 * @param geojson {Object} - a geojson being evaulated. To render, pass to `display`.
 * @param display {Function} - all geojson objects passed to this be rendered onto the map
 */
ModeInterface.prototype.toDisplayFeatures = function() {
  throw new Error('You must overwrite toDisplayFeatures');
};



/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/mode_interface_accessors.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/mode_interface_accessors.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Constants = __webpack_require__(/*! ../constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");
const featuresAt = __webpack_require__(/*! ../lib/features_at */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/features_at.js");
const Point = __webpack_require__(/*! ../feature_types/point */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/point.js");
const LineString = __webpack_require__(/*! ../feature_types/line_string */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/line_string.js");
const Polygon = __webpack_require__(/*! ../feature_types/polygon */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/polygon.js");
const MultiFeature = __webpack_require__(/*! ../feature_types/multi_feature */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/feature_types/multi_feature.js");

const ModeInterface = module.exports = function(ctx) {
  this.map = ctx.map;
  this.drawConfig = JSON.parse(JSON.stringify(ctx.options || {}));
  this._ctx = ctx;
};

/**
 * Sets Draw's interal selected state
 * @name this.setSelected
 * @param {DrawFeature[]} - whats selected as a [DrawFeature](https://github.com/mapbox/mapbox-gl-draw/blob/master/src/feature_types/feature.js)
 */
ModeInterface.prototype.setSelected = function(features) {
  return this._ctx.store.setSelected(features);
};

/**
 * Sets Draw's internal selected coordinate state
 * @name this.setSelectedCoordinates
 * @param {Object[]} coords - a array of {coord_path: 'string', featureId: 'string'}
 */
ModeInterface.prototype.setSelectedCoordinates = function(coords) {
  this._ctx.store.setSelectedCoordinates(coords);
  coords.reduce((m, c) => {
    if (m[c.feature_id] === undefined) {
      m[c.feature_id] = true;
      this._ctx.store.get(c.feature_id).changed();
    }
    return m;
  }, {});
};

/**
 * Get all selected features as a [DrawFeature](https://github.com/mapbox/mapbox-gl-draw/blob/master/src/feature_types/feature.js)
 * @name this.getSelected
 * @returns {DrawFeature[]}
 */
ModeInterface.prototype.getSelected = function() {
  return this._ctx.store.getSelected();
};

/**
 * Get the ids of all currently selected features
 * @name this.getSelectedIds
 * @returns {String[]}
 */
ModeInterface.prototype.getSelectedIds = function() {
  return this._ctx.store.getSelectedIds();
};

/**
 * Check if a feature is selected
 * @name this.isSelected
 * @param {String} id - a feature id
 * @returns {Boolean}
 */
ModeInterface.prototype.isSelected = function(id) {
  return this._ctx.store.isSelected(id);
};

/**
 * Get a [DrawFeature](https://github.com/mapbox/mapbox-gl-draw/blob/master/src/feature_types/feature.js) by its id
 * @name this.getFeature
 * @param {String} id - a feature id
 * @returns {DrawFeature}
 */
ModeInterface.prototype.getFeature = function(id) {
  return this._ctx.store.get(id);
};

/**
 * Add a feature to draw's internal selected state
 * @name this.select
 * @param {String} id
 */
ModeInterface.prototype.select = function(id) {
  return this._ctx.store.select(id);
};

/**
 * Remove a feature from draw's internal selected state
 * @name this.delete
 * @param {String} id
 */
ModeInterface.prototype.deselect = function(id) {
  return this._ctx.store.deselect(id);
};

/**
 * Delete a feature from draw
 * @name this.deleteFeature
 * @param {String} id - a feature id
 */
ModeInterface.prototype.deleteFeature = function(id, opts = {}) {
  return this._ctx.store.delete(id, opts);
};

/**
 * Add a [DrawFeature](https://github.com/mapbox/mapbox-gl-draw/blob/master/src/feature_types/feature.js) to draw.
 * See `this.newFeature` for converting geojson into a DrawFeature
 * @name this.addFeature
 * @param {DrawFeature} feature - the feature to add
 */
ModeInterface.prototype.addFeature = function(feature) {
  return this._ctx.store.add(feature);
};

/**
 * Clear all selected features
 */
ModeInterface.prototype.clearSelectedFeatures = function() {
  return this._ctx.store.clearSelected();
};

/**
 * Clear all selected coordinates
 */
ModeInterface.prototype.clearSelectedCoordinates = function() {
  return this._ctx.store.clearSelectedCoordinates();
};

/**
 * Indicate if the different action are currently possible with your mode
 * See [draw.actionalbe](https://github.com/mapbox/mapbox-gl-draw/blob/master/API.md#drawactionable) for a list of possible actions. All undefined actions are set to **false** by default
 * @name this.setActionableState
 * @param {Object} actions
 */
ModeInterface.prototype.setActionableState = function(actions = {}) {
  const newSet = {
    trash: actions.trash || false,
    combineFeatures: actions.combineFeatures || false,
    uncombineFeatures: actions.uncombineFeatures || false
  };
  return this._ctx.events.actionable(newSet);
};

/**
 * Trigger a mode change
 * @name this.changeMode
 * @param {String} mode - the mode to transition into
 * @param {Object} opts - the options object to pass to the new mode
 * @param {Object} eventOpts - used to control what kind of events are emitted.
 */
ModeInterface.prototype.changeMode = function(mode, opts = {}, eventOpts = {}) {
  return this._ctx.events.changeMode(mode, opts, eventOpts);
};

/**
 * Update the state of draw map classes
 * @name this.updateUIClasses
 * @param {Object} opts
 */
ModeInterface.prototype.updateUIClasses = function(opts) {
  return this._ctx.ui.queueMapClasses(opts);
};

/**
 * If a name is provided it makes that button active, else if makes all buttons inactive
 * @name this.activateUIButton
 * @param {String?} name - name of the button to make active, leave as undefined to set buttons to be inactive
 */
ModeInterface.prototype.activateUIButton = function(name) {
  return this._ctx.ui.setActiveButton(name);
};

/**
 * Get the features at the location of an event object or in a bbox
 * @name this.featuresAt
 * @param {Event||NULL} event - a mapbox-gl event object
 * @param {BBOX||NULL} bbox - the area to get features from
 * @param {String} bufferType - is this `click` or `tap` event, defaults to click
 */
ModeInterface.prototype.featuresAt = function(event, bbox, bufferType = 'click') {
  if (bufferType !== 'click' && bufferType !== 'touch') throw new Error('invalid buffer type');
  return featuresAt[bufferType](event, bbox, this._ctx);
};

/**
 * Create a new [DrawFeature](https://github.com/mapbox/mapbox-gl-draw/blob/master/src/feature_types/feature.js) from geojson
 * @name this.newFeature
 * @param {GeoJSONFeature} geojson
 * @returns {DrawFeature}
 */
ModeInterface.prototype.newFeature = function(geojson) {
  const type = geojson.geometry.type;
  if (type === Constants.geojsonTypes.POINT) return new Point(this._ctx, geojson);
  if (type === Constants.geojsonTypes.LINE_STRING) return new LineString(this._ctx, geojson);
  if (type === Constants.geojsonTypes.POLYGON) return new Polygon(this._ctx, geojson);
  return new MultiFeature(this._ctx, geojson);
};

/**
 * Check is an object is an instance of a [DrawFeature](https://github.com/mapbox/mapbox-gl-draw/blob/master/src/feature_types/feature.js)
 * @name this.isInstanceOf
 * @param {String} type - `Point`, `LineString`, `Polygon`, `MultiFeature`
 * @param {Object} feature - the object that needs to be checked
 * @returns {Boolean}
 */
ModeInterface.prototype.isInstanceOf = function(type, feature) {
  if (type === Constants.geojsonTypes.POINT) return feature instanceof Point;
  if (type === Constants.geojsonTypes.LINE_STRING) return feature instanceof LineString;
  if (type === Constants.geojsonTypes.POLYGON) return feature instanceof Polygon;
  if (type === 'MultiFeature') return feature instanceof MultiFeature;
  throw new Error(`Unknown feature class: ${type}`);
};

/**
 * Force draw to rerender the feature of the provided id
 * @name this.doRender
 * @param {String} id - a feature id
 */
ModeInterface.prototype.doRender = function(id) {
  return this._ctx.store.featureChanged(id);
};



/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/object_to_mode.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/object_to_mode.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const ModeInterface = __webpack_require__(/*! ./mode_interface */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/mode_interface.js");

const eventMapper = {
  drag: 'onDrag',
  click: 'onClick',
  mousemove: 'onMouseMove',
  mousedown: 'onMouseDown',
  mouseup: 'onMouseUp',
  mouseout: 'onMouseOut',
  keyup: 'onKeyUp',
  keydown: 'onKeyDown',
  touchstart: 'onTouchStart',
  touchmove: 'onTouchMove',
  touchend: 'onTouchEnd',
  tap: 'onTap'
};

const eventKeys = Object.keys(eventMapper);

module.exports = function(modeObject) {
  const modeObjectKeys = Object.keys(modeObject);

  return function(ctx, startOpts = {}) {
    let state = {};

    const mode = modeObjectKeys.reduce((m, k) => {
      m[k] = modeObject[k];
      return m;
    }, new ModeInterface(ctx));

    function wrapper(eh) {
      return function(e) {
        mode[eh](state, e);
      };
    }

    return {
      start: function() {
        state = mode.onSetup(startOpts); // this should set ui buttons

        // Adds event handlers for all event options
        // add sets the selector to false for all
        // handlers that are not present in the mode
        // to reduce on render calls for functions that
        // have no logic
        eventKeys.forEach(key => {
          const modeHandler = eventMapper[key];
          let selector = () => false;
          if (modeObject[modeHandler]) {
            selector = () => true;
          }
          this.on(key, selector, wrapper(modeHandler));
        });

      },
      stop: function() {
        mode.onStop(state);
      },
      trash: function() {
        mode.onTrash(state);
      },
      combineFeatures: function() {
        mode.onCombineFeatures(state);
      },
      uncombineFeatures: function() {
        mode.onUncombineFeatures(state);
      },
      render: function(geojson, push) {
        mode.toDisplayFeatures(state, geojson, push);
      }
    };
  };
};


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/simple_select.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/simple_select.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const CommonSelectors = __webpack_require__(/*! ../lib/common_selectors */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/common_selectors.js");
const mouseEventPoint = __webpack_require__(/*! ../lib/mouse_event_point */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/mouse_event_point.js");
const createSupplementaryPoints = __webpack_require__(/*! ../lib/create_supplementary_points */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/create_supplementary_points.js");
const StringSet = __webpack_require__(/*! ../lib/string_set */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/string_set.js");
const doubleClickZoom = __webpack_require__(/*! ../lib/double_click_zoom */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/double_click_zoom.js");
const moveFeatures = __webpack_require__(/*! ../lib/move_features */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/move_features.js");
const Constants = __webpack_require__(/*! ../constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");

const SimpleSelect = {};

SimpleSelect.onSetup = function(opts) {
  // turn the opts into state.
  const state = {
    dragMoveLocation: null,
    boxSelectStartLocation: null,
    boxSelectElement: undefined,
    boxSelecting: false,
    canBoxSelect: false,
    dragMoveing: false,
    canDragMove: false,
    initiallySelectedFeatureIds: opts.featureIds || []
  };

  this.setSelected(state.initiallySelectedFeatureIds.filter(id => {
    return this.getFeature(id) !== undefined;
  }));
  this.fireActionable();

  this.setActionableState({
    combineFeatures: true,
    uncombineFeatures: true,
    trash: true
  });

  return state;
};

SimpleSelect.fireUpdate = function() {
  this.map.fire(Constants.events.UPDATE, {
    action: Constants.updateActions.MOVE,
    features: this.getSelected().map(f => f.toGeoJSON())
  });
};

SimpleSelect.fireActionable = function() {
  const selectedFeatures = this.getSelected();

  const multiFeatures = selectedFeatures.filter(
    feature => this.isInstanceOf('MultiFeature', feature)
  );

  let combineFeatures = false;

  if (selectedFeatures.length > 1) {
    combineFeatures = true;
    const featureType = selectedFeatures[0].type.replace('Multi', '');
    selectedFeatures.forEach(feature => {
      if (feature.type.replace('Multi', '') !== featureType) {
        combineFeatures = false;
      }
    });
  }

  const uncombineFeatures = multiFeatures.length > 0;
  const trash = selectedFeatures.length > 0;

  this.setActionableState({
    combineFeatures, uncombineFeatures, trash
  });
};

SimpleSelect.getUniqueIds = function(allFeatures) {
  if (!allFeatures.length) return [];
  const ids = allFeatures.map(s => s.properties.id)
    .filter(id => id !== undefined)
    .reduce((memo, id) => {
      memo.add(id);
      return memo;
    }, new StringSet());

  return ids.values();
};

SimpleSelect.stopExtendedInteractions = function(state) {
  if (state.boxSelectElement) {
    if (state.boxSelectElement.parentNode) state.boxSelectElement.parentNode.removeChild(state.boxSelectElement);
    state.boxSelectElement = null;
  }

  this.map.dragPan.enable();

  state.boxSelecting = false;
  state.canBoxSelect = false;
  state.dragMoving = false;
  state.canDragMove = false;
};

SimpleSelect.onStop = function() {
  doubleClickZoom.enable(this);
};

SimpleSelect.onMouseMove = function(state) {
  // On mousemove that is not a drag, stop extended interactions.
  // This is useful if you drag off the canvas, release the button,
  // then move the mouse back over the canvas --- we don't allow the
  // interaction to continue then, but we do let it continue if you held
  // the mouse button that whole time
  return this.stopExtendedInteractions(state);
};

SimpleSelect.onMouseOut = function(state) {
  // As soon as you mouse leaves the canvas, update the feature
  if (state.dragMoving) return this.fireUpdate();
};

SimpleSelect.onTap = SimpleSelect.onClick = function(state, e) {
  // Click (with or without shift) on no feature
  if (CommonSelectors.noTarget(e)) return this.clickAnywhere(state, e); // also tap
  if (CommonSelectors.isOfMetaType(Constants.meta.VERTEX)(e)) return this.clickOnVertex(state, e); //tap
  if (CommonSelectors.isFeature(e)) return this.clickOnFeature(state, e);
};

SimpleSelect.clickAnywhere = function (state) {
  // Clear the re-render selection
  const wasSelected = this.getSelectedIds();
  if (wasSelected.length) {
    this.clearSelectedFeatures();
    wasSelected.forEach(id => this.doRender(id));
  }
  doubleClickZoom.enable(this);
  this.stopExtendedInteractions(state);
};

SimpleSelect.clickOnVertex = function(state, e) {
  // Enter direct select mode
  this.changeMode(Constants.modes.DIRECT_SELECT, {
    featureId: e.featureTarget.properties.parent,
    coordPath: e.featureTarget.properties.coord_path,
    startPos: e.lngLat
  });
  this.updateUIClasses({ mouse: Constants.cursors.MOVE });
};

SimpleSelect.startOnActiveFeature = function(state, e) {
  // Stop any already-underway extended interactions
  this.stopExtendedInteractions(state);

  // Disable map.dragPan immediately so it can't start
  this.map.dragPan.disable();

  // Re-render it and enable drag move
  this.doRender(e.featureTarget.properties.id);

  // Set up the state for drag moving
  state.canDragMove = true;
  state.dragMoveLocation = e.lngLat;
};

SimpleSelect.clickOnFeature = function(state, e) {
  // Stop everything
  doubleClickZoom.disable(this);
  this.stopExtendedInteractions(state);

  const isShiftClick = CommonSelectors.isShiftDown(e);
  const selectedFeatureIds = this.getSelectedIds();
  const featureId = e.featureTarget.properties.id;
  const isFeatureSelected = this.isSelected(featureId);

  // Click (without shift) on any selected feature but a point
  if (!isShiftClick && isFeatureSelected && this.getFeature(featureId).type !== Constants.geojsonTypes.POINT) {
    // Enter direct select mode
    return this.changeMode(Constants.modes.DIRECT_SELECT, {
      featureId: featureId
    });
  }

  // Shift-click on a selected feature
  if (isFeatureSelected && isShiftClick) {
    // Deselect it
    this.deselect(featureId);
    this.updateUIClasses({ mouse: Constants.cursors.POINTER });
    if (selectedFeatureIds.length === 1) {
      doubleClickZoom.enable(this);
    }
  // Shift-click on an unselected feature
  } else if (!isFeatureSelected && isShiftClick) {
    // Add it to the selection
    this.select(featureId);
    this.updateUIClasses({ mouse: Constants.cursors.MOVE });
  // Click (without shift) on an unselected feature
  } else if (!isFeatureSelected && !isShiftClick) {
    // Make it the only selected feature
    selectedFeatureIds.forEach(id => this.doRender(id));
    this.setSelected(featureId);
    this.updateUIClasses({ mouse: Constants.cursors.MOVE });
  }

  // No matter what, re-render the clicked feature
  this.doRender(featureId);
};

SimpleSelect.onMouseDown = function(state, e) {
  if (CommonSelectors.isActiveFeature(e)) return this.startOnActiveFeature(state, e);
  if (this.drawConfig.boxSelect && CommonSelectors.isShiftMousedown(e)) return this.startBoxSelect(state, e);
};

SimpleSelect.startBoxSelect = function(state, e) {
  this.stopExtendedInteractions(state);
  this.map.dragPan.disable();
  // Enable box select
  state.boxSelectStartLocation = mouseEventPoint(e.originalEvent, this.map.getContainer());
  state.canBoxSelect = true;
};

SimpleSelect.onTouchStart = function(state, e) {
  if (CommonSelectors.isActiveFeature(e)) return this.startOnActiveFeature(state, e);
};

SimpleSelect.onDrag = function(state, e) {
  if (state.canDragMove) return this.dragMove(state, e);
  if (this.drawConfig.boxSelect && state.canBoxSelect) return this.whileBoxSelect(state, e);
};

SimpleSelect.whileBoxSelect = function(state, e) {
  state.boxSelecting = true;
  this.updateUIClasses({ mouse: Constants.cursors.ADD });

  // Create the box node if it doesn't exist
  if (!state.boxSelectElement) {
    state.boxSelectElement = document.createElement('div');
    state.boxSelectElement.classList.add(Constants.classes.BOX_SELECT);
    this.map.getContainer().appendChild(state.boxSelectElement);
  }

  // Adjust the box node's width and xy position
  const current = mouseEventPoint(e.originalEvent, this.map.getContainer());
  const minX = Math.min(state.boxSelectStartLocation.x, current.x);
  const maxX = Math.max(state.boxSelectStartLocation.x, current.x);
  const minY = Math.min(state.boxSelectStartLocation.y, current.y);
  const maxY = Math.max(state.boxSelectStartLocation.y, current.y);
  const translateValue = `translate(${minX}px, ${minY}px)`;
  state.boxSelectElement.style.transform = translateValue;
  state.boxSelectElement.style.WebkitTransform = translateValue;
  state.boxSelectElement.style.width = `${maxX - minX}px`;
  state.boxSelectElement.style.height = `${maxY - minY}px`;
};

SimpleSelect.dragMove = function(state, e) {
  // Dragging when drag move is enabled
  state.dragMoving = true;
  e.originalEvent.stopPropagation();

  const delta = {
    lng: e.lngLat.lng - state.dragMoveLocation.lng,
    lat: e.lngLat.lat - state.dragMoveLocation.lat
  };

  moveFeatures(this.getSelected(), delta);

  state.dragMoveLocation = e.lngLat;
};

SimpleSelect.onMouseUp = function(state, e) {
  // End any extended interactions
  if (state.dragMoving) {
    this.fireUpdate();
  } else if (state.boxSelecting) {
    const bbox = [
      state.boxSelectStartLocation,
      mouseEventPoint(e.originalEvent, this.map.getContainer())
    ];
    const featuresInBox = this.featuresAt(null, bbox, 'click');
    const idsToSelect = this.getUniqueIds(featuresInBox)
      .filter(id => !this.isSelected(id));

    if (idsToSelect.length) {
      this.select(idsToSelect);
      idsToSelect.forEach(id => this.doRender(id));
      this.updateUIClasses({ mouse: Constants.cursors.MOVE });
    }
  }
  this.stopExtendedInteractions(state);
};

SimpleSelect.toDisplayFeatures = function(state, geojson, display) {
  geojson.properties.active = (this.isSelected(geojson.properties.id)) ?
    Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;
  display(geojson);
  this.fireActionable();
  if (geojson.properties.active !== Constants.activeStates.ACTIVE ||
    geojson.geometry.type === Constants.geojsonTypes.POINT) return;
  createSupplementaryPoints(geojson).forEach(display);
};

SimpleSelect.onTrash = function() {
  this.deleteFeature(this.getSelectedIds());
  this.fireActionable();
};

SimpleSelect.onCombineFeatures = function() {
  const selectedFeatures = this.getSelected();

  if (selectedFeatures.length === 0 || selectedFeatures.length < 2) return;

  const coordinates = [], featuresCombined = [];
  const featureType = selectedFeatures[0].type.replace('Multi', '');

  for (let i = 0; i < selectedFeatures.length; i++) {
    const feature = selectedFeatures[i];

    if (feature.type.replace('Multi', '') !== featureType) {
      return;
    }
    if (feature.type.includes('Multi')) {
      feature.getCoordinates().forEach((subcoords) => {
        coordinates.push(subcoords);
      });
    } else {
      coordinates.push(feature.getCoordinates());
    }

    featuresCombined.push(feature.toGeoJSON());
  }

  if (featuresCombined.length > 1) {
    const multiFeature = this.newFeature({
      type: Constants.geojsonTypes.FEATURE,
      properties: featuresCombined[0].properties,
      geometry: {
        type: `Multi${featureType}`,
        coordinates: coordinates
      }
    });

    this.addFeature(multiFeature);
    this.deleteFeature(this.getSelectedIds(), { silent: true });
    this.setSelected([multiFeature.id]);

    this.map.fire(Constants.events.COMBINE_FEATURES, {
      createdFeatures: [multiFeature.toGeoJSON()],
      deletedFeatures: featuresCombined
    });
  }
  this.fireActionable();
};

SimpleSelect.onUncombineFeatures = function() {
  const selectedFeatures = this.getSelected();
  if (selectedFeatures.length === 0) return;

  const createdFeatures = [];
  const featuresUncombined = [];

  for (let i = 0; i < selectedFeatures.length; i++) {
    const feature = selectedFeatures[i];

    if (this.isInstanceOf('MultiFeature', feature)) {
      feature.getFeatures().forEach((subFeature) => {
        this.addFeature(subFeature);
        subFeature.properties = feature.properties;
        createdFeatures.push(subFeature.toGeoJSON());
        this.select([subFeature.id]);
      });
      this.deleteFeature(feature.id, { silent: true });
      featuresUncombined.push(feature.toGeoJSON());
    }
  }

  if (createdFeatures.length > 1) {
    this.map.fire(Constants.events.UNCOMBINE_FEATURES, {
      createdFeatures: createdFeatures,
      deletedFeatures: featuresUncombined
    });
  }
  this.fireActionable();
};

module.exports = SimpleSelect;


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/options.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/options.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const xtend = __webpack_require__(/*! xtend */ "./node_modules/xtend/immutable.js");
const Constants = __webpack_require__(/*! ./constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");

const defaultOptions = {
  defaultMode: Constants.modes.SIMPLE_SELECT,
  keybindings: true,
  touchEnabled: true,
  clickBuffer: 2,
  touchBuffer: 25,
  boxSelect: true,
  displayControlsDefault: true,
  styles: __webpack_require__(/*! ./lib/theme */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/theme.js"),
  modes: __webpack_require__(/*! ./modes */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/modes/index.js"),
  controls: {},
  userProperties: false
};

const showControls = {
  point: true,
  line_string: true,
  polygon: true,
  trash: true,
  combine_features: true,
  uncombine_features: true
};

const hideControls = {
  point: false,
  line_string: false,
  polygon: false,
  trash: false,
  combine_features: false,
  uncombine_features: false
};

function addSources(styles, sourceBucket) {
  return styles.map(style => {
    if (style.source) return style;
    return xtend(style, {
      id: `${style.id}.${sourceBucket}`,
      source: (sourceBucket === 'hot') ? Constants.sources.HOT : Constants.sources.COLD
    });
  });
}

module.exports = function(options = {}) {
  let withDefaults = xtend(options);

  if (!options.controls) {
    withDefaults.controls = {};
  }

  if (options.displayControlsDefault === false) {
    withDefaults.controls = xtend(hideControls, options.controls);
  } else {
    withDefaults.controls = xtend(showControls, options.controls);
  }

  withDefaults = xtend(defaultOptions, withDefaults);

  // Layers with a shared source should be adjacent for performance reasons
  withDefaults.styles = addSources(withDefaults.styles, 'cold').concat(addSources(withDefaults.styles, 'hot'));

  return withDefaults;
};


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/render.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/render.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Constants = __webpack_require__(/*! ./constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");

module.exports = function render() {
  const store = this;
  const mapExists = store.ctx.map && store.ctx.map.getSource(Constants.sources.HOT) !== undefined;
  if (!mapExists) return cleanup();

  const mode = store.ctx.events.currentModeName();

  store.ctx.ui.queueMapClasses({ mode });

  let newHotIds = [];
  let newColdIds = [];

  if (store.isDirty) {
    newColdIds = store.getAllIds();
  } else {
    newHotIds = store.getChangedIds().filter(id => store.get(id) !== undefined);
    newColdIds = store.sources.hot.filter((geojson) => {
      return geojson.properties.id && newHotIds.indexOf(geojson.properties.id) === -1 && store.get(geojson.properties.id) !== undefined;
    }).map(geojson => geojson.properties.id);
  }

  store.sources.hot = [];
  const lastColdCount = store.sources.cold.length;
  store.sources.cold = store.isDirty ? [] : store.sources.cold.filter((geojson) => {
    const id = geojson.properties.id || geojson.properties.parent;
    return newHotIds.indexOf(id) === -1;
  });

  const coldChanged = lastColdCount !== store.sources.cold.length || newColdIds.length > 0;
  newHotIds.forEach(id => renderFeature(id, 'hot'));
  newColdIds.forEach(id => renderFeature(id, 'cold'));

  function renderFeature(id, source) {
    const feature = store.get(id);
    const featureInternal = feature.internal(mode);
    store.ctx.events.currentModeRender(featureInternal, (geojson) => {
      store.sources[source].push(geojson);
    });
  }

  if (coldChanged) {
    store.ctx.map.getSource(Constants.sources.COLD).setData({
      type: Constants.geojsonTypes.FEATURE_COLLECTION,
      features: store.sources.cold
    });
  }

  store.ctx.map.getSource(Constants.sources.HOT).setData({
    type: Constants.geojsonTypes.FEATURE_COLLECTION,
    features: store.sources.hot
  });

  if (store._emitSelectionChange) {
    store.ctx.map.fire(Constants.events.SELECTION_CHANGE, {
      features: store.getSelected().map(feature => feature.toGeoJSON()),
      points: store.getSelectedCoordinates().map(coordinate => {
        return {
          type: Constants.geojsonTypes.FEATURE,
          properties: {},
          geometry: {
            type: Constants.geojsonTypes.POINT,
            coordinates: coordinate.coordinates
          }
        };
      })
    });
    store._emitSelectionChange = false;
  }

  if (store._deletedFeaturesToEmit.length) {
    const geojsonToEmit = store._deletedFeaturesToEmit.map(feature => feature.toGeoJSON());

    store._deletedFeaturesToEmit = [];

    store.ctx.map.fire(Constants.events.DELETE, {
      features: geojsonToEmit
    });
  }

  cleanup();
  store.ctx.map.fire(Constants.events.RENDER, {});

  function cleanup() {
    store.isDirty = false;
    store.clearChangedIds();
  }
};


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/setup.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/setup.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const events = __webpack_require__(/*! ./events */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/events.js");
const Store = __webpack_require__(/*! ./store */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/store.js");
const ui = __webpack_require__(/*! ./ui */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/ui.js");
const Constants = __webpack_require__(/*! ./constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");
const xtend = __webpack_require__(/*! xtend */ "./node_modules/xtend/immutable.js");

module.exports = function(ctx) {

  let controlContainer = null;
  let mapLoadedInterval = null;

  const setup = {
    onRemove: function() {
      // Stop connect attempt in the event that control is removed before map is loaded
      ctx.map.off('load', setup.connect);
      clearInterval(mapLoadedInterval);

      setup.removeLayers();
      ctx.store.restoreMapConfig();
      ctx.ui.removeButtons();
      ctx.events.removeEventListeners();
      ctx.ui.clearMapClasses();
      ctx.map = null;
      ctx.container = null;
      ctx.store = null;

      if (controlContainer && controlContainer.parentNode) controlContainer.parentNode.removeChild(controlContainer);
      controlContainer = null;

      return this;
    },
    connect: function() {
      ctx.map.off('load', setup.connect);
      clearInterval(mapLoadedInterval);
      setup.addLayers();
      ctx.store.storeMapConfig();
      ctx.events.addEventListeners();
    },
    onAdd: function(map) {
      if (true) {
        // Monkey patch to resolve breaking change to `fire` introduced by
        // mapbox-gl-js. See mapbox/mapbox-gl-draw/issues/766.
        const _fire = map.fire;
        map.fire = function(type, event) {
          let args = arguments;

          if (_fire.length === 1 && arguments.length !== 1) {
            args = [xtend({}, { type: type }, event)];
          }

          return _fire.apply(map, args);
        };
      }

      ctx.map = map;
      ctx.events = events(ctx);
      ctx.ui = ui(ctx);
      ctx.container = map.getContainer();
      ctx.store = new Store(ctx);


      controlContainer = ctx.ui.addButtons();

      if (ctx.options.boxSelect) {
        map.boxZoom.disable();
        // Need to toggle dragPan on and off or else first
        // dragPan disable attempt in simple_select doesn't work
        map.dragPan.disable();
        map.dragPan.enable();
      }

      if (map.loaded()) {
        setup.connect();
      } else {
        map.on('load', setup.connect);
        mapLoadedInterval = setInterval(() => { if (map.loaded()) setup.connect(); }, 16);
      }

      ctx.events.start();
      return controlContainer;
    },
    addLayers: function() {
      // drawn features style
      ctx.map.addSource(Constants.sources.COLD, {
        data: {
          type: Constants.geojsonTypes.FEATURE_COLLECTION,
          features: []
        },
        type: 'geojson'
      });

      // hot features style
      ctx.map.addSource(Constants.sources.HOT, {
        data: {
          type: Constants.geojsonTypes.FEATURE_COLLECTION,
          features: []
        },
        type: 'geojson'
      });

      ctx.options.styles.forEach(style => {
        ctx.map.addLayer(style);
      });

      ctx.store.setDirty(true);
      ctx.store.render();
    },
    // Check for layers and sources before attempting to remove
    // If user adds draw control and removes it before the map is loaded, layers and sources will be missing
    removeLayers: function() {
      ctx.options.styles.forEach(style => {
        if (ctx.map.getLayer(style.id)) {
          ctx.map.removeLayer(style.id);
        }
      });

      if (ctx.map.getSource(Constants.sources.COLD)) {
        ctx.map.removeSource(Constants.sources.COLD);
      }

      if (ctx.map.getSource(Constants.sources.HOT)) {
        ctx.map.removeSource(Constants.sources.HOT);
      }
    }
  };

  ctx.setup = setup;

  return setup;
};


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/store.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/store.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const throttle = __webpack_require__(/*! ./lib/throttle */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/throttle.js");
const toDenseArray = __webpack_require__(/*! ./lib/to_dense_array */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/to_dense_array.js");
const StringSet = __webpack_require__(/*! ./lib/string_set */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/lib/string_set.js");
const render = __webpack_require__(/*! ./render */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/render.js");
const interactions = __webpack_require__(/*! ./constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js").interactions;

const Store = module.exports = function(ctx) {
  this._features = {};
  this._featureIds = new StringSet();
  this._selectedFeatureIds = new StringSet();
  this._selectedCoordinates = [];
  this._changedFeatureIds = new StringSet();
  this._deletedFeaturesToEmit = [];
  this._emitSelectionChange = false;
  this._mapInitialConfig = {};
  this.ctx = ctx;
  this.sources = {
    hot: [],
    cold: []
  };
  this.render = throttle(render, 16, this);
  this.isDirty = false;
};


/**
 * Delays all rendering until the returned function is invoked
 * @return {Function} renderBatch
 */
Store.prototype.createRenderBatch = function() {
  const holdRender = this.render;
  let numRenders = 0;
  this.render = function() {
    numRenders++;
  };

  return () => {
    this.render = holdRender;
    if (numRenders > 0) {
      this.render();
    }
  };
};

/**
 * Sets the store's state to dirty.
 * @return {Store} this
 */
Store.prototype.setDirty = function() {
  this.isDirty = true;
  return this;
};

/**
 * Sets a feature's state to changed.
 * @param {string} featureId
 * @return {Store} this
 */
Store.prototype.featureChanged = function(featureId) {
  this._changedFeatureIds.add(featureId);
  return this;
};

/**
 * Gets the ids of all features currently in changed state.
 * @return {Store} this
 */
Store.prototype.getChangedIds = function() {
  return this._changedFeatureIds.values();
};

/**
 * Sets all features to unchanged state.
 * @return {Store} this
 */
Store.prototype.clearChangedIds = function() {
  this._changedFeatureIds.clear();
  return this;
};

/**
 * Gets the ids of all features in the store.
 * @return {Store} this
 */
Store.prototype.getAllIds = function() {
  return this._featureIds.values();
};

/**
 * Adds a feature to the store.
 * @param {Object} feature
 *
 * @return {Store} this
 */
Store.prototype.add = function(feature) {
  this.featureChanged(feature.id);
  this._features[feature.id] = feature;
  this._featureIds.add(feature.id);
  return this;
};

/**
 * Deletes a feature or array of features from the store.
 * Cleans up after the deletion by deselecting the features.
 * If changes were made, sets the state to the dirty
 * and fires an event.
 * @param {string | Array<string>} featureIds
 * @param {Object} [options]
 * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.
 * @return {Store} this
 */
Store.prototype.delete = function(featureIds, options = {}) {
  toDenseArray(featureIds).forEach(id => {
    if (!this._featureIds.has(id)) return;
    this._featureIds.delete(id);
    this._selectedFeatureIds.delete(id);
    if (!options.silent) {
      if (this._deletedFeaturesToEmit.indexOf(this._features[id]) === -1) {
        this._deletedFeaturesToEmit.push(this._features[id]);
      }
    }
    delete this._features[id];
    this.isDirty = true;
  });
  refreshSelectedCoordinates.call(this, options);
  return this;
};

/**
 * Returns a feature in the store matching the specified value.
 * @return {Object | undefined} feature
 */
Store.prototype.get = function(id) {
  return this._features[id];
};

/**
 * Returns all features in the store.
 * @return {Array<Object>}
 */
Store.prototype.getAll = function() {
  return Object.keys(this._features).map(id => this._features[id]);
};

/**
 * Adds features to the current selection.
 * @param {string | Array<string>} featureIds
 * @param {Object} [options]
 * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.
 * @return {Store} this
 */
Store.prototype.select = function(featureIds, options = {}) {
  toDenseArray(featureIds).forEach(id => {
    if (this._selectedFeatureIds.has(id)) return;
    this._selectedFeatureIds.add(id);
    this._changedFeatureIds.add(id);
    if (!options.silent) {
      this._emitSelectionChange = true;
    }
  });
  return this;
};

/**
 * Deletes features from the current selection.
 * @param {string | Array<string>} featureIds
 * @param {Object} [options]
 * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.
 * @return {Store} this
 */
Store.prototype.deselect = function(featureIds, options = {}) {
  toDenseArray(featureIds).forEach(id => {
    if (!this._selectedFeatureIds.has(id)) return;
    this._selectedFeatureIds.delete(id);
    this._changedFeatureIds.add(id);
    if (!options.silent) {
      this._emitSelectionChange = true;
    }
  });
  refreshSelectedCoordinates.call(this, options);
  return this;
};

/**
 * Clears the current selection.
 * @param {Object} [options]
 * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.
 * @return {Store} this
 */
Store.prototype.clearSelected = function(options = {}) {
  this.deselect(this._selectedFeatureIds.values(), { silent: options.silent });
  return this;
};

/**
 * Sets the store's selection, clearing any prior values.
 * If no feature ids are passed, the store is just cleared.
 * @param {string | Array<string> | undefined} featureIds
 * @param {Object} [options]
 * @param {Object} [options.silent] - If `true`, this invocation will not fire an event.
 * @return {Store} this
 */
Store.prototype.setSelected = function(featureIds, options = {}) {
  featureIds = toDenseArray(featureIds);

  // Deselect any features not in the new selection
  this.deselect(this._selectedFeatureIds.values().filter(id => {
    return featureIds.indexOf(id) === -1;
  }), { silent: options.silent });

  // Select any features in the new selection that were not already selected
  this.select(featureIds.filter(id => {
    return !this._selectedFeatureIds.has(id);
  }), { silent: options.silent });

  return this;
};

/**
 * Sets the store's coordinates selection, clearing any prior values.
 * @param {Array<Array<string>>} coordinates
 * @return {Store} this
 */
Store.prototype.setSelectedCoordinates = function(coordinates) {
  this._selectedCoordinates = coordinates;
  this._emitSelectionChange = true;
  return this;
};

/**
 * Clears the current coordinates selection.
 * @param {Object} [options]
 * @return {Store} this
 */
Store.prototype.clearSelectedCoordinates = function() {
  this._selectedCoordinates = [];
  this._emitSelectionChange = true;
  return this;
};

/**
 * Returns the ids of features in the current selection.
 * @return {Array<string>} Selected feature ids.
 */
Store.prototype.getSelectedIds = function() {
  return this._selectedFeatureIds.values();
};

/**
 * Returns features in the current selection.
 * @return {Array<Object>} Selected features.
 */
Store.prototype.getSelected = function() {
  return this._selectedFeatureIds.values().map(id => this.get(id));
};

/**
 * Returns selected coordinates in the currently selected feature.
 * @return {Array<Object>} Selected coordinates.
 */
Store.prototype.getSelectedCoordinates = function() {
  const selected = this._selectedCoordinates.map(coordinate => {
    const feature = this.get(coordinate.feature_id);
    return {
      coordinates: feature.getCoordinate(coordinate.coord_path)
    };
  });
  return selected;
};

/**
 * Indicates whether a feature is selected.
 * @param {string} featureId
 * @return {boolean} `true` if the feature is selected, `false` if not.
 */
Store.prototype.isSelected = function(featureId) {
  return this._selectedFeatureIds.has(featureId);
};

/**
 * Sets a property on the given feature
 * @param {string} featureId
 * @param {string} property property
 * @param {string} property value
*/
Store.prototype.setFeatureProperty = function(featureId, property, value) {
  this.get(featureId).setProperty(property, value);
  this.featureChanged(featureId);
};

function refreshSelectedCoordinates(options) {
  const newSelectedCoordinates = this._selectedCoordinates.filter(point => this._selectedFeatureIds.has(point.feature_id));
  if (this._selectedCoordinates.length !== newSelectedCoordinates.length && !options.silent) {
    this._emitSelectionChange = true;
  }
  this._selectedCoordinates = newSelectedCoordinates;
}

/**
 * Stores the initial config for a map, so that we can set it again after we're done.
*/
Store.prototype.storeMapConfig = function() {
  interactions.forEach((interaction) => {
    const interactionSet = this.ctx.map[interaction];
    if (interactionSet) {
      this._mapInitialConfig[interaction] = this.ctx.map[interaction].isEnabled();
    }
  });
};

/**
 * Restores the initial config for a map, ensuring all is well.
*/
Store.prototype.restoreMapConfig = function() {
  Object.keys(this._mapInitialConfig).forEach(key => {
    const value = this._mapInitialConfig[key];
    if (value) {
      this.ctx.map[key].enable();
    } else {
      this.ctx.map[key].disable();
    }
  });
};

/**
 * Returns the initial state of an interaction setting.
 * @param {string} interaction
 * @return {boolean} `true` if the interaction is enabled, `false` if not.
 * Defaults to `true`. (Todo: include defaults.)
*/
Store.prototype.getInitialConfigValue = function(interaction) {
  if (this._mapInitialConfig[interaction] !== undefined) {
    return this._mapInitialConfig[interaction];
  } else {
    // This needs to be set to whatever the default is for that interaction
    // It seems to be true for all cases currently, so let's send back `true`.
    return true;
  }
};


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/ui.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/ui.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const xtend = __webpack_require__(/*! xtend */ "./node_modules/xtend/immutable.js");
const Constants = __webpack_require__(/*! ./constants */ "./node_modules/mapbox-gl-draw-circle/node_modules/@mapbox/mapbox-gl-draw/src/constants.js");

const classTypes = ['mode', 'feature', 'mouse'];

module.exports = function(ctx) {


  const buttonElements = {};
  let activeButton = null;

  let currentMapClasses = {
    mode: null, // e.g. mode-direct_select
    feature: null, // e.g. feature-vertex
    mouse: null // e.g. mouse-move
  };

  let nextMapClasses = {
    mode: null,
    feature: null,
    mouse: null
  };

  function clearMapClasses() {
    queueMapClasses({mode:null, feature:null, mouse:null});
    updateMapClasses();
  }

  function queueMapClasses(options) {
    nextMapClasses = xtend(nextMapClasses, options);
  }

  function updateMapClasses() {
    if (!ctx.container) return;

    const classesToRemove = [];
    const classesToAdd = [];

    classTypes.forEach((type) => {
      if (nextMapClasses[type] === currentMapClasses[type]) return;

      classesToRemove.push(`${type}-${currentMapClasses[type]}`);
      if (nextMapClasses[type] !== null) {
        classesToAdd.push(`${type}-${nextMapClasses[type]}`);
      }
    });

    if (classesToRemove.length > 0) {
      ctx.container.classList.remove.apply(ctx.container.classList, classesToRemove);
    }

    if (classesToAdd.length > 0) {
      ctx.container.classList.add.apply(ctx.container.classList, classesToAdd);
    }

    currentMapClasses = xtend(currentMapClasses, nextMapClasses);
  }

  function createControlButton(id, options = {}) {
    const button = document.createElement('button');
    button.className = `${Constants.classes.CONTROL_BUTTON} ${options.className}`;
    button.setAttribute('title', options.title);
    options.container.appendChild(button);

    button.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();

      const clickedButton = e.target;
      if (clickedButton === activeButton) {
        deactivateButtons();
        return;
      }

      setActiveButton(id);
      options.onActivate();
    }, true);

    return button;
  }

  function deactivateButtons() {
    if (!activeButton) return;
    activeButton.classList.remove(Constants.classes.ACTIVE_BUTTON);
    activeButton = null;
  }

  function setActiveButton(id) {
    deactivateButtons();

    const button = buttonElements[id];
    if (!button) return;

    if (button && id !== 'trash') {
      button.classList.add(Constants.classes.ACTIVE_BUTTON);
      activeButton = button;
    }
  }

  function addButtons() {
    const controls = ctx.options.controls;
    const controlGroup = document.createElement('div');
    controlGroup.className = `${Constants.classes.CONTROL_GROUP} ${Constants.classes.CONTROL_BASE}`;

    if (!controls) return controlGroup;

    if (controls[Constants.types.LINE]) {
      buttonElements[Constants.types.LINE] = createControlButton(Constants.types.LINE, {
        container: controlGroup,
        className: Constants.classes.CONTROL_BUTTON_LINE,
        title: `LineString tool ${ctx.options.keybindings ? '(l)' : ''}`,
        onActivate: () => ctx.events.changeMode(Constants.modes.DRAW_LINE_STRING)
      });
    }

    if (controls[Constants.types.POLYGON]) {
      buttonElements[Constants.types.POLYGON] = createControlButton(Constants.types.POLYGON, {
        container: controlGroup,
        className: Constants.classes.CONTROL_BUTTON_POLYGON,
        title: `Polygon tool ${ctx.options.keybindings ? '(p)' : ''}`,
        onActivate: () => ctx.events.changeMode(Constants.modes.DRAW_POLYGON)
      });
    }

    if (controls[Constants.types.POINT]) {
      buttonElements[Constants.types.POINT] = createControlButton(Constants.types.POINT, {
        container: controlGroup,
        className: Constants.classes.CONTROL_BUTTON_POINT,
        title: `Marker tool ${ctx.options.keybindings ? '(m)' : ''}`,
        onActivate: () => ctx.events.changeMode(Constants.modes.DRAW_POINT)
      });
    }

    if (controls.trash) {
      buttonElements.trash = createControlButton('trash', {
        container: controlGroup,
        className: Constants.classes.CONTROL_BUTTON_TRASH,
        title: 'Delete',
        onActivate: () => {
          ctx.events.trash();
        }
      });
    }

    if (controls.combine_features) {
      buttonElements.combine_features = createControlButton('combineFeatures', {
        container: controlGroup,
        className: Constants.classes.CONTROL_BUTTON_COMBINE_FEATURES,
        title: 'Combine',
        onActivate: () => {
          ctx.events.combineFeatures();
        }
      });
    }

    if (controls.uncombine_features) {
      buttonElements.uncombine_features = createControlButton('uncombineFeatures', {
        container: controlGroup,
        className: Constants.classes.CONTROL_BUTTON_UNCOMBINE_FEATURES,
        title: 'Uncombine',
        onActivate: () => {
          ctx.events.uncombineFeatures();
        }
      });
    }

    return controlGroup;
  }

  function removeButtons() {
    Object.keys(buttonElements).forEach(buttonId => {
      const button = buttonElements[buttonId];
      if (button.parentNode) {
        button.parentNode.removeChild(button);
      }
      delete buttonElements[buttonId];
    });
  }

  return {
    setActiveButton,
    queueMapClasses,
    updateMapClasses,
    clearMapClasses,
    addButtons,
    removeButtons
  };
};


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@turf/circle/dist/es/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@turf/circle/dist/es/index.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _turf_destination__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/destination */ "./node_modules/mapbox-gl-draw-circle/node_modules/@turf/destination/dist/es/index.js");
/* harmony import */ var _turf_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @turf/helpers */ "./node_modules/mapbox-gl-draw-circle/node_modules/@turf/helpers/dist/es/index.js");


/**
 * Takes a {@link Point} and calculates the circle polygon given a radius in degrees, radians, miles, or kilometers; and steps for precision.
 *
 * @name circle
 * @param {Feature<Point>|number[]} center center point
 * @param {number} radius radius of the circle
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.steps=64] number of steps
 * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians
 * @param {Object} [options.properties={}] properties
 * @returns {Feature<Polygon>} circle polygon
 * @example
 * var center = [-75.343, 39.984];
 * var radius = 5;
 * var options = {steps: 10, units: 'kilometers', properties: {foo: 'bar'}};
 * var circle = turf.circle(center, radius, options);
 *
 * //addToMap
 * var addToMap = [turf.point(center), circle]
 */
function circle(center, radius, options) {
    if (options === void 0) { options = {}; }
    // default params
    var steps = options.steps || 64;
    var properties = options.properties
        ? options.properties
        : !Array.isArray(center) && center.type === "Feature" && center.properties
            ? center.properties
            : {};
    // main
    var coordinates = [];
    for (var i = 0; i < steps; i++) {
        coordinates.push(Object(_turf_destination__WEBPACK_IMPORTED_MODULE_0__["default"])(center, radius, (i * -360) / steps, options).geometry
            .coordinates);
    }
    coordinates.push(coordinates[0]);
    return Object(_turf_helpers__WEBPACK_IMPORTED_MODULE_1__["polygon"])([coordinates], properties);
}
/* harmony default export */ __webpack_exports__["default"] = (circle);


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@turf/destination/dist/es/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@turf/destination/dist/es/index.js ***!
  \********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return destination; });
/* harmony import */ var _turf_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/helpers */ "./node_modules/mapbox-gl-draw-circle/node_modules/@turf/helpers/dist/es/index.js");
/* harmony import */ var _turf_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @turf/invariant */ "./node_modules/mapbox-gl-draw-circle/node_modules/@turf/invariant/dist/es/index.js");
// http://en.wikipedia.org/wiki/Haversine_formula
// http://www.movable-type.co.uk/scripts/latlong.html


/**
 * Takes a {@link Point} and calculates the location of a destination point given a distance in
 * degrees, radians, miles, or kilometers; and bearing in degrees.
 * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.
 *
 * @name destination
 * @param {Coord} origin starting point
 * @param {number} distance distance from the origin point
 * @param {number} bearing ranging from -180 to 180
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians
 * @param {Object} [options.properties={}] Translate properties to Point
 * @returns {Feature<Point>} destination point
 * @example
 * var point = turf.point([-75.343, 39.984]);
 * var distance = 50;
 * var bearing = 90;
 * var options = {units: 'miles'};
 *
 * var destination = turf.destination(point, distance, bearing, options);
 *
 * //addToMap
 * var addToMap = [point, destination]
 * destination.properties['marker-color'] = '#f00';
 * point.properties['marker-color'] = '#0f0';
 */
function destination(origin, distance, bearing, options) {
    if (options === void 0) { options = {}; }
    // Handle input
    var coordinates1 = Object(_turf_invariant__WEBPACK_IMPORTED_MODULE_1__["getCoord"])(origin);
    var longitude1 = Object(_turf_helpers__WEBPACK_IMPORTED_MODULE_0__["degreesToRadians"])(coordinates1[0]);
    var latitude1 = Object(_turf_helpers__WEBPACK_IMPORTED_MODULE_0__["degreesToRadians"])(coordinates1[1]);
    var bearingRad = Object(_turf_helpers__WEBPACK_IMPORTED_MODULE_0__["degreesToRadians"])(bearing);
    var radians = Object(_turf_helpers__WEBPACK_IMPORTED_MODULE_0__["lengthToRadians"])(distance, options.units);
    // Main
    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +
        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));
    var longitude2 = longitude1 +
        Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));
    var lng = Object(_turf_helpers__WEBPACK_IMPORTED_MODULE_0__["radiansToDegrees"])(longitude2);
    var lat = Object(_turf_helpers__WEBPACK_IMPORTED_MODULE_0__["radiansToDegrees"])(latitude2);
    return Object(_turf_helpers__WEBPACK_IMPORTED_MODULE_0__["point"])([lng, lat], options.properties);
}


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@turf/distance/dist/es/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@turf/distance/dist/es/index.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _turf_invariant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/invariant */ "./node_modules/mapbox-gl-draw-circle/node_modules/@turf/invariant/dist/es/index.js");
/* harmony import */ var _turf_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @turf/helpers */ "./node_modules/mapbox-gl-draw-circle/node_modules/@turf/helpers/dist/es/index.js");


//http://en.wikipedia.org/wiki/Haversine_formula
//http://www.movable-type.co.uk/scripts/latlong.html
/**
 * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.
 * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.
 *
 * @name distance
 * @param {Coord} from origin point
 * @param {Coord} to destination point
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers
 * @returns {number} distance between the two points
 * @example
 * var from = turf.point([-75.343, 39.984]);
 * var to = turf.point([-75.534, 39.123]);
 * var options = {units: 'miles'};
 *
 * var distance = turf.distance(from, to, options);
 *
 * //addToMap
 * var addToMap = [from, to];
 * from.properties.distance = distance;
 * to.properties.distance = distance;
 */
function distance(from, to, options) {
    if (options === void 0) { options = {}; }
    var coordinates1 = Object(_turf_invariant__WEBPACK_IMPORTED_MODULE_0__["getCoord"])(from);
    var coordinates2 = Object(_turf_invariant__WEBPACK_IMPORTED_MODULE_0__["getCoord"])(to);
    var dLat = Object(_turf_helpers__WEBPACK_IMPORTED_MODULE_1__["degreesToRadians"])(coordinates2[1] - coordinates1[1]);
    var dLon = Object(_turf_helpers__WEBPACK_IMPORTED_MODULE_1__["degreesToRadians"])(coordinates2[0] - coordinates1[0]);
    var lat1 = Object(_turf_helpers__WEBPACK_IMPORTED_MODULE_1__["degreesToRadians"])(coordinates1[1]);
    var lat2 = Object(_turf_helpers__WEBPACK_IMPORTED_MODULE_1__["degreesToRadians"])(coordinates2[1]);
    var a = Math.pow(Math.sin(dLat / 2), 2) +
        Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
    return Object(_turf_helpers__WEBPACK_IMPORTED_MODULE_1__["radiansToLength"])(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);
}
/* harmony default export */ __webpack_exports__["default"] = (distance);


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@turf/helpers/dist/es/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@turf/helpers/dist/es/index.js ***!
  \****************************************************************************************/
/*! exports provided: earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "earthRadius", function() { return earthRadius; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "factors", function() { return factors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unitsFactors", function() { return unitsFactors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areaFactors", function() { return areaFactors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "feature", function() { return feature; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geometry", function() { return geometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "point", function() { return point; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "points", function() { return points; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polygon", function() { return polygon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polygons", function() { return polygons; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineString", function() { return lineString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineStrings", function() { return lineStrings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "featureCollection", function() { return featureCollection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiLineString", function() { return multiLineString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiPoint", function() { return multiPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiPolygon", function() { return multiPolygon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geometryCollection", function() { return geometryCollection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "radiansToLength", function() { return radiansToLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lengthToRadians", function() { return lengthToRadians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lengthToDegrees", function() { return lengthToDegrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bearingToAzimuth", function() { return bearingToAzimuth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "radiansToDegrees", function() { return radiansToDegrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degreesToRadians", function() { return degreesToRadians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertLength", function() { return convertLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertArea", function() { return convertArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNumber", function() { return isNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObject", function() { return isObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateBBox", function() { return validateBBox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateId", function() { return validateId; });
/**
 * @module helpers
 */
/**
 * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
 *
 * @memberof helpers
 * @type {number}
 */
var earthRadius = 6371008.8;
/**
 * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
 *
 * @memberof helpers
 * @type {Object}
 */
var factors = {
    centimeters: earthRadius * 100,
    centimetres: earthRadius * 100,
    degrees: earthRadius / 111325,
    feet: earthRadius * 3.28084,
    inches: earthRadius * 39.37,
    kilometers: earthRadius / 1000,
    kilometres: earthRadius / 1000,
    meters: earthRadius,
    metres: earthRadius,
    miles: earthRadius / 1609.344,
    millimeters: earthRadius * 1000,
    millimetres: earthRadius * 1000,
    nauticalmiles: earthRadius / 1852,
    radians: 1,
    yards: earthRadius / 1.0936,
};
/**
 * Units of measurement factors based on 1 meter.
 *
 * @memberof helpers
 * @type {Object}
 */
var unitsFactors = {
    centimeters: 100,
    centimetres: 100,
    degrees: 1 / 111325,
    feet: 3.28084,
    inches: 39.37,
    kilometers: 1 / 1000,
    kilometres: 1 / 1000,
    meters: 1,
    metres: 1,
    miles: 1 / 1609.344,
    millimeters: 1000,
    millimetres: 1000,
    nauticalmiles: 1 / 1852,
    radians: 1 / earthRadius,
    yards: 1 / 1.0936,
};
/**
 * Area of measurement factors based on 1 square meter.
 *
 * @memberof helpers
 * @type {Object}
 */
var areaFactors = {
    acres: 0.000247105,
    centimeters: 10000,
    centimetres: 10000,
    feet: 10.763910417,
    hectares: 0.0001,
    inches: 1550.003100006,
    kilometers: 0.000001,
    kilometres: 0.000001,
    meters: 1,
    metres: 1,
    miles: 3.86e-7,
    millimeters: 1000000,
    millimetres: 1000000,
    yards: 1.195990046,
};
/**
 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
 *
 * @name feature
 * @param {Geometry} geometry input geometry
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature} a GeoJSON Feature
 * @example
 * var geometry = {
 *   "type": "Point",
 *   "coordinates": [110, 50]
 * };
 *
 * var feature = turf.feature(geometry);
 *
 * //=feature
 */
function feature(geom, properties, options) {
    if (options === void 0) { options = {}; }
    var feat = { type: "Feature" };
    if (options.id === 0 || options.id) {
        feat.id = options.id;
    }
    if (options.bbox) {
        feat.bbox = options.bbox;
    }
    feat.properties = properties || {};
    feat.geometry = geom;
    return feat;
}
/**
 * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
 * For GeometryCollection type use `helpers.geometryCollection`
 *
 * @name geometry
 * @param {string} type Geometry Type
 * @param {Array<any>} coordinates Coordinates
 * @param {Object} [options={}] Optional Parameters
 * @returns {Geometry} a GeoJSON Geometry
 * @example
 * var type = "Point";
 * var coordinates = [110, 50];
 * var geometry = turf.geometry(type, coordinates);
 * // => geometry
 */
function geometry(type, coordinates, _options) {
    if (_options === void 0) { _options = {}; }
    switch (type) {
        case "Point":
            return point(coordinates).geometry;
        case "LineString":
            return lineString(coordinates).geometry;
        case "Polygon":
            return polygon(coordinates).geometry;
        case "MultiPoint":
            return multiPoint(coordinates).geometry;
        case "MultiLineString":
            return multiLineString(coordinates).geometry;
        case "MultiPolygon":
            return multiPolygon(coordinates).geometry;
        default:
            throw new Error(type + " is invalid");
    }
}
/**
 * Creates a {@link Point} {@link Feature} from a Position.
 *
 * @name point
 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Point>} a Point feature
 * @example
 * var point = turf.point([-75.343, 39.984]);
 *
 * //=point
 */
function point(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    if (!coordinates) {
        throw new Error("coordinates is required");
    }
    if (!Array.isArray(coordinates)) {
        throw new Error("coordinates must be an Array");
    }
    if (coordinates.length < 2) {
        throw new Error("coordinates must be at least 2 numbers long");
    }
    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
        throw new Error("coordinates must contain numbers");
    }
    var geom = {
        type: "Point",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
/**
 * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.
 *
 * @name points
 * @param {Array<Array<number>>} coordinates an array of Points
 * @param {Object} [properties={}] Translate these properties to each Feature
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
 * associated with the FeatureCollection
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<Point>} Point Feature
 * @example
 * var points = turf.points([
 *   [-75, 39],
 *   [-80, 45],
 *   [-78, 50]
 * ]);
 *
 * //=points
 */
function points(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    return featureCollection(coordinates.map(function (coords) {
        return point(coords, properties);
    }), options);
}
/**
 * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.
 *
 * @name polygon
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Polygon>} Polygon Feature
 * @example
 * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });
 *
 * //=polygon
 */
function polygon(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
        var ring = coordinates_1[_i];
        if (ring.length < 4) {
            throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
        }
        for (var j = 0; j < ring[ring.length - 1].length; j++) {
            // Check if first point of Polygon contains two numbers
            if (ring[ring.length - 1][j] !== ring[0][j]) {
                throw new Error("First and last Position are not equivalent.");
            }
        }
    }
    var geom = {
        type: "Polygon",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
/**
 * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.
 *
 * @name polygons
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection
 * @example
 * var polygons = turf.polygons([
 *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],
 *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],
 * ]);
 *
 * //=polygons
 */
function polygons(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    return featureCollection(coordinates.map(function (coords) {
        return polygon(coords, properties);
    }), options);
}
/**
 * Creates a {@link LineString} {@link Feature} from an Array of Positions.
 *
 * @name lineString
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<LineString>} LineString Feature
 * @example
 * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});
 * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});
 *
 * //=linestring1
 * //=linestring2
 */
function lineString(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    if (coordinates.length < 2) {
        throw new Error("coordinates must be an array of two or more positions");
    }
    var geom = {
        type: "LineString",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
/**
 * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.
 *
 * @name lineStrings
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
 * associated with the FeatureCollection
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<LineString>} LineString FeatureCollection
 * @example
 * var linestrings = turf.lineStrings([
 *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],
 *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]
 * ]);
 *
 * //=linestrings
 */
function lineStrings(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    return featureCollection(coordinates.map(function (coords) {
        return lineString(coords, properties);
    }), options);
}
/**
 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
 *
 * @name featureCollection
 * @param {Feature[]} features input features
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {FeatureCollection} FeatureCollection of Features
 * @example
 * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});
 * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});
 * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});
 *
 * var collection = turf.featureCollection([
 *   locationA,
 *   locationB,
 *   locationC
 * ]);
 *
 * //=collection
 */
function featureCollection(features, options) {
    if (options === void 0) { options = {}; }
    var fc = { type: "FeatureCollection" };
    if (options.id) {
        fc.id = options.id;
    }
    if (options.bbox) {
        fc.bbox = options.bbox;
    }
    fc.features = features;
    return fc;
}
/**
 * Creates a {@link Feature<MultiLineString>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiLineString
 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiLineString>} a MultiLineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
 *
 * //=multiLine
 */
function multiLineString(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "MultiLineString",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
/**
 * Creates a {@link Feature<MultiPoint>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPoint
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiPoint>} a MultiPoint feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
 *
 * //=multiPt
 */
function multiPoint(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "MultiPoint",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
/**
 * Creates a {@link Feature<MultiPolygon>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPolygon
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiPolygon>} a multipolygon feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
 *
 * //=multiPoly
 *
 */
function multiPolygon(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "MultiPolygon",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
/**
 * Creates a {@link Feature<GeometryCollection>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name geometryCollection
 * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
 * @example
 * var pt = turf.geometry("Point", [100, 0]);
 * var line = turf.geometry("LineString", [[101, 0], [102, 1]]);
 * var collection = turf.geometryCollection([pt, line]);
 *
 * // => collection
 */
function geometryCollection(geometries, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "GeometryCollection",
        geometries: geometries,
    };
    return feature(geom, properties, options);
}
/**
 * Round number to precision
 *
 * @param {number} num Number
 * @param {number} [precision=0] Precision
 * @returns {number} rounded number
 * @example
 * turf.round(120.4321)
 * //=120
 *
 * turf.round(120.4321, 2)
 * //=120.43
 */
function round(num, precision) {
    if (precision === void 0) { precision = 0; }
    if (precision && !(precision >= 0)) {
        throw new Error("precision must be a positive number");
    }
    var multiplier = Math.pow(10, precision || 0);
    return Math.round(num * multiplier) / multiplier;
}
/**
 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name radiansToLength
 * @param {number} radians in radians across the sphere
 * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} distance
 */
function radiansToLength(radians, units) {
    if (units === void 0) { units = "kilometers"; }
    var factor = factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return radians * factor;
}
/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name lengthToRadians
 * @param {number} distance in real units
 * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} radians
 */
function lengthToRadians(distance, units) {
    if (units === void 0) { units = "kilometers"; }
    var factor = factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return distance / factor;
}
/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
 *
 * @name lengthToDegrees
 * @param {number} distance in real units
 * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} degrees
 */
function lengthToDegrees(distance, units) {
    return radiansToDegrees(lengthToRadians(distance, units));
}
/**
 * Converts any bearing angle from the north line direction (positive clockwise)
 * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
 *
 * @name bearingToAzimuth
 * @param {number} bearing angle, between -180 and +180 degrees
 * @returns {number} angle between 0 and 360 degrees
 */
function bearingToAzimuth(bearing) {
    var angle = bearing % 360;
    if (angle < 0) {
        angle += 360;
    }
    return angle;
}
/**
 * Converts an angle in radians to degrees
 *
 * @name radiansToDegrees
 * @param {number} radians angle in radians
 * @returns {number} degrees between 0 and 360 degrees
 */
function radiansToDegrees(radians) {
    var degrees = radians % (2 * Math.PI);
    return (degrees * 180) / Math.PI;
}
/**
 * Converts an angle in degrees to radians
 *
 * @name degreesToRadians
 * @param {number} degrees angle between 0 and 360 degrees
 * @returns {number} angle in radians
 */
function degreesToRadians(degrees) {
    var radians = degrees % 360;
    return (radians * Math.PI) / 180;
}
/**
 * Converts a length to the requested unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @param {number} length to be converted
 * @param {Units} [originalUnit="kilometers"] of the length
 * @param {Units} [finalUnit="kilometers"] returned unit
 * @returns {number} the converted length
 */
function convertLength(length, originalUnit, finalUnit) {
    if (originalUnit === void 0) { originalUnit = "kilometers"; }
    if (finalUnit === void 0) { finalUnit = "kilometers"; }
    if (!(length >= 0)) {
        throw new Error("length must be a positive number");
    }
    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);
}
/**
 * Converts a area to the requested unit.
 * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares
 * @param {number} area to be converted
 * @param {Units} [originalUnit="meters"] of the distance
 * @param {Units} [finalUnit="kilometers"] returned unit
 * @returns {number} the converted area
 */
function convertArea(area, originalUnit, finalUnit) {
    if (originalUnit === void 0) { originalUnit = "meters"; }
    if (finalUnit === void 0) { finalUnit = "kilometers"; }
    if (!(area >= 0)) {
        throw new Error("area must be a positive number");
    }
    var startFactor = areaFactors[originalUnit];
    if (!startFactor) {
        throw new Error("invalid original units");
    }
    var finalFactor = areaFactors[finalUnit];
    if (!finalFactor) {
        throw new Error("invalid final units");
    }
    return (area / startFactor) * finalFactor;
}
/**
 * isNumber
 *
 * @param {*} num Number to validate
 * @returns {boolean} true/false
 * @example
 * turf.isNumber(123)
 * //=true
 * turf.isNumber('foo')
 * //=false
 */
function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num);
}
/**
 * isObject
 *
 * @param {*} input variable to validate
 * @returns {boolean} true/false
 * @example
 * turf.isObject({elevation: 10})
 * //=true
 * turf.isObject('foo')
 * //=false
 */
function isObject(input) {
    return !!input && input.constructor === Object;
}
/**
 * Validate BBox
 *
 * @private
 * @param {Array<number>} bbox BBox to validate
 * @returns {void}
 * @throws Error if BBox is not valid
 * @example
 * validateBBox([-180, -40, 110, 50])
 * //=OK
 * validateBBox([-180, -40])
 * //=Error
 * validateBBox('Foo')
 * //=Error
 * validateBBox(5)
 * //=Error
 * validateBBox(null)
 * //=Error
 * validateBBox(undefined)
 * //=Error
 */
function validateBBox(bbox) {
    if (!bbox) {
        throw new Error("bbox is required");
    }
    if (!Array.isArray(bbox)) {
        throw new Error("bbox must be an Array");
    }
    if (bbox.length !== 4 && bbox.length !== 6) {
        throw new Error("bbox must be an Array of 4 or 6 numbers");
    }
    bbox.forEach(function (num) {
        if (!isNumber(num)) {
            throw new Error("bbox must only contain numbers");
        }
    });
}
/**
 * Validate Id
 *
 * @private
 * @param {string|number} id Id to validate
 * @returns {void}
 * @throws Error if Id is not valid
 * @example
 * validateId([-180, -40, 110, 50])
 * //=Error
 * validateId([-180, -40])
 * //=Error
 * validateId('Foo')
 * //=OK
 * validateId(5)
 * //=OK
 * validateId(null)
 * //=Error
 * validateId(undefined)
 * //=Error
 */
function validateId(id) {
    if (!id) {
        throw new Error("id is required");
    }
    if (["string", "number"].indexOf(typeof id) === -1) {
        throw new Error("id must be a number or a string");
    }
}


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-circle/node_modules/@turf/invariant/dist/es/index.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-circle/node_modules/@turf/invariant/dist/es/index.js ***!
  \******************************************************************************************/
/*! exports provided: getCoord, getCoords, containsNumber, geojsonType, featureOf, collectionOf, getGeom, getType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCoord", function() { return getCoord; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCoords", function() { return getCoords; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "containsNumber", function() { return containsNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geojsonType", function() { return geojsonType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "featureOf", function() { return featureOf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "collectionOf", function() { return collectionOf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGeom", function() { return getGeom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getType", function() { return getType; });
/* harmony import */ var _turf_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/helpers */ "./node_modules/mapbox-gl-draw-circle/node_modules/@turf/helpers/dist/es/index.js");

/**
 * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
 *
 * @name getCoord
 * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers
 * @returns {Array<number>} coordinates
 * @example
 * var pt = turf.point([10, 10]);
 *
 * var coord = turf.getCoord(pt);
 * //= [10, 10]
 */
function getCoord(coord) {
    if (!coord) {
        throw new Error("coord is required");
    }
    if (!Array.isArray(coord)) {
        if (coord.type === "Feature" &&
            coord.geometry !== null &&
            coord.geometry.type === "Point") {
            return coord.geometry.coordinates;
        }
        if (coord.type === "Point") {
            return coord.coordinates;
        }
    }
    if (Array.isArray(coord) &&
        coord.length >= 2 &&
        !Array.isArray(coord[0]) &&
        !Array.isArray(coord[1])) {
        return coord;
    }
    throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
/**
 * Unwrap coordinates from a Feature, Geometry Object or an Array
 *
 * @name getCoords
 * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array
 * @returns {Array<any>} coordinates
 * @example
 * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);
 *
 * var coords = turf.getCoords(poly);
 * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]
 */
function getCoords(coords) {
    if (Array.isArray(coords)) {
        return coords;
    }
    // Feature
    if (coords.type === "Feature") {
        if (coords.geometry !== null) {
            return coords.geometry.coordinates;
        }
    }
    else {
        // Geometry
        if (coords.coordinates) {
            return coords.coordinates;
        }
    }
    throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
/**
 * Checks if coordinates contains a number
 *
 * @name containsNumber
 * @param {Array<any>} coordinates GeoJSON Coordinates
 * @returns {boolean} true if Array contains a number
 */
function containsNumber(coordinates) {
    if (coordinates.length > 1 &&
        Object(_turf_helpers__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(coordinates[0]) &&
        Object(_turf_helpers__WEBPACK_IMPORTED_MODULE_0__["isNumber"])(coordinates[1])) {
        return true;
    }
    if (Array.isArray(coordinates[0]) && coordinates[0].length) {
        return containsNumber(coordinates[0]);
    }
    throw new Error("coordinates must only contain numbers");
}
/**
 * Enforce expectations about types of GeoJSON objects for Turf.
 *
 * @name geojsonType
 * @param {GeoJSON} value any GeoJSON object
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function geojsonType(value, type, name) {
    if (!type || !name) {
        throw new Error("type and name required");
    }
    if (!value || value.type !== type) {
        throw new Error("Invalid input to " +
            name +
            ": must be a " +
            type +
            ", given " +
            value.type);
    }
}
/**
 * Enforce expectations about types of {@link Feature} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name featureOf
 * @param {Feature} feature a feature with an expected geometry type
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} error if value is not the expected type.
 */
function featureOf(feature, type, name) {
    if (!feature) {
        throw new Error("No feature passed");
    }
    if (!name) {
        throw new Error(".featureOf() requires a name");
    }
    if (!feature || feature.type !== "Feature" || !feature.geometry) {
        throw new Error("Invalid input to " + name + ", Feature with geometry required");
    }
    if (!feature.geometry || feature.geometry.type !== type) {
        throw new Error("Invalid input to " +
            name +
            ": must be a " +
            type +
            ", given " +
            feature.geometry.type);
    }
}
/**
 * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name collectionOf
 * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function collectionOf(featureCollection, type, name) {
    if (!featureCollection) {
        throw new Error("No featureCollection passed");
    }
    if (!name) {
        throw new Error(".collectionOf() requires a name");
    }
    if (!featureCollection || featureCollection.type !== "FeatureCollection") {
        throw new Error("Invalid input to " + name + ", FeatureCollection required");
    }
    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {
        var feature = _a[_i];
        if (!feature || feature.type !== "Feature" || !feature.geometry) {
            throw new Error("Invalid input to " + name + ", Feature with geometry required");
        }
        if (!feature.geometry || feature.geometry.type !== type) {
            throw new Error("Invalid input to " +
                name +
                ": must be a " +
                type +
                ", given " +
                feature.geometry.type);
        }
    }
}
/**
 * Get Geometry from Feature or Geometry Object
 *
 * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object
 * @returns {Geometry|null} GeoJSON Geometry Object
 * @throws {Error} if geojson is not a Feature or Geometry Object
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getGeom(point)
 * //={"type": "Point", "coordinates": [110, 40]}
 */
function getGeom(geojson) {
    if (geojson.type === "Feature") {
        return geojson.geometry;
    }
    return geojson;
}
/**
 * Get GeoJSON object's type, Geometry type is prioritize.
 *
 * @param {GeoJSON} geojson GeoJSON object
 * @param {string} [name="geojson"] name of the variable to display in error message (unused)
 * @returns {string} GeoJSON type
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getType(point)
 * //="Point"
 */
function getType(geojson, _name) {
    if (geojson.type === "FeatureCollection") {
        return "FeatureCollection";
    }
    if (geojson.type === "GeometryCollection") {
        return "GeometryCollection";
    }
    if (geojson.type === "Feature" && geojson.geometry !== null) {
        return geojson.geometry.type;
    }
    return geojson.type;
}


/***/ }),

/***/ "./node_modules/mapbox-gl-draw-rectangle-mode/dist/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/mapbox-gl-draw-rectangle-mode/dist/index.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var doubleClickZoom = {
  enable: function enable(ctx) {
    setTimeout(function () {
      // First check we've got a map and some context.
      if (!ctx.map || !ctx.map.doubleClickZoom || !ctx._ctx || !ctx._ctx.store || !ctx._ctx.store.getInitialConfigValue) return;
      // Now check initial state wasn't false (we leave it disabled if so)
      if (!ctx._ctx.store.getInitialConfigValue("doubleClickZoom")) return;
      ctx.map.doubleClickZoom.enable();
    }, 0);
  },
  disable: function disable(ctx) {
    setTimeout(function () {
      if (!ctx.map || !ctx.map.doubleClickZoom) return;
      // Always disable here, as it's necessary in some cases.
      ctx.map.doubleClickZoom.disable();
    }, 0);
  }
};

var DrawRectangle = {
  // When the mode starts this function will be called.
  onSetup: function onSetup(opts) {
    var rectangle = this.newFeature({
      type: "Feature",
      properties: {},
      geometry: {
        type: "Polygon",
        coordinates: [[]]
      }
    });
    this.addFeature(rectangle);
    this.clearSelectedFeatures();
    doubleClickZoom.disable(this);
    this.updateUIClasses({ mouse: "add" });
    this.setActionableState({
      trash: true
    });
    return {
      rectangle: rectangle
    };
  },
  // support mobile taps
  onTap: function onTap(state, e) {
    // emulate 'move mouse' to update feature coords
    if (state.startPoint) this.onMouseMove(state, e);
    // emulate onClick
    this.onClick(state, e);
  },
  // Whenever a user clicks on the map, Draw will call `onClick`
  onClick: function onClick(state, e) {
    // if state.startPoint exist, means its second click
    //change to  simple_select mode
    if (state.startPoint && state.startPoint[0] !== e.lngLat.lng && state.startPoint[1] !== e.lngLat.lat) {
      this.updateUIClasses({ mouse: "pointer" });
      state.endPoint = [e.lngLat.lng, e.lngLat.lat];
      this.changeMode("simple_select", { featuresId: state.rectangle.id });
    }
    // on first click, save clicked point coords as starting for  rectangle
    var startPoint = [e.lngLat.lng, e.lngLat.lat];
    state.startPoint = startPoint;
  },
  onMouseMove: function onMouseMove(state, e) {
    // if startPoint, update the feature coordinates, using the bounding box concept
    // we are simply using the startingPoint coordinates and the current Mouse Position
    // coordinates to calculate the bounding box on the fly, which will be our rectangle
    if (state.startPoint) {
      state.rectangle.updateCoordinate("0.0", state.startPoint[0], state.startPoint[1]); //minX, minY - the starting point
      state.rectangle.updateCoordinate("0.1", e.lngLat.lng, state.startPoint[1]); // maxX, minY
      state.rectangle.updateCoordinate("0.2", e.lngLat.lng, e.lngLat.lat); // maxX, maxY
      state.rectangle.updateCoordinate("0.3", state.startPoint[0], e.lngLat.lat); // minX,maxY
      state.rectangle.updateCoordinate("0.4", state.startPoint[0], state.startPoint[1]); //minX,minY - ending point (equals to starting point)
    }
  },
  // Whenever a user clicks on a key while focused on the map, it will be sent here
  onKeyUp: function onKeyUp(state, e) {
    if (e.keyCode === 27) return this.changeMode("simple_select");
  },
  onStop: function onStop(state) {
    doubleClickZoom.enable(this);
    this.updateUIClasses({ mouse: "none" });
    this.activateUIButton();

    // check to see if we've deleted this feature
    if (this.getFeature(state.rectangle.id) === undefined) return;

    //remove last added coordinate
    state.rectangle.removeCoordinate("0.4");
    if (state.rectangle.isValid()) {
      this.map.fire("draw.create", {
        features: [state.rectangle.toGeoJSON()]
      });
    } else {
      this.deleteFeature([state.rectangle.id], { silent: true });
      this.changeMode("simple_select", {}, { silent: true });
    }
  },
  toDisplayFeatures: function toDisplayFeatures(state, geojson, display) {
    var isActivePolygon = geojson.properties.id === state.rectangle.id;
    geojson.properties.active = isActivePolygon ? "true" : "false";
    if (!isActivePolygon) return display(geojson);

    // Only render the rectangular polygon if it has the starting point
    if (!state.startPoint) return;
    return display(geojson);
  },
  onTrash: function onTrash(state) {
    this.deleteFeature([state.rectangle.id], { silent: true });
    this.changeMode("simple_select");
  }
};

exports.default = DrawRectangle;

/***/ }),

/***/ "./node_modules/traverse/index.js":
/*!****************************************!*\
  !*** ./node_modules/traverse/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var traverse = module.exports = function (obj) {
    return new Traverse(obj);
};

function Traverse (obj) {
    this.value = obj;
}

Traverse.prototype.get = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            node = undefined;
            break;
        }
        node = node[key];
    }
    return node;
};

Traverse.prototype.has = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            return false;
        }
        node = node[key];
    }
    return true;
};

Traverse.prototype.set = function (ps, value) {
    var node = this.value;
    for (var i = 0; i < ps.length - 1; i ++) {
        var key = ps[i];
        if (!hasOwnProperty.call(node, key)) node[key] = {};
        node = node[key];
    }
    node[ps[i]] = value;
    return value;
};

Traverse.prototype.map = function (cb) {
    return walk(this.value, cb, true);
};

Traverse.prototype.forEach = function (cb) {
    this.value = walk(this.value, cb, false);
    return this.value;
};

Traverse.prototype.reduce = function (cb, init) {
    var skip = arguments.length === 1;
    var acc = skip ? this.value : init;
    this.forEach(function (x) {
        if (!this.isRoot || !skip) {
            acc = cb.call(this, acc, x);
        }
    });
    return acc;
};

Traverse.prototype.paths = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.path); 
    });
    return acc;
};

Traverse.prototype.nodes = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.node);
    });
    return acc;
};

Traverse.prototype.clone = function () {
    var parents = [], nodes = [];
    
    return (function clone (src) {
        for (var i = 0; i < parents.length; i++) {
            if (parents[i] === src) {
                return nodes[i];
            }
        }
        
        if (typeof src === 'object' && src !== null) {
            var dst = copy(src);
            
            parents.push(src);
            nodes.push(dst);
            
            forEach(objectKeys(src), function (key) {
                dst[key] = clone(src[key]);
            });
            
            parents.pop();
            nodes.pop();
            return dst;
        }
        else {
            return src;
        }
    })(this.value);
};

function walk (root, cb, immutable) {
    var path = [];
    var parents = [];
    var alive = true;
    
    return (function walker (node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        
        var keepGoing = true;
        
        var state = {
            node : node,
            node_ : node_,
            path : [].concat(path),
            parent : parents[parents.length - 1],
            parents : parents,
            key : path.slice(-1)[0],
            isRoot : path.length === 0,
            level : path.length,
            circular : null,
            update : function (x, stopHere) {
                if (!state.isRoot) {
                    state.parent.node[state.key] = x;
                }
                state.node = x;
                if (stopHere) keepGoing = false;
            },
            'delete' : function (stopHere) {
                delete state.parent.node[state.key];
                if (stopHere) keepGoing = false;
            },
            remove : function (stopHere) {
                if (isArray(state.parent.node)) {
                    state.parent.node.splice(state.key, 1);
                }
                else {
                    delete state.parent.node[state.key];
                }
                if (stopHere) keepGoing = false;
            },
            keys : null,
            before : function (f) { modifiers.before = f },
            after : function (f) { modifiers.after = f },
            pre : function (f) { modifiers.pre = f },
            post : function (f) { modifiers.post = f },
            stop : function () { alive = false },
            block : function () { keepGoing = false }
        };
        
        if (!alive) return state;
        
        function updateState() {
            if (typeof state.node === 'object' && state.node !== null) {
                if (!state.keys || state.node_ !== state.node) {
                    state.keys = objectKeys(state.node)
                }
                
                state.isLeaf = state.keys.length == 0;
                
                for (var i = 0; i < parents.length; i++) {
                    if (parents[i].node_ === node_) {
                        state.circular = parents[i];
                        break;
                    }
                }
            }
            else {
                state.isLeaf = true;
                state.keys = null;
            }
            
            state.notLeaf = !state.isLeaf;
            state.notRoot = !state.isRoot;
        }
        
        updateState();
        
        // use return values to update if defined
        var ret = cb.call(state, state.node);
        if (ret !== undefined && state.update) state.update(ret);
        
        if (modifiers.before) modifiers.before.call(state, state.node);
        
        if (!keepGoing) return state;
        
        if (typeof state.node == 'object'
        && state.node !== null && !state.circular) {
            parents.push(state);
            
            updateState();
            
            forEach(state.keys, function (key, i) {
                path.push(key);
                
                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);
                
                var child = walker(state.node[key]);
                if (immutable && hasOwnProperty.call(state.node, key)) {
                    state.node[key] = child.node;
                }
                
                child.isLast = i == state.keys.length - 1;
                child.isFirst = i == 0;
                
                if (modifiers.post) modifiers.post.call(state, child);
                
                path.pop();
            });
            parents.pop();
        }
        
        if (modifiers.after) modifiers.after.call(state, state.node);
        
        return state;
    })(root).node;
}

function copy (src) {
    if (typeof src === 'object' && src !== null) {
        var dst;
        
        if (isArray(src)) {
            dst = [];
        }
        else if (isDate(src)) {
            dst = new Date(src.getTime ? src.getTime() : src);
        }
        else if (isRegExp(src)) {
            dst = new RegExp(src);
        }
        else if (isError(src)) {
            dst = { message: src.message };
        }
        else if (isBoolean(src)) {
            dst = new Boolean(src);
        }
        else if (isNumber(src)) {
            dst = new Number(src);
        }
        else if (isString(src)) {
            dst = new String(src);
        }
        else if (Object.create && Object.getPrototypeOf) {
            dst = Object.create(Object.getPrototypeOf(src));
        }
        else if (src.constructor === Object) {
            dst = {};
        }
        else {
            var proto =
                (src.constructor && src.constructor.prototype)
                || src.__proto__
                || {}
            ;
            var T = function () {};
            T.prototype = proto;
            dst = new T;
        }
        
        forEach(objectKeys(src), function (key) {
            dst[key] = src[key];
        });
        return dst;
    }
    else return src;
}

var objectKeys = Object.keys || function keys (obj) {
    var res = [];
    for (var key in obj) res.push(key)
    return res;
};

function toS (obj) { return Object.prototype.toString.call(obj) }
function isDate (obj) { return toS(obj) === '[object Date]' }
function isRegExp (obj) { return toS(obj) === '[object RegExp]' }
function isError (obj) { return toS(obj) === '[object Error]' }
function isBoolean (obj) { return toS(obj) === '[object Boolean]' }
function isNumber (obj) { return toS(obj) === '[object Number]' }
function isString (obj) { return toS(obj) === '[object String]' }

var isArray = Array.isArray || function isArray (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

forEach(objectKeys(Traverse.prototype), function (key) {
    traverse[key] = function (obj) {
        var args = [].slice.call(arguments, 1);
        var t = new Traverse(obj);
        return t[key].apply(t, args);
    };
});

var hasOwnProperty = Object.hasOwnProperty || function (obj, key) {
    return key in obj;
};


/***/ }),

/***/ "./node_modules/wellknown/index.js":
/*!*****************************************!*\
  !*** ./node_modules/wellknown/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*eslint-disable no-cond-assign */
module.exports = parse;
module.exports.parse = parse;
module.exports.stringify = stringify;

var numberRegexp = /[-+]?([0-9]*\.[0-9]+|[0-9]+)([eE][-+]?[0-9]+)?/;
// Matches sequences like '100 100' or '100 100 100'.
var tuples = new RegExp('^' + numberRegexp.source + '(\\s' + numberRegexp.source + '){1,}');

/*
 * Parse WKT and return GeoJSON.
 *
 * @param {string} _ A WKT geometry
 * @return {?Object} A GeoJSON geometry object
 */
function parse (input) {
  var parts = input.split(';');
  var _ = parts.pop();
  var srid = (parts.shift() || '').split('=').pop();

  var i = 0;

  function $ (re) {
    var match = _.substring(i).match(re);
    if (!match) return null;
    else {
      i += match[0].length;
      return match[0];
    }
  }

  function crs (obj) {
    if (obj && srid.match(/\d+/)) {
      obj.crs = {
        type: 'name',
        properties: {
          name: 'urn:ogc:def:crs:EPSG::' + srid
        }
      };
    }

    return obj;
  }

  function white () { $(/^\s*/); }

  function multicoords () {
    white();
    var depth = 0;
    var rings = [];
    var stack = [rings];
    var pointer = rings;
    var elem;

    while (elem =
           $(/^(\()/) ||
             $(/^(\))/) ||
               $(/^(,)/) ||
                 $(tuples)) {
      if (elem === '(') {
        stack.push(pointer);
        pointer = [];
        stack[stack.length - 1].push(pointer);
        depth++;
      } else if (elem === ')') {
        // For the case: Polygon(), ...
        if (pointer.length === 0) return null;

        pointer = stack.pop();
        // the stack was empty, input was malformed
        if (!pointer) return null;
        depth--;
        if (depth === 0) break;
      } else if (elem === ',') {
        pointer = [];
        stack[stack.length - 1].push(pointer);
      } else if (!elem.split(/\s/g).some(isNaN)) {
        Array.prototype.push.apply(pointer, elem.split(/\s/g).map(parseFloat));
      } else {
        return null;
      }
      white();
    }

    if (depth !== 0) return null;

    return rings;
  }

  function coords () {
    var list = [];
    var item;
    var pt;
    while (pt =
           $(tuples) ||
             $(/^(,)/)) {
      if (pt === ',') {
        list.push(item);
        item = [];
      } else if (!pt.split(/\s/g).some(isNaN)) {
        if (!item) item = [];
        Array.prototype.push.apply(item, pt.split(/\s/g).map(parseFloat));
      }
      white();
    }

    if (item) list.push(item);
    else return null;

    return list.length ? list : null;
  }

  function point () {
    if (!$(/^(point(\sz)?)/i)) return null;
    white();
    if (!$(/^(\()/)) return null;
    var c = coords();
    if (!c) return null;
    white();
    if (!$(/^(\))/)) return null;
    return {
      type: 'Point',
      coordinates: c[0]
    };
  }

  function multipoint () {
    if (!$(/^(multipoint)/i)) return null;
    white();
    var newCoordsFormat = _
      .substring(_.indexOf('(') + 1, _.length - 1)
      .replace(/\(/g, '')
      .replace(/\)/g, '');
    _ = 'MULTIPOINT (' + newCoordsFormat + ')';
    var c = multicoords();
    if (!c) return null;
    white();
    return {
      type: 'MultiPoint',
      coordinates: c
    };
  }

  function multilinestring () {
    if (!$(/^(multilinestring)/i)) return null;
    white();
    var c = multicoords();
    if (!c) return null;
    white();
    return {
      type: 'MultiLineString',
      coordinates: c
    };
  }

  function linestring () {
    if (!$(/^(linestring(\sz)?)/i)) return null;
    white();
    if (!$(/^(\()/)) return null;
    var c = coords();
    if (!c) return null;
    if (!$(/^(\))/)) return null;
    return {
      type: 'LineString',
      coordinates: c
    };
  }

  function polygon () {
    if (!$(/^(polygon(\sz)?)/i)) return null;
    white();
    var c = multicoords();
    if (!c) return null;
    return {
      type: 'Polygon',
      coordinates: c
    };
  }

  function multipolygon () {
    if (!$(/^(multipolygon)/i)) return null;
    white();
    var c = multicoords();
    if (!c) return null;
    return {
      type: 'MultiPolygon',
      coordinates: c
    };
  }

  function geometrycollection () {
    var geometries = [];
    var geometry;

    if (!$(/^(geometrycollection)/i)) return null;
    white();

    if (!$(/^(\()/)) return null;
    while (geometry = root()) {
      geometries.push(geometry);
      white();
      $(/^(,)/);
      white();
    }
    if (!$(/^(\))/)) return null;

    return {
      type: 'GeometryCollection',
      geometries: geometries
    };
  }

  function root () {
    return point() ||
      linestring() ||
      polygon() ||
      multipoint() ||
      multilinestring() ||
      multipolygon() ||
      geometrycollection();
  }

  return crs(root());
}

/**
 * Stringifies a GeoJSON object into WKT
 */
function stringify (gj) {
  if (gj.type === 'Feature') {
    gj = gj.geometry;
  }

  function pairWKT (c) {
    return c.join(' ');
  }

  function ringWKT (r) {
    return r.map(pairWKT).join(', ');
  }

  function ringsWKT (r) {
    return r.map(ringWKT).map(wrapParens).join(', ');
  }

  function multiRingsWKT (r) {
    return r.map(ringsWKT).map(wrapParens).join(', ');
  }

  function wrapParens (s) { return '(' + s + ')'; }

  switch (gj.type) {
    case 'Point':
      return 'POINT (' + pairWKT(gj.coordinates) + ')';
    case 'LineString':
      return 'LINESTRING (' + ringWKT(gj.coordinates) + ')';
    case 'Polygon':
      return 'POLYGON (' + ringsWKT(gj.coordinates) + ')';
    case 'MultiPoint':
      return 'MULTIPOINT (' + ringWKT(gj.coordinates) + ')';
    case 'MultiPolygon':
      return 'MULTIPOLYGON (' + multiRingsWKT(gj.coordinates) + ')';
    case 'MultiLineString':
      return 'MULTILINESTRING (' + ringsWKT(gj.coordinates) + ')';
    case 'GeometryCollection':
      return 'GEOMETRYCOLLECTION (' + gj.geometries.map(stringify).join(', ') + ')';
    default:
      throw new Error('stringify requires a valid GeoJSON Feature or geometry object as input');
  }
}


/***/ }),

/***/ "./node_modules/wgs84/index.js":
/*!*************************************!*\
  !*** ./node_modules/wgs84/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports.RADIUS = 6378137;
module.exports.FLATTENING = 1/298.257223563;
module.exports.POLAR_RADIUS = 6356752.3142;


/***/ }),

/***/ "./node_modules/xtend/immutable.js":
/*!*****************************************!*\
  !*** ./node_modules/xtend/immutable.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}


/***/ }),

/***/ "./src/app/business/geo-label/sign/edit-tool/edit-tool.component.ts":
/*!**************************************************************************!*\
  !*** ./src/app/business/geo-label/sign/edit-tool/edit-tool.component.ts ***!
  \**************************************************************************/
/*! exports provided: EditToolComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditToolComponent", function() { return EditToolComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/__ivy_ngcc__/fesm5/core.js");
/* harmony import */ var _mapbox_mapbox_gl_draw__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @mapbox/mapbox-gl-draw */ "./node_modules/@mapbox/mapbox-gl-draw/index.js");
/* harmony import */ var mapbox_gl_draw_rectangle_mode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! mapbox-gl-draw-rectangle-mode */ "./node_modules/mapbox-gl-draw-rectangle-mode/dist/index.js");
/* harmony import */ var mapbox_gl_draw_rectangle_mode__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(mapbox_gl_draw_rectangle_mode__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var mapbox_gl_draw_circle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! mapbox-gl-draw-circle */ "./node_modules/mapbox-gl-draw-circle/index.js");
/* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/__ivy_ngcc__/fesm5/animations.js");
/* harmony import */ var _utils_mapTool__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/mapTool */ "./src/app/business/geo-label/utils/mapTool.ts");
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./style */ "./src/app/business/geo-label/sign/edit-tool/style.ts");
/* harmony import */ var _toolConfig__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./toolConfig */ "./src/app/business/geo-label/sign/edit-tool/toolConfig.ts");
/* harmony import */ var src_app_cityfun_mapbox_map_service_mapboxmap_service__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! src/app/cityfun/mapbox-map/service/mapboxmap.service */ "./src/app/cityfun/mapbox-map/service/mapboxmap.service.ts");
/* harmony import */ var _services_edit_tool_service__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../services/edit-tool.service */ "./src/app/business/geo-label/sign/services/edit-tool.service.ts");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/__ivy_ngcc__/fesm5/common.js");













function EditToolComponent_div_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementContainerStart"](0);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["element"](1, "img", 6);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementContainerEnd"]();
} if (rf & 2) {
    var item_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["nextContext"]().$implicit;
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["advance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["property"]("src", item_r1.selectImg, _angular_core__WEBPACK_IMPORTED_MODULE_1__["sanitizeUrl"]);
} }
function EditToolComponent_div_1_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["element"](0, "img", 6);
} if (rf & 2) {
    var item_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["nextContext"]().$implicit;
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["property"]("src", item_r1.defaultImg, _angular_core__WEBPACK_IMPORTED_MODULE_1__["sanitizeUrl"]);
} }
function EditToolComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    var _r9 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["getCurrentView"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementStart"](0, "div", 2);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["listener"]("click", function EditToolComponent_div_1_Template_div_click_0_listener() { _angular_core__WEBPACK_IMPORTED_MODULE_1__["restoreView"](_r9); var item_r1 = ctx.$implicit; var i_r2 = ctx.index; var ctx_r8 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["nextContext"](); return ctx_r8.tooItemClick(item_r1, i_r2); });
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementStart"](1, "div", 3);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["template"](2, EditToolComponent_div_1_ng_container_2_Template, 2, 1, "ng-container", 4);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["template"](3, EditToolComponent_div_1_ng_template_3_Template, 1, 1, "ng-template", null, 5, _angular_core__WEBPACK_IMPORTED_MODULE_1__["templateRefExtractor"]);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementStart"](5, "span");
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["text"](6);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementEnd"]();
} if (rf & 2) {
    var item_r1 = ctx.$implicit;
    var i_r2 = ctx.index;
    var _r4 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["reference"](4);
    var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["nextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["classProp"]("select", i_r2 === ctx_r0.selectIndex);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["advance"](2);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["property"]("ngIf", i_r2 === ctx_r0.selectIndex)("ngIfElse", _r4);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["advance"](4);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["textInterpolate1"](" ", item_r1.label, "");
} }
var EditToolComponent = /** @class */ (function () {
    function EditToolComponent(mapboxmapService, cdr, editToolService) {
        var _this = this;
        this.mapboxmapService = mapboxmapService;
        this.cdr = cdr;
        this.editToolService = editToolService;
        this.mapboxglmap = null;
        this.mapboxDraw = null;
        this.selectIndex = -1;
        this.deleteSub = null;
        this.addToMapSub = null;
        this.tools = _toolConfig__WEBPACK_IMPORTED_MODULE_8__["tools"];
        this.eventCallBack = {};
        this.mapboxmapService.init().subscribe(function (mapboxglmap) {
            _this.mapboxglmap = mapboxglmap;
            if (_this.mapboxmapService.firstFullLoaded) {
                _this.mapInit();
            }
            mapboxglmap.on('load', function () {
                _this.mapInit();
            });
        });
    }
    EditToolComponent.prototype.ngOnInit = function () { };
    EditToolComponent.prototype.mapInit = function () {
        var _this = this;
        var self = this;
        function updateArea(data, type) {
            self.cdr.markForCheck();
            self.selectIndex = -1;
            switch (type) {
                case 'create':
                    self.editToolService.addFeature(data.features[0]);
                    break;
                case 'delete':
                    self.editToolService.deleteFeature(data.features[0]);
                    break;
                case 'update':
                    self.editToolService.editFeature(data.features[0]);
                    break;
            }
            setTimeout(function () {
                self.mapboxmapService.setCursor('grab');
            }, 20);
        }
        this.mapboxDraw = new _mapbox_mapbox_gl_draw__WEBPACK_IMPORTED_MODULE_2__["default"]({
            styles: _style__WEBPACK_IMPORTED_MODULE_7__["drawStyles"],
            modes: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"])({}, _mapbox_mapbox_gl_draw__WEBPACK_IMPORTED_MODULE_2__["default"].modes), { draw_circle: mapbox_gl_draw_circle__WEBPACK_IMPORTED_MODULE_4__["CircleMode"], drag_circle: mapbox_gl_draw_circle__WEBPACK_IMPORTED_MODULE_4__["DragCircleMode"], draw_rectangle: mapbox_gl_draw_rectangle_mode__WEBPACK_IMPORTED_MODULE_3___default.a, direct_select: mapbox_gl_draw_circle__WEBPACK_IMPORTED_MODULE_4__["DirectMode"], simple_select: mapbox_gl_draw_circle__WEBPACK_IMPORTED_MODULE_4__["SimpleSelectMode"] }),
        });
        this.mapboxglmap.addControl(this.mapboxDraw, 'bottom-right');
        this.eventCallBack[_utils_mapTool__WEBPACK_IMPORTED_MODULE_6__["event_draw_create"]] = function (e) {
            updateArea(e, 'create');
        };
        this.eventCallBack[_utils_mapTool__WEBPACK_IMPORTED_MODULE_6__["event_draw_update"]] = function (e) {
            updateArea(e, 'update');
        };
        this.eventCallBack[_utils_mapTool__WEBPACK_IMPORTED_MODULE_6__["event_draw_delete"]] = function (e) {
            updateArea(e, 'delete');
        };
        this.mapboxglmap.on('draw.create', this.eventCallBack[_utils_mapTool__WEBPACK_IMPORTED_MODULE_6__["event_draw_create"]]);
        this.mapboxglmap.on('draw.delete', this.eventCallBack[_utils_mapTool__WEBPACK_IMPORTED_MODULE_6__["event_draw_delete"]]);
        this.mapboxglmap.on('draw.update', this.eventCallBack[_utils_mapTool__WEBPACK_IMPORTED_MODULE_6__["event_draw_update"]]);
        this.deleteSub = this.editToolService.deleteFeature$.subscribe(function (feature) {
            _this.delete([feature.id]);
        });
        this.addToMapSub = this.editToolService.addToMap$.subscribe(function (features) {
            _this.initDrawFeaturesToMap(features);
        });
    };
    EditToolComponent.prototype.initDrawFeaturesToMap = function (features) {
        var _this = this;
        features.forEach(function (feature) {
            _this.mapboxDraw.add(feature);
        });
    };
    EditToolComponent.prototype.tooItemClick = function (item, index) {
        var _this = this;
        this.selectIndex = index;
        this.mapboxDraw.changeMode(item.type);
        setTimeout(function () {
            _this.mapboxmapService.setCursor('crosshair');
        }, 5);
    };
    EditToolComponent.prototype.getSelectedIds = function () {
        return this.mapboxDraw.getSelectedIds();
    };
    EditToolComponent.prototype.deleteAll = function () {
        this.mapboxDraw.deleteAll();
    };
    EditToolComponent.prototype.delete = function (ids) {
        this.mapboxDraw.delete(ids);
    };
    EditToolComponent.prototype.getAll = function () {
        return this.mapboxDraw.getAll();
    };
    EditToolComponent.prototype.ngOnDestroy = function () {
        if (this.mapboxDraw) {
            this.mapboxglmap.removeControl(this.mapboxDraw);
        }
        this.deleteSub && this.deleteSub.unsubscribe();
        this.addToMapSub && this.addToMapSub.unsubscribe();
        Object(_utils_mapTool__WEBPACK_IMPORTED_MODULE_6__["offMapEvent"])(this.mapboxglmap, 'draw.create', _utils_mapTool__WEBPACK_IMPORTED_MODULE_6__["event_draw_create"], this.eventCallBack);
        Object(_utils_mapTool__WEBPACK_IMPORTED_MODULE_6__["offMapEvent"])(this.mapboxglmap, 'draw.delete', _utils_mapTool__WEBPACK_IMPORTED_MODULE_6__["event_draw_delete"], this.eventCallBack);
        Object(_utils_mapTool__WEBPACK_IMPORTED_MODULE_6__["offMapEvent"])(this.mapboxglmap, 'draw.update', _utils_mapTool__WEBPACK_IMPORTED_MODULE_6__["event_draw_update"], this.eventCallBack);
    };
    EditToolComponent.fac = function EditToolComponent_Factory(t) { return new (t || EditToolComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["directiveInject"](src_app_cityfun_mapbox_map_service_mapboxmap_service__WEBPACK_IMPORTED_MODULE_9__["MapboxmapService"]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["directiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["directiveInject"](_services_edit_tool_service__WEBPACK_IMPORTED_MODULE_10__["EditToolService"])); };
    EditToolComponent.cmp = _angular_core__WEBPACK_IMPORTED_MODULE_1__["defineComponent"]({ type: EditToolComponent, selectors: [["lb-edit-tool"]], inputs: { tools: "tools" }, decls: 2, vars: 2, consts: [[1, "tool-container"], ["class", "item", 3, "select", "click", 4, "ngFor", "ngForOf"], [1, "item", 3, "click"], [1, "item-content"], [4, "ngIf", "ngIfElse"], ["elseTemplate", ""], [3, "src"]], template: function EditToolComponent_Template(rf, ctx) { if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementStart"](0, "div", 0);
            _angular_core__WEBPACK_IMPORTED_MODULE_1__["template"](1, EditToolComponent_div_1_Template, 7, 5, "div", 1);
            _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementEnd"]();
        } if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_1__["property"]("@showEditToolAni", undefined);
            _angular_core__WEBPACK_IMPORTED_MODULE_1__["advance"](1);
            _angular_core__WEBPACK_IMPORTED_MODULE_1__["property"]("ngForOf", ctx.tools);
        } }, directives: [_angular_common__WEBPACK_IMPORTED_MODULE_11__["NgForOf"], _angular_common__WEBPACK_IMPORTED_MODULE_11__["NgIf"]], styles: [".tool-container[_ngcontent-%COMP%] {\n  display: -ms-flexbox;\n  display: flex;\n  border-radius: 4px;\n  background: #fff;\n  color: #333;\n  font-size: 14px;\n  pointer-events: all;\n}\n.tool-container[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%] {\n  width: 80px;\n  height: 40px;\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-align: center;\n      align-items: center;\n  -ms-flex-pack: center;\n      justify-content: center;\n  cursor: pointer;\n  box-sizing: border-box;\n}\n.tool-container[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]   .item-content[_ngcontent-%COMP%] {\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-align: center;\n      align-items: center;\n  -ms-flex-pack: center;\n      justify-content: center;\n  width: 100%;\n  border-right: 1px solid #f3f3f3;\n}\n.tool-container[_ngcontent-%COMP%]   .select[_ngcontent-%COMP%] {\n  border: 2px solid #1890ff;\n  color: #1890ff;\n}\n.tool-container[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]:first-child {\n  border-top-left-radius: 4px;\n  border-bottom-left-radius: 4px;\n}\n.tool-container[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]:last-child {\n  border-top-right-radius: 4px;\n  border-bottom-right-radius: 4px;\n}\n.tool-container[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]:last-child   .item-content[_ngcontent-%COMP%]   span[_ngcontent-%COMP%] {\n  border-right: 0;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAvYnVzaW5lc3MvZ2VvLWxhYmVsL3NpZ24vZWRpdC10b29sL0U6XFxQcm9qMjAyMFxc56m66Ze06LWE5rqQ5pm65oWn566h55CGXFxHZW9MYWJlbC9zcmNcXGFwcFxcYnVzaW5lc3NcXGdlby1sYWJlbFxcc2lnblxcZWRpdC10b29sXFxlZGl0LXRvb2wuY29tcG9uZW50LnNjc3MiLCJzcmMvYXBwL2J1c2luZXNzL2dlby1sYWJlbC9zaWduL2VkaXQtdG9vbC9lZGl0LXRvb2wuY29tcG9uZW50LnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7RUFDRSxvQkFBQTtFQUFBLGFBQUE7RUFDQSxrQkFBQTtFQUNBLGdCQUFBO0VBQ0EsV0FBQTtFQUNBLGVBQUE7RUFDQSxtQkFBQTtBQ0NGO0FEQUU7RUFDRSxXQUFBO0VBQ0EsWUFBQTtFQUNBLG9CQUFBO0VBQUEsYUFBQTtFQUNBLHNCQUFBO01BQUEsbUJBQUE7RUFDQSxxQkFBQTtNQUFBLHVCQUFBO0VBQ0EsZUFBQTtFQUNBLHNCQUFBO0FDRUo7QURESTtFQUNFLG9CQUFBO0VBQUEsYUFBQTtFQUNBLHNCQUFBO01BQUEsbUJBQUE7RUFDQSxxQkFBQTtNQUFBLHVCQUFBO0VBQ0EsV0FBQTtFQUNBLCtCQUFBO0FDR047QURPRTtFQUNFLHlCQUFBO0VBQ0EsY0FBQTtBQ0xKO0FET0U7RUFDRSwyQkFBQTtFQUNBLDhCQUFBO0FDTEo7QURPRTtFQUNFLDRCQUFBO0VBQ0EsK0JBQUE7QUNMSjtBRE9NO0VBQ0UsZUFBQTtBQ0xSIiwiZmlsZSI6InNyYy9hcHAvYnVzaW5lc3MvZ2VvLWxhYmVsL3NpZ24vZWRpdC10b29sL2VkaXQtdG9vbC5jb21wb25lbnQuc2NzcyIsInNvdXJjZXNDb250ZW50IjpbIi50b29sLWNvbnRhaW5lciB7XHJcbiAgZGlzcGxheTogZmxleDtcclxuICBib3JkZXItcmFkaXVzOiA0cHg7XHJcbiAgYmFja2dyb3VuZDogI2ZmZjtcclxuICBjb2xvcjogIzMzMztcclxuICBmb250LXNpemU6IDE0cHg7XHJcbiAgcG9pbnRlci1ldmVudHM6IGFsbDtcclxuICAuaXRlbSB7XHJcbiAgICB3aWR0aDogODBweDtcclxuICAgIGhlaWdodDogNDBweDtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xyXG4gICAgLml0ZW0tY29udGVudCB7XHJcbiAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbiAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xyXG4gICAgICB3aWR0aDogMTAwJTtcclxuICAgICAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQgI2YzZjNmMztcclxuICAgIC8vICAgc3BhbiB7XHJcbiAgICAvLyAgICAgZGlzcGxheTogZmxleDtcclxuICAgIC8vICAgICBoZWlnaHQ6IDIwcHg7XHJcbiAgICAgXHJcbiAgICAvLyAgICAgbGluZS1oZWlnaHQ6IDIwcHg7XHJcbiAgICAvLyAgICAgd2lkdGg6IDUwJTtcclxuICAgIC8vICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICAuc2VsZWN0IHtcclxuICAgIGJvcmRlcjogMnB4IHNvbGlkICMxODkwZmY7XHJcbiAgICBjb2xvcjogIzE4OTBmZjtcclxuICB9XHJcbiAgLml0ZW06Zmlyc3QtY2hpbGQge1xyXG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogNHB4O1xyXG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogNHB4O1xyXG4gIH1cclxuICAuaXRlbTpsYXN0LWNoaWxkIHtcclxuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA0cHg7XHJcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogNHB4O1xyXG4gICAgLml0ZW0tY29udGVudCB7XHJcbiAgICAgIHNwYW4ge1xyXG4gICAgICAgIGJvcmRlci1yaWdodDogMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCIudG9vbC1jb250YWluZXIge1xuICBkaXNwbGF5OiBmbGV4O1xuICBib3JkZXItcmFkaXVzOiA0cHg7XG4gIGJhY2tncm91bmQ6ICNmZmY7XG4gIGNvbG9yOiAjMzMzO1xuICBmb250LXNpemU6IDE0cHg7XG4gIHBvaW50ZXItZXZlbnRzOiBhbGw7XG59XG4udG9vbC1jb250YWluZXIgLml0ZW0ge1xuICB3aWR0aDogODBweDtcbiAgaGVpZ2h0OiA0MHB4O1xuICBkaXNwbGF5OiBmbGV4O1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xufVxuLnRvb2wtY29udGFpbmVyIC5pdGVtIC5pdGVtLWNvbnRlbnQge1xuICBkaXNwbGF5OiBmbGV4O1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgd2lkdGg6IDEwMCU7XG4gIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNmM2YzZjM7XG59XG4udG9vbC1jb250YWluZXIgLnNlbGVjdCB7XG4gIGJvcmRlcjogMnB4IHNvbGlkICMxODkwZmY7XG4gIGNvbG9yOiAjMTg5MGZmO1xufVxuLnRvb2wtY29udGFpbmVyIC5pdGVtOmZpcnN0LWNoaWxkIHtcbiAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogNHB4O1xuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiA0cHg7XG59XG4udG9vbC1jb250YWluZXIgLml0ZW06bGFzdC1jaGlsZCB7XG4gIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA0cHg7XG4gIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiA0cHg7XG59XG4udG9vbC1jb250YWluZXIgLml0ZW06bGFzdC1jaGlsZCAuaXRlbS1jb250ZW50IHNwYW4ge1xuICBib3JkZXItcmlnaHQ6IDA7XG59Il19 */"], data: { animation: [
                Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["trigger"])('showEditToolAni', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["transition"])(':enter', [
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["style"])({
                            opacity: 0,
                        }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["animate"])('.2s', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["style"])({
                            opacity: 1,
                        })),
                    ]),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["transition"])(':leave', [
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["style"])({
                            opacity: 1,
                        }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["animate"])('.2s', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["style"])({
                            opacity: 0,
                        })),
                    ]),
                ]),
            ] }, changeDetection: 0 });
    return EditToolComponent;
}());

/*@__PURE__*/ (function () { _angular_core__WEBPACK_IMPORTED_MODULE_1__["setClassMetadata"](EditToolComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
        args: [{
                selector: 'lb-edit-tool',
                templateUrl: './edit-tool.component.html',
                styleUrls: ['./edit-tool.component.scss'],
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                animations: [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["trigger"])('showEditToolAni', [
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["transition"])(':enter', [
                            Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["style"])({
                                opacity: 0,
                            }),
                            Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["animate"])('.2s', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["style"])({
                                opacity: 1,
                            })),
                        ]),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["transition"])(':leave', [
                            Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["style"])({
                                opacity: 1,
                            }),
                            Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["animate"])('.2s', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_5__["style"])({
                                opacity: 0,
                            })),
                        ]),
                    ]),
                ],
            }]
    }], function () { return [{ type: src_app_cityfun_mapbox_map_service_mapboxmap_service__WEBPACK_IMPORTED_MODULE_9__["MapboxmapService"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] }, { type: _services_edit_tool_service__WEBPACK_IMPORTED_MODULE_10__["EditToolService"] }]; }, { tools: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }] }); })();


/***/ }),

/***/ "./src/app/business/geo-label/sign/edit-tool/style.ts":
/*!************************************************************!*\
  !*** ./src/app/business/geo-label/sign/edit-tool/style.ts ***!
  \************************************************************/
/*! exports provided: drawStyles */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawStyles", function() { return drawStyles; });
var drawStyles = [
    {
        'id': 'highlight-active-points',
        'type': 'circle',
        'filter': ['all',
            ['==', '$type', 'Point'],
            ['==', 'meta', 'feature'],
            ['==', 'active', 'true']],
        'paint': {
            'circle-radius': 7,
            'circle-color': 'red'
        }
    },
    {
        'id': 'points-are-blue',
        'type': 'circle',
        'filter': ['all',
            ['==', '$type', 'Point'],
            ['==', 'meta', 'feature'],
            ['==', 'active', 'false']],
        'paint': {
            'circle-radius': 5,
            'circle-color': '#1890ff'
        }
    },
    {
        "id": "gl-draw-line",
        "type": "line",
        "filter": ["all", ["==", "$type", "LineString"], ["!=", "mode", "static"]],
        "layout": {
            "line-cap": "round",
            "line-join": "round"
        },
        "paint": {
            "line-color": "#1890ff",
            "line-dasharray": [0.2, 2],
            "line-width": 2
        }
    },
    // polygon fill
    {
        "id": "gl-draw-polygon-fill",
        "type": "fill",
        "filter": ["all", ["==", "$type", "Polygon"], ["!=", "mode", "static"]],
        "paint": {
            "fill-color": "#1890ff",
            "fill-outline-color": "#D20C0C",
            "fill-opacity": 0.1
        }
    },
    // polygon outline stroke
    // This doesn't style the first edge of the polygon, which uses the line stroke styling instead
    {
        "id": "gl-draw-polygon-stroke-active",
        "type": "line",
        "filter": ["all", ["==", "$type", "Polygon"], ["!=", "mode", "static"]],
        "layout": {
            "line-cap": "round",
            "line-join": "round"
        },
        "paint": {
            "line-color": "#1890ff",
            "line-dasharray": [0.2, 2],
            "line-width": 2
        }
    },
    // vertex point halos
    {
        "id": "gl-draw-polygon-and-line-vertex-halo-active",
        "type": "circle",
        "filter": ["all", ["==", "meta", "vertex"], ["==", "$type", "Point"], ["!=", "mode", "static"]],
        "paint": {
            "circle-radius": 5,
            "circle-color": "#FFF"
        }
    },
    // vertex points
    {
        "id": "gl-draw-polygon-and-line-vertex-active",
        "type": "circle",
        "filter": ["all", ["==", "meta", "vertex"], ["==", "$type", "Point"], ["!=", "mode", "static"]],
        "paint": {
            "circle-radius": 3,
            "circle-color": "#D20C0C",
        }
    },
    // INACTIVE (static, already drawn)
    // line stroke
    {
        "id": "gl-draw-line-static",
        "type": "line",
        "filter": ["all", ["==", "$type", "LineString"], ["==", "mode", "static"]],
        "layout": {
            "line-cap": "round",
            "line-join": "round"
        },
        "paint": {
            "line-color": "#000",
            "line-width": 3
        }
    },
    // polygon fill
    {
        "id": "gl-draw-polygon-fill-static",
        "type": "fill",
        "filter": ["all", ["==", "$type", "Polygon"], ["==", "mode", "static"]],
        "paint": {
            "fill-color": "#000",
            "fill-outline-color": "#000",
            "fill-opacity": 0.1
        }
    },
    // polygon outline
    {
        "id": "gl-draw-polygon-stroke-static",
        "type": "line",
        "filter": ["all", ["==", "$type", "Polygon"], ["==", "mode", "static"]],
        "layout": {
            "line-cap": "round",
            "line-join": "round"
        },
        "paint": {
            "line-color": "#000",
            "line-width": 3
        }
    }
];


/***/ }),

/***/ "./src/app/business/geo-label/sign/edit-tool/toolConfig.ts":
/*!*****************************************************************!*\
  !*** ./src/app/business/geo-label/sign/edit-tool/toolConfig.ts ***!
  \*****************************************************************/
/*! exports provided: tools */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tools", function() { return tools; });
var tools = [
    {
        label: '',
        type: 'draw_point',
        defaultImg: './assets/img/map/icon_mark_point.png',
        selectImg: './assets/img/map/icon_mark_point_selected.png',
    },
    {
        label: '',
        type: 'draw_line_string',
        defaultImg: './assets/img/map/icon_mark_line.png',
        selectImg: './assets/img/map/icon_mark_line_selected.png',
    },
    {
        label: '',
        type: 'draw_polygon',
        defaultImg: './assets/img/map/icon_mark_rectangle.png',
        selectImg: './assets/img/map/icon_mark_rectangle_selected.png',
    },
    {
        label: '',
        type: 'drag_circle',
        defaultImg: './assets/img/map/icon_mark_circle.png',
        selectImg: './assets/img/map/icon_mark_circle_selected.png',
    },
];


/***/ }),

/***/ "./src/app/business/geo-label/sign/label-add/add-content/add-content.component.ts":
/*!****************************************************************************************!*\
  !*** ./src/app/business/geo-label/sign/label-add/add-content/add-content.component.ts ***!
  \****************************************************************************************/
/*! exports provided: AddContentComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddContentComponent", function() { return AddContentComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/__ivy_ngcc__/fesm5/core.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_main_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utils/main-format */ "./src/app/business/geo-label/utils/main-format.ts");
/* harmony import */ var _sign_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../sign.component */ "./src/app/business/geo-label/sign/sign.component.ts");
/* harmony import */ var _sign_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../sign.service */ "./src/app/business/geo-label/sign/sign.service.ts");
/* harmony import */ var ng_zorro_antd_message__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ng-zorro-antd/message */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-message.js");
/* harmony import */ var _services_edit_tool_service__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../services/edit-tool.service */ "./src/app/business/geo-label/sign/services/edit-tool.service.ts");
/* harmony import */ var _common_add_marker_statue_add_marker_statue_component__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../common/add-marker-statue/add-marker-statue.component */ "./src/app/business/geo-label/common/add-marker-statue/add-marker-statue.component.ts");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/__ivy_ngcc__/fesm5/common.js");
/* harmony import */ var _base_info_base_info_component__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../base-info/base-info.component */ "./src/app/business/geo-label/sign/label-add/base-info/base-info.component.ts");
/* harmony import */ var _label_feature_label_feature_component__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../label-feature/label-feature.component */ "./src/app/business/geo-label/sign/label-add/label-feature/label-feature.component.ts");
/* harmony import */ var _label_success_label_success_component__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../label-success/label-success.component */ "./src/app/business/geo-label/sign/label-add/label-success/label-success.component.ts");
/* harmony import */ var ng_zorro_antd_button__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ng-zorro-antd/button */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-button.js");
/* harmony import */ var ng_zorro_antd_core_wave__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ng-zorro-antd/core/wave */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-core-wave.js");
/* harmony import */ var ng_zorro_antd_core_transition_patch__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ng-zorro-antd/core/transition-patch */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-core-transition-patch.js");
















var _c0 = ["baseInfoComponent"];
var _c1 = ["labelFeatureComponent"];
function AddContentComponent_app_base_info_2_Template(rf, ctx) { if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["element"](0, "app-base-info", 6, 7);
} if (rf & 2) {
    var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("baseInfo", ctx_r0.addSourceInfo.baseInfo);
} }
function AddContentComponent_app_label_feature_3_Template(rf, ctx) { if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["element"](0, "app-label-feature", 8, 9);
} if (rf & 2) {
    var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("features", ctx_r1.addSourceInfo.graphs);
} }
function AddContentComponent_app_label_success_4_Template(rf, ctx) { if (rf & 1) {
    var _r7 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["getCurrentView"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](0, "app-label-success", 10);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["listener"]("createAgainEmit", function AddContentComponent_app_label_success_4_Template_app_label_success_createAgainEmit_0_listener() { _angular_core__WEBPACK_IMPORTED_MODULE_0__["restoreView"](_r7); var ctx_r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](); return ctx_r6.createAgain(); })("viewDetailEmit", function AddContentComponent_app_label_success_4_Template_app_label_success_viewDetailEmit_0_listener() { _angular_core__WEBPACK_IMPORTED_MODULE_0__["restoreView"](_r7); var ctx_r8 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](); return ctx_r8.viewDetail(); });
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
} if (rf & 2) {
    var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("addTagSuccess", ctx_r2.addTagSuccess);
} }
function AddContentComponent_div_5_button_1_Template(rf, ctx) { if (rf & 1) {
    var _r11 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["getCurrentView"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](0, "button", 14);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["listener"]("click", function AddContentComponent_div_5_button_1_Template_button_click_0_listener() { _angular_core__WEBPACK_IMPORTED_MODULE_0__["restoreView"](_r11); var ctx_r10 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](2); return ctx_r10.beforeClick(); });
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](1, " \u4E0A\u4E00\u6B65 ");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
} }
function AddContentComponent_div_5_Template(rf, ctx) { if (rf & 1) {
    var _r13 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["getCurrentView"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](0, "div", 11);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](1, AddContentComponent_div_5_button_1_Template, 2, 0, "button", 12);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](2, "button", 13);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["listener"]("click", function AddContentComponent_div_5_Template_button_click_2_listener() { _angular_core__WEBPACK_IMPORTED_MODULE_0__["restoreView"](_r13); var ctx_r12 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](); return ctx_r12.nextClick(); });
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](3, "\u4E0B\u4E00\u6B65");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
} if (rf & 2) {
    var ctx_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngIf", ctx_r3.addStatueIndex == 1);
} }
var AddContentComponent = /** @class */ (function () {
    function AddContentComponent(signComponent, signService, mzMessageService, cdr, editToolService) {
        this.signComponent = signComponent;
        this.signService = signService;
        this.mzMessageService = mzMessageService;
        this.cdr = cdr;
        this.editToolService = editToolService;
        this.isEdit = false;
        this.tagId = '';
        this.addStatueIndex = 0;
        this.addTagSuccess = true;
        this.showEditToolEvent = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.showDetail = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.addSourceInfo = {
            baseInfo: null,
            graphs: [],
        };
    }
    AddContentComponent.prototype.ngOnInit = function () {
    };
    AddContentComponent.prototype.nextClick = function () {
        switch (this.addStatueIndex) {
            case 0:
                this.baseInfoComponent.submitForm();
                // 
                if (this.baseInfoComponent.validateForm.valid) {
                    // 
                    this.addSourceInfo.baseInfo = Object(lodash__WEBPACK_IMPORTED_MODULE_1__["cloneDeep"])(this.baseInfoComponent.validateForm.value);
                    this.addStatueIndex++;
                }
                break;
            case 1:
                // 
                this.addSourceInfo.graphs = this.labelFeatureComponent.features;
                var _a = this.signComponent.editMarker.getLngLat(), lng = _a.lng, lat = _a.lat;
                this.addTag([lng, lat], this.addSourceInfo);
                break;
        }
        // 
        this.toggleDrawTool(this.addStatueIndex);
    };
    AddContentComponent.prototype.beforeClick = function () {
        this.addStatueIndex -= 1;
        // show draw  Tool
        this.toggleDrawTool(this.addStatueIndex);
    };
    AddContentComponent.prototype.createAgain = function () {
        // this.addStatueIndex =   0 ;
        this.signComponent.stopMarker();
        this.signComponent.tagDetailInfo = null;
    };
    AddContentComponent.prototype.viewDetail = function () {
        if (this.isEdit) {
            this.signComponent.stopMarker();
            this.showDetail.emit();
        }
        this.signComponent.toggleDetail(this.tagId);
    };
    AddContentComponent.prototype.addTag = function (geo, source) {
        var _this = this;
        var res = Object(_utils_main_format__WEBPACK_IMPORTED_MODULE_2__["sourceTagToParams"])(geo, source);
        var funName = this.isEdit ? "editTag" : 'addTag';
        var message = this.isEdit ? "" : '';
        if (this.isEdit) {
            res.tagid = this.tagId;
        }
        else {
            delete res.tagid;
        }
        this.signService[funName](res).subscribe(function (tagId) {
            if (tagId) {
                _this.tagId = tagId;
                _this.addStatueIndex++;
                _this.addTagSuccess = true;
                _this.cdr.markForCheck();
                _this.mzMessageService.success(message + "\u6807\u8BB0\u6210\u529F!");
                _this.signComponent.getTags(null);
            }
            else {
                _this.addTagSuccess = false;
                _this.mzMessageService.error(message + "\u6807\u8BB0\u5931\u8D25!");
            }
        });
    };
    AddContentComponent.prototype.toggleDrawTool = function (statueIndex) {
        if (statueIndex == 1) {
            this.editToolService.toggleTool(true);
        }
        else {
            this.editToolService.toggleTool(false);
        }
    };
    AddContentComponent.prototype.ngOnDestroy = function () {
        this.editToolService.toggleTool(false);
    };
    AddContentComponent.fac = function AddContentComponent_Factory(t) { return new (t || AddContentComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](_sign_component__WEBPACK_IMPORTED_MODULE_3__["SignComponent"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](_sign_service__WEBPACK_IMPORTED_MODULE_4__["SignService"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](ng_zorro_antd_message__WEBPACK_IMPORTED_MODULE_5__["NzMessageService"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](_services_edit_tool_service__WEBPACK_IMPORTED_MODULE_6__["EditToolService"])); };
    AddContentComponent.cmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["defineComponent"]({ type: AddContentComponent, selectors: [["lb-add-content"]], viewQuery: function AddContentComponent_Query(rf, ctx) { if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["viewQuery"](_c0, true);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["viewQuery"](_c1, true);
        } if (rf & 2) {
            var _t;
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["queryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["loadQuery"]()) && (ctx.baseInfoComponent = _t.first);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["queryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["loadQuery"]()) && (ctx.labelFeatureComponent = _t.first);
        } }, inputs: { isEdit: "isEdit", tagId: "tagId", addSourceInfo: "addSourceInfo" }, outputs: { showEditToolEvent: "showEditToolEvent", showDetail: "showDetail" }, decls: 6, vars: 6, consts: [[1, "top"], [3, "selectIndex", "addTagSuccess"], [3, "baseInfo", 4, "ngIf"], [3, "features", 4, "ngIf"], [3, "addTagSuccess", "createAgainEmit", "viewDetailEmit", 4, "ngIf"], ["class", "bottom", 4, "ngIf"], [3, "baseInfo"], ["baseInfoComponent", ""], [3, "features"], ["labelFeatureComponent", ""], [3, "addTagSuccess", "createAgainEmit", "viewDetailEmit"], [1, "bottom"], ["nz-button", "", "nzType", "default", 3, "click", 4, "ngIf"], ["nz-button", "", "nzType", "primary", 3, "click"], ["nz-button", "", "nzType", "default", 3, "click"]], template: function AddContentComponent_Template(rf, ctx) { if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](0, "div", 0);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["element"](1, "app-add-marker-statue", 1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](2, AddContentComponent_app_base_info_2_Template, 2, 1, "app-base-info", 2);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](3, AddContentComponent_app_label_feature_3_Template, 2, 1, "app-label-feature", 3);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](4, AddContentComponent_app_label_success_4_Template, 1, 1, "app-label-success", 4);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](5, AddContentComponent_div_5_Template, 4, 1, "div", 5);
        } if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("selectIndex", ctx.addStatueIndex)("addTagSuccess", ctx.addTagSuccess);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngIf", ctx.addStatueIndex == 0);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngIf", ctx.addStatueIndex == 1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngIf", ctx.addStatueIndex == 2);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngIf", ctx.addStatueIndex < 2);
        } }, directives: [_common_add_marker_statue_add_marker_statue_component__WEBPACK_IMPORTED_MODULE_7__["AddMarkerStatueComponent"], _angular_common__WEBPACK_IMPORTED_MODULE_8__["NgIf"], _base_info_base_info_component__WEBPACK_IMPORTED_MODULE_9__["BaseInfoComponent"], _label_feature_label_feature_component__WEBPACK_IMPORTED_MODULE_10__["LabelFeatureComponent"], _label_success_label_success_component__WEBPACK_IMPORTED_MODULE_11__["LabelSuccessComponent"], ng_zorro_antd_button__WEBPACK_IMPORTED_MODULE_12__["NzButtonComponent"], ng_zorro_antd_core_wave__WEBPACK_IMPORTED_MODULE_13__["NzWaveDirective"], ng_zorro_antd_core_transition_patch__WEBPACK_IMPORTED_MODULE_14__["NzTransitionPatchDirective"]], styles: [".top[_ngcontent-%COMP%] {\n  padding: 16px;\n}\n\n.bottom[_ngcontent-%COMP%] {\n  position: absolute;\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-align: center;\n      align-items: center;\n  -ms-flex-pack: end;\n      justify-content: flex-end;\n  height: 48px;\n  border-top: 1px solid #e5e5e5;\n  padding-right: 16px;\n  bottom: 0px;\n  left: 0px;\n  width: 100%;\n  background: #ffffff;\n}\n\n.bottom[_ngcontent-%COMP%]    > [_ngcontent-%COMP%]:nth-child(2) {\n  margin-left: 8px;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAvYnVzaW5lc3MvZ2VvLWxhYmVsL3NpZ24vbGFiZWwtYWRkL2FkZC1jb250ZW50L0U6XFxQcm9qMjAyMFxc56m66Ze06LWE5rqQ5pm65oWn566h55CGXFxHZW9MYWJlbC9zcmNcXGFwcFxcYnVzaW5lc3NcXGdlby1sYWJlbFxcc2lnblxcbGFiZWwtYWRkXFxhZGQtY29udGVudFxcYWRkLWNvbnRlbnQuY29tcG9uZW50LnNjc3MiLCJzcmMvYXBwL2J1c2luZXNzL2dlby1sYWJlbC9zaWduL2xhYmVsLWFkZC9hZGQtY29udGVudC9hZGQtY29udGVudC5jb21wb25lbnQuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtFQUNFLGFBQUE7QUNDRjs7QURDQTtFQUNFLGtCQUFBO0VBQ0Esb0JBQUE7RUFBQSxhQUFBO0VBQ0Esc0JBQUE7TUFBQSxtQkFBQTtFQUNBLGtCQUFBO01BQUEseUJBQUE7RUFDQSxZQUFBO0VBQ0EsNkJBQUE7RUFDQSxtQkFBQTtFQUNBLFdBQUE7RUFDQSxTQUFBO0VBQ0EsV0FBQTtFQUNBLG1CQUFBO0FDRUY7O0FEREU7RUFDRSxnQkFBQTtBQ0dKIiwiZmlsZSI6InNyYy9hcHAvYnVzaW5lc3MvZ2VvLWxhYmVsL3NpZ24vbGFiZWwtYWRkL2FkZC1jb250ZW50L2FkZC1jb250ZW50LmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsiLnRvcCB7XHJcbiAgcGFkZGluZzogMTZweDtcclxufVxyXG4uYm90dG9tIHtcclxuICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgZGlzcGxheTogZmxleDtcclxuICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XHJcbiAgaGVpZ2h0OiA0OHB4O1xyXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCAjZTVlNWU1O1xyXG4gIHBhZGRpbmctcmlnaHQ6IDE2cHg7XHJcbiAgYm90dG9tOiAwcHg7XHJcbiAgbGVmdDogMHB4O1xyXG4gIHdpZHRoOiAxMDAlO1xyXG4gIGJhY2tncm91bmQ6ICNmZmZmZmY7XHJcbiAgJiA+IDpudGgtY2hpbGQoMikge1xyXG4gICAgbWFyZ2luLWxlZnQ6IDhweDtcclxuICB9XHJcbn1cclxuIiwiLnRvcCB7XG4gIHBhZGRpbmc6IDE2cHg7XG59XG5cbi5ib3R0b20ge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XG4gIGhlaWdodDogNDhweDtcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNlNWU1ZTU7XG4gIHBhZGRpbmctcmlnaHQ6IDE2cHg7XG4gIGJvdHRvbTogMHB4O1xuICBsZWZ0OiAwcHg7XG4gIHdpZHRoOiAxMDAlO1xuICBiYWNrZ3JvdW5kOiAjZmZmZmZmO1xufVxuLmJvdHRvbSA+IDpudGgtY2hpbGQoMikge1xuICBtYXJnaW4tbGVmdDogOHB4O1xufSJdfQ== */"], changeDetection: 0 });
    return AddContentComponent;
}());

/*@__PURE__*/ (function () { _angular_core__WEBPACK_IMPORTED_MODULE_0__["setClassMetadata"](AddContentComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
                selector: 'lb-add-content',
                templateUrl: './add-content.component.html',
                styleUrls: ['./add-content.component.scss'],
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
            }]
    }], function () { return [{ type: _sign_component__WEBPACK_IMPORTED_MODULE_3__["SignComponent"] }, { type: _sign_service__WEBPACK_IMPORTED_MODULE_4__["SignService"] }, { type: ng_zorro_antd_message__WEBPACK_IMPORTED_MODULE_5__["NzMessageService"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] }, { type: _services_edit_tool_service__WEBPACK_IMPORTED_MODULE_6__["EditToolService"] }]; }, { isEdit: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }], tagId: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }], showEditToolEvent: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }], baseInfoComponent: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"],
            args: ['baseInfoComponent', { static: false }]
        }], labelFeatureComponent: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"],
            args: ['labelFeatureComponent', { static: false }]
        }], showDetail: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }], addSourceInfo: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }] }); })();


/***/ }),

/***/ "./src/app/business/geo-label/sign/label-add/base-info/base-info.component.ts":
/*!************************************************************************************!*\
  !*** ./src/app/business/geo-label/sign/label-add/base-info/base-info.component.ts ***!
  \************************************************************************************/
/*! exports provided: BaseInfoComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseInfoComponent", function() { return BaseInfoComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/__ivy_ngcc__/fesm5/core.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/__ivy_ngcc__/fesm5/forms.js");
/* harmony import */ var _sign_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../sign.service */ "./src/app/business/geo-label/sign/sign.service.ts");
/* harmony import */ var ng_zorro_antd_form__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ng-zorro-antd/form */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-form.js");
/* harmony import */ var ng_zorro_antd_grid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ng-zorro-antd/grid */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-grid.js");
/* harmony import */ var ng_zorro_antd_input__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ng-zorro-antd/input */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-input.js");
/* harmony import */ var ng_zorro_antd_radio__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ng-zorro-antd/radio */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-radio.js");
/* harmony import */ var ng_zorro_antd_cascader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ng-zorro-antd/cascader */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-cascader.js");
/* harmony import */ var _common_form_tag_form_tag_component__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../common/form-tag/form-tag.component */ "./src/app/business/geo-label/common/form-tag/form-tag.component.ts");











var _c0 = ["inputElement"];
var _c1 = function () { return { minRows: 3, maxRows: 3 }; };
var BaseInfoComponent = /** @class */ (function () {
    function BaseInfoComponent(fb, cdr, signService) {
        this.fb = fb;
        this.cdr = cdr;
        this.signService = signService;
        this.defaultValue = { "title": '', "ispublic": '1', "taginfos": [], "desc": '', categoryid: [] };
        this.baseInfo = null;
        this.classifyTree = [];
    }
    BaseInfoComponent.prototype.ngOnInit = function () {
        this.getClassifyTree();
    };
    BaseInfoComponent.prototype.submitForm = function () {
        for (var i in this.validateForm.controls) {
            this.validateForm.controls[i].markAsDirty();
            this.validateForm.controls[i].updateValueAndValidity();
        }
    };
    BaseInfoComponent.prototype.classifyNgModelChange = function (value) {
    };
    BaseInfoComponent.prototype.ngOnChanges = function (changes) {
        var _a = this.baseInfo || this.defaultValue, title = _a.title, ispublic = _a.ispublic, taginfos = _a.taginfos, desc = _a.desc, categoryid = _a.categoryid;
        this.validateForm = this.fb.group({
            title: [title, [_angular_forms__WEBPACK_IMPORTED_MODULE_1__["Validators"].required]],
            ispublic: [ispublic, [_angular_forms__WEBPACK_IMPORTED_MODULE_1__["Validators"].required]],
            categoryid: [categoryid, [_angular_forms__WEBPACK_IMPORTED_MODULE_1__["Validators"].required]],
            desc: [desc],
            taginfos: [taginfos,],
        });
    };
    BaseInfoComponent.prototype.getClassifyTree = function () {
        var _this = this;
        this.signService.getClassifyTree({ treeid: '' }).subscribe(function (result) {
            _this.classifyTree = JSON.parse(result.jsontree);
            ;
        });
    };
    BaseInfoComponent.fac = function BaseInfoComponent_Factory(t) { return new (t || BaseInfoComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](_angular_forms__WEBPACK_IMPORTED_MODULE_1__["FormBuilder"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](_sign_service__WEBPACK_IMPORTED_MODULE_2__["SignService"])); };
    BaseInfoComponent.cmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["defineComponent"]({ type: BaseInfoComponent, selectors: [["app-base-info"]], viewQuery: function BaseInfoComponent_Query(rf, ctx) { if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["viewQuery"](_c0, true);
        } if (rf & 2) {
            var _t;
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["queryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["loadQuery"]()) && (ctx.inputElement = _t.first);
        } }, inputs: { baseInfo: "baseInfo" }, features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["NgOnChangesFeature"]], decls: 31, vars: 17, consts: [[1, "container"], ["nz-form", "", 3, "formGroup", "ngSubmit"], ["nzRequired", "", "nzFor", "name", 3, "nzSpan"], ["nzErrorTip", "\u8BF7\u8F93\u5165\u540D\u79F0!", 3, "nzSpan"], ["nz-input", "", "formControlName", "title"], ["nzRequired", "", "nzFor", "", 3, "nzSpan"], ["nzErrorTip", "\u8BF7\u9009\u62E9\u516C\u5F00\u5EA6!", 3, "nzSpan"], ["id", "ispublic", "formControlName", "ispublic"], ["nz-radio", "", "nzValue", "1"], ["nz-radio", "", "nzValue", "0"], ["nzRequired", "", "nzFor", "classify", 3, "nzSpan"], ["nzErrorTip", "\u8BF7\u9009\u62E9\u5206\u7C7B!", 3, "nzSpan"], ["id", "categoryid", "formControlName", "categoryid", 3, "nzExpandTrigger", "nzOptions", "nzValueProperty", "nzLabelProperty", "ngModelChange"], ["nzFor", "tag", 3, "nzSpan"], [3, "nzSpan"], ["id", "taginfos", "formControlName", "taginfos"], ["nzFor", "desInfo", 3, "nzSpan"], ["nzErrorTip", "\u8BF7\u8F93\u5165\u63CF\u8FF0\u4FE1\u606F\uFF01!", 3, "nzSpan"], ["id", "desc", "nz-input", "", "formControlName", "desc", "placeholder", "\u8BF7\u8F93\u5165\u8BE5\u6807\u8BB0\u63CF\u8FF0\u4FE1\u606F", 3, "nzAutosize"]], template: function BaseInfoComponent_Template(rf, ctx) { if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](0, "div", 0);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](1, "form", 1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["listener"]("ngSubmit", function BaseInfoComponent_Template_form_ngSubmit_1_listener() { return ctx.submitForm(); });
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](2, "nz-form-item");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](3, "nz-form-label", 2);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](4, "\u540D\u79F0");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](5, "nz-form-control", 3);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["element"](6, "input", 4);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](7, "nz-form-item");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](8, "nz-form-label", 5);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](9, "\u516C\u5F00\u5EA6");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](10, "nz-form-control", 6);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](11, "nz-radio-group", 7);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](12, "label", 8);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](13, "\u516C\u5F00");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](14, "label", 9);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](15, "\u79C1\u6709");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](16, "nz-form-item");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](17, "nz-form-label", 10);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](18, "\u5206\u7C7B");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](19, "nz-form-control", 11);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](20, "nz-cascader", 12);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["listener"]("ngModelChange", function BaseInfoComponent_Template_nz_cascader_ngModelChange_20_listener($event) { return ctx.classifyNgModelChange($event); });
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](21, "nz-form-item");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](22, "nz-form-label", 13);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](23, "\u6807\u7B7E");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](24, "nz-form-control", 14);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["element"](25, "lb-form-tag", 15);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](26, "nz-form-item");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](27, "nz-form-label", 16);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](28, "\u63CF\u8FF0\u4FE1\u606F");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](29, "nz-form-control", 17);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["element"](30, "textarea", 18);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
        } if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("formGroup", ctx.validateForm);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](2);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("nzSpan", 6);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](2);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("nzSpan", 18);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](3);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("nzSpan", 6);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](2);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("nzSpan", 18);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](7);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("nzSpan", 6);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](2);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("nzSpan", 18);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("nzExpandTrigger", "hover")("nzOptions", ctx.classifyTree)("nzValueProperty", "nodeid")("nzLabelProperty", "title");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](2);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("nzSpan", 6);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](2);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("nzSpan", 18);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](3);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("nzSpan", 6);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](2);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("nzSpan", 18);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("nzAutosize", _angular_core__WEBPACK_IMPORTED_MODULE_0__["pureFunction0"](16, _c1));
        } }, directives: [_angular_forms__WEBPACK_IMPORTED_MODULE_1__["angular_packages_forms_forms_y"], _angular_forms__WEBPACK_IMPORTED_MODULE_1__["NgControlStatusGroup"], ng_zorro_antd_form__WEBPACK_IMPORTED_MODULE_3__["NzFormDirective"], _angular_forms__WEBPACK_IMPORTED_MODULE_1__["FormGroupDirective"], ng_zorro_antd_grid__WEBPACK_IMPORTED_MODULE_4__["NzRowDirective"], ng_zorro_antd_form__WEBPACK_IMPORTED_MODULE_3__["NzFormItemComponent"], ng_zorro_antd_grid__WEBPACK_IMPORTED_MODULE_4__["NzColDirective"], ng_zorro_antd_form__WEBPACK_IMPORTED_MODULE_3__["NzFormLabelComponent"], ng_zorro_antd_form__WEBPACK_IMPORTED_MODULE_3__["NzFormControlComponent"], ng_zorro_antd_input__WEBPACK_IMPORTED_MODULE_5__["NzInputDirective"], _angular_forms__WEBPACK_IMPORTED_MODULE_1__["DefaultValueAccessor"], _angular_forms__WEBPACK_IMPORTED_MODULE_1__["NgControlStatus"], _angular_forms__WEBPACK_IMPORTED_MODULE_1__["FormControlName"], ng_zorro_antd_radio__WEBPACK_IMPORTED_MODULE_6__["NzRadioGroupComponent"], ng_zorro_antd_radio__WEBPACK_IMPORTED_MODULE_6__["NzRadioComponent"], ng_zorro_antd_cascader__WEBPACK_IMPORTED_MODULE_7__["NzCascaderComponent"], _common_form_tag_form_tag_component__WEBPACK_IMPORTED_MODULE_8__["FormTagComponent"], ng_zorro_antd_input__WEBPACK_IMPORTED_MODULE_5__["NzAutosizeDirective"]], styles: [".container[_ngcontent-%COMP%] {\n  padding: 16px;\n}\n.container[_ngcontent-%COMP%]   .base-info-item[_ngcontent-%COMP%] {\n  margin-top: 16px;\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-direction: column;\n      flex-direction: column;\n}\n.container[_ngcontent-%COMP%]   .base-info-item[_ngcontent-%COMP%]    > label[_ngcontent-%COMP%] {\n  font-size: 14px;\n  color: #333333;\n  margin-bottom: 8px;\n}\n.container[_ngcontent-%COMP%]   .base-info-item[_ngcontent-%COMP%]    > label[_ngcontent-%COMP%]    > span[_ngcontent-%COMP%] {\n  color: red;\n}\n.container[_ngcontent-%COMP%]   .tags[_ngcontent-%COMP%] {\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-wrap: wrap;\n      flex-wrap: wrap;\n}\n.container[_ngcontent-%COMP%]   .item-tag[_ngcontent-%COMP%] {\n  margin-bottom: 8px;\n}\n.container[_ngcontent-%COMP%]   .editable-tag[_ngcontent-%COMP%] {\n  background: white;\n  border-style: dashed;\n  margin-bottom: 8px;\n  cursor: pointer;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAvYnVzaW5lc3MvZ2VvLWxhYmVsL3NpZ24vbGFiZWwtYWRkL2Jhc2UtaW5mby9FOlxcUHJvajIwMjBcXOepuumXtOi1hOa6kOaZuuaFp+euoeeQhlxcR2VvTGFiZWwvc3JjXFxhcHBcXGJ1c2luZXNzXFxnZW8tbGFiZWxcXHNpZ25cXGxhYmVsLWFkZFxcYmFzZS1pbmZvXFxiYXNlLWluZm8uY29tcG9uZW50LnNjc3MiLCJzcmMvYXBwL2J1c2luZXNzL2dlby1sYWJlbC9zaWduL2xhYmVsLWFkZC9iYXNlLWluZm8vYmFzZS1pbmZvLmNvbXBvbmVudC5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0VBQ0UsYUFBQTtBQ0NGO0FEQUU7RUFDRSxnQkFBQTtFQUNBLG9CQUFBO0VBQUEsYUFBQTtFQUNBLDBCQUFBO01BQUEsc0JBQUE7QUNFSjtBRERJO0VBQ0UsZUFBQTtFQUNBLGNBQUE7RUFDQSxrQkFBQTtBQ0dOO0FEREk7RUFDRSxVQUFBO0FDR047QURDRTtFQUNJLG9CQUFBO0VBQUEsYUFBQTtFQUNBLG1CQUFBO01BQUEsZUFBQTtBQ0NOO0FEQ0U7RUFDSSxrQkFBQTtBQ0NOO0FEQ0U7RUFDRSxpQkFBQTtFQUNBLG9CQUFBO0VBQ0Esa0JBQUE7RUFDQSxlQUFBO0FDQ0oiLCJmaWxlIjoic3JjL2FwcC9idXNpbmVzcy9nZW8tbGFiZWwvc2lnbi9sYWJlbC1hZGQvYmFzZS1pbmZvL2Jhc2UtaW5mby5jb21wb25lbnQuc2NzcyIsInNvdXJjZXNDb250ZW50IjpbIi5jb250YWluZXIge1xyXG4gIHBhZGRpbmc6IDE2cHggICA7XHJcbiAgLmJhc2UtaW5mby1pdGVtIHtcclxuICAgIG1hcmdpbi10b3A6IDE2cHg7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcclxuICAgICYgPiBsYWJlbCB7XHJcbiAgICAgIGZvbnQtc2l6ZTogMTRweDtcclxuICAgICAgY29sb3I6ICMzMzMzMzM7XHJcbiAgICAgIG1hcmdpbi1ib3R0b206IDhweDtcclxuICAgIH1cclxuICAgICYgPiBsYWJlbCA+IHNwYW4ge1xyXG4gICAgICBjb2xvcjogcmVkO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLnRhZ3N7XHJcbiAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgIGZsZXgtd3JhcDogd3JhcDtcclxuICB9XHJcbiAgLml0ZW0tdGFne1xyXG4gICAgICBtYXJnaW4tYm90dG9tOiA4cHg7XHJcbiAgfVxyXG4gIC5lZGl0YWJsZS10YWcge1xyXG4gICAgYmFja2dyb3VuZDogcmdiKDI1NSwgMjU1LCAyNTUpO1xyXG4gICAgYm9yZGVyLXN0eWxlOiBkYXNoZWQ7XHJcbiAgICBtYXJnaW4tYm90dG9tOiA4cHg7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgfVxyXG59XHJcbiIsIi5jb250YWluZXIge1xuICBwYWRkaW5nOiAxNnB4O1xufVxuLmNvbnRhaW5lciAuYmFzZS1pbmZvLWl0ZW0ge1xuICBtYXJnaW4tdG9wOiAxNnB4O1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xufVxuLmNvbnRhaW5lciAuYmFzZS1pbmZvLWl0ZW0gPiBsYWJlbCB7XG4gIGZvbnQtc2l6ZTogMTRweDtcbiAgY29sb3I6ICMzMzMzMzM7XG4gIG1hcmdpbi1ib3R0b206IDhweDtcbn1cbi5jb250YWluZXIgLmJhc2UtaW5mby1pdGVtID4gbGFiZWwgPiBzcGFuIHtcbiAgY29sb3I6IHJlZDtcbn1cbi5jb250YWluZXIgLnRhZ3Mge1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LXdyYXA6IHdyYXA7XG59XG4uY29udGFpbmVyIC5pdGVtLXRhZyB7XG4gIG1hcmdpbi1ib3R0b206IDhweDtcbn1cbi5jb250YWluZXIgLmVkaXRhYmxlLXRhZyB7XG4gIGJhY2tncm91bmQ6IHdoaXRlO1xuICBib3JkZXItc3R5bGU6IGRhc2hlZDtcbiAgbWFyZ2luLWJvdHRvbTogOHB4O1xuICBjdXJzb3I6IHBvaW50ZXI7XG59Il19 */"], changeDetection: 0 });
    return BaseInfoComponent;
}());

/*@__PURE__*/ (function () { _angular_core__WEBPACK_IMPORTED_MODULE_0__["setClassMetadata"](BaseInfoComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
                selector: 'app-base-info',
                templateUrl: './base-info.component.html',
                styleUrls: ['./base-info.component.scss'],
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush
            }]
    }], function () { return [{ type: _angular_forms__WEBPACK_IMPORTED_MODULE_1__["FormBuilder"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] }, { type: _sign_service__WEBPACK_IMPORTED_MODULE_2__["SignService"] }]; }, { baseInfo: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }], inputElement: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"],
            args: ['inputElement', { static: false }]
        }] }); })();


/***/ }),

/***/ "./src/app/business/geo-label/sign/label-add/label-add.component.ts":
/*!**************************************************************************!*\
  !*** ./src/app/business/geo-label/sign/label-add/label-add.component.ts ***!
  \**************************************************************************/
/*! exports provided: LabelAddComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LabelAddComponent", function() { return LabelAddComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/__ivy_ngcc__/fesm5/core.js");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/__ivy_ngcc__/fesm5/common.js");
/* harmony import */ var _common_label_container_label_container_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/label-container/label-container.component */ "./src/app/business/geo-label/common/label-container/label-container.component.ts");
/* harmony import */ var _add_content_add_content_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./add-content/add-content.component */ "./src/app/business/geo-label/sign/label-add/add-content/add-content.component.ts");





function LabelAddComponent_app_label_container_1_Template(rf, ctx) { if (rf & 1) {
    var _r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["getCurrentView"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](0, "app-label-container", 2);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["listener"]("closed", function LabelAddComponent_app_label_container_1_Template_app_label_container_closed_0_listener() { _angular_core__WEBPACK_IMPORTED_MODULE_0__["restoreView"](_r2); var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](); return ctx_r1.closeContainer(); });
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementContainerStart"](1, 3);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](2, " \u6DFB\u52A0\u6807\u8BB0 ");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementContainerEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementContainerStart"](3, 4);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["element"](4, "lb-add-content");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementContainerEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
} if (rf & 2) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("closeble", false)("toggleble", false);
} }
var LabelAddComponent = /** @class */ (function () {
    function LabelAddComponent() {
        this.isOpen = true;
    }
    LabelAddComponent.prototype.closeContainer = function () {
        this.isOpen = false;
    };
    LabelAddComponent.prototype.ngOnInit = function () {
    };
    LabelAddComponent.fac = function LabelAddComponent_Factory(t) { return new (t || LabelAddComponent)(); };
    LabelAddComponent.cmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["defineComponent"]({ type: LabelAddComponent, selectors: [["app-label-add"]], decls: 2, vars: 1, consts: [[1, "editmark"], [3, "closeble", "toggleble", "closed", 4, "ngIf"], [3, "closeble", "toggleble", "closed"], ["name", "header"], ["name", "content"]], template: function LabelAddComponent_Template(rf, ctx) { if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](0, "div", 0);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](1, LabelAddComponent_app_label_container_1_Template, 5, 2, "app-label-container", 1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
        } if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngIf", ctx.isOpen);
        } }, directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["NgIf"], _common_label_container_label_container_component__WEBPACK_IMPORTED_MODULE_2__["LabelContainerComponent"], _add_content_add_content_component__WEBPACK_IMPORTED_MODULE_3__["AddContentComponent"]], styles: [".editmark[_ngcontent-%COMP%] {\n  width: 380px;\n  height: 100%;\n}\n\napp-label-container[_ngcontent-%COMP%] {\n  height: 100%;\n  background: #ffffff;\n  position: relative;\n  display: block;\n  box-shadow: 0px 1px 10px rgba(0, 0, 0, 0.1);\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAvYnVzaW5lc3MvZ2VvLWxhYmVsL3NpZ24vbGFiZWwtYWRkL0U6XFxQcm9qMjAyMFxc56m66Ze06LWE5rqQ5pm65oWn566h55CGXFxHZW9MYWJlbC9zcmNcXGFwcFxcYnVzaW5lc3NcXGdlby1sYWJlbFxcc2lnblxcbGFiZWwtYWRkXFxsYWJlbC1hZGQuY29tcG9uZW50LnNjc3MiLCJzcmMvYXBwL2J1c2luZXNzL2dlby1sYWJlbC9zaWduL2xhYmVsLWFkZC9sYWJlbC1hZGQuY29tcG9uZW50LnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7RUFDRSxZQUFBO0VBQ0EsWUFBQTtBQ0NGOztBREVBO0VBRUUsWUFBQTtFQUNBLG1CQUFBO0VBQ0Esa0JBQUE7RUFDQSxjQUFBO0VBRUEsMkNBQUE7QUNERiIsImZpbGUiOiJzcmMvYXBwL2J1c2luZXNzL2dlby1sYWJlbC9zaWduL2xhYmVsLWFkZC9sYWJlbC1hZGQuY29tcG9uZW50LnNjc3MiLCJzb3VyY2VzQ29udGVudCI6WyIuZWRpdG1hcmsge1xyXG4gIHdpZHRoOiAzODBweDtcclxuICBoZWlnaHQ6IDEwMCU7XHJcbn1cclxuXHJcbmFwcC1sYWJlbC1jb250YWluZXIge1xyXG4gIC8vICAgICB3aWR0aDoxMDAlO1xyXG4gIGhlaWdodDogMTAwJTtcclxuICBiYWNrZ3JvdW5kOiAjZmZmZmZmO1xyXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICBkaXNwbGF5OiBibG9jaztcclxuXHJcbiAgYm94LXNoYWRvdzogMHB4IDFweCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4xKTtcclxuXHJcbn1cclxuIiwiLmVkaXRtYXJrIHtcbiAgd2lkdGg6IDM4MHB4O1xuICBoZWlnaHQ6IDEwMCU7XG59XG5cbmFwcC1sYWJlbC1jb250YWluZXIge1xuICBoZWlnaHQ6IDEwMCU7XG4gIGJhY2tncm91bmQ6ICNmZmZmZmY7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgZGlzcGxheTogYmxvY2s7XG4gIGJveC1zaGFkb3c6IDBweCAxcHggMTBweCByZ2JhKDAsIDAsIDAsIDAuMSk7XG59Il19 */"], changeDetection: 0 });
    return LabelAddComponent;
}());

/*@__PURE__*/ (function () { _angular_core__WEBPACK_IMPORTED_MODULE_0__["setClassMetadata"](LabelAddComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
                selector: 'app-label-add',
                templateUrl: './label-add.component.html',
                styleUrls: ['./label-add.component.scss'],
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
            }]
    }], function () { return []; }, null); })();


/***/ }),

/***/ "./src/app/business/geo-label/sign/label-add/label-feature/addTagIcon.pipe.ts":
/*!************************************************************************************!*\
  !*** ./src/app/business/geo-label/sign/label-add/label-feature/addTagIcon.pipe.ts ***!
  \************************************************************************************/
/*! exports provided: AddTagIconPipe */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddTagIconPipe", function() { return AddTagIconPipe; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/__ivy_ngcc__/fesm5/core.js");


var AddTagIconPipe = /** @class */ (function () {
    function AddTagIconPipe() {
    }
    AddTagIconPipe.prototype.transform = function (value, args) {
        switch (args.toLocaleLowerCase()) {
            case 'point': // // 'Point' | 'LineString' | 'Polygon';
                return './assets/img/map/icon_detail_point.png';
            case 'linestring':
            case 'polyline':
                return './assets/img/map/icon_detail_line.png';
            case 'polygon':
                return './assets/img/map/icon_detail_rectangle.png';
            default:
                return './assets/img/map/icon_detail_rectangle.png';
        }
    };
    AddTagIconPipe.fac = function AddTagIconPipe_Factory(t) { return new (t || AddTagIconPipe)(); };
    AddTagIconPipe.pipe = _angular_core__WEBPACK_IMPORTED_MODULE_0__["definePipe"]({ name: "addTagIcon", type: AddTagIconPipe, pure: true });
    return AddTagIconPipe;
}());

/*@__PURE__*/ (function () { _angular_core__WEBPACK_IMPORTED_MODULE_0__["setClassMetadata"](AddTagIconPipe, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Pipe"],
        args: [{
                name: 'addTagIcon',
            }]
    }], null, null); })();


/***/ }),

/***/ "./src/app/business/geo-label/sign/label-add/label-feature/label-feature.component.ts":
/*!********************************************************************************************!*\
  !*** ./src/app/business/geo-label/sign/label-add/label-feature/label-feature.component.ts ***!
  \********************************************************************************************/
/*! exports provided: LabelFeatureComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LabelFeatureComponent", function() { return LabelFeatureComponent; });
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/__ivy_ngcc__/fesm5/common.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/__ivy_ngcc__/fesm5/core.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _services_edit_tool_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../services/edit-tool.service */ "./src/app/business/geo-label/sign/services/edit-tool.service.ts");
/* harmony import */ var _shared_components_cf_scroll_cf_scroll_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../../shared/components/cf-scroll/cf-scroll.component */ "./src/app/shared/components/cf-scroll/cf-scroll.component.ts");
/* harmony import */ var ng_zorro_antd_input__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ng-zorro-antd/input */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-input.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/__ivy_ngcc__/fesm5/forms.js");
/* harmony import */ var _addTagIcon_pipe__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./addTagIcon.pipe */ "./src/app/business/geo-label/sign/label-add/label-feature/addTagIcon.pipe.ts");










function LabelFeatureComponent_p_1_Template(rf, ctx) { if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementStart"](0, "p");
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["text"](1, " \u8BF7\u70B9\u51FB\u53F3\u4E0A\u65B9\u70B9\u3001\u7EBF\u3001\u9762\u3001\u5706\u6309\u94AE\u5728\u5730\u56FE\u4E0A\u7ED8\u5236\u3002 ");
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementEnd"]();
} }
var _c0 = function () { return { minRows: 2, maxRows: 6 }; };
function LabelFeatureComponent_div_4_Template(rf, ctx) { if (rf & 1) {
    var _r4 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["getCurrentView"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementStart"](0, "div", 4);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementStart"](1, "div", 5);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementStart"](2, "div", 6);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["element"](3, "img", 7);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["pipe"](4, "addTagIcon");
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementStart"](5, "input", 8);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["listener"]("ngModelChange", function LabelFeatureComponent_div_4_Template_input_ngModelChange_5_listener($event) { _angular_core__WEBPACK_IMPORTED_MODULE_1__["restoreView"](_r4); var item_r2 = ctx.$implicit; return item_r2.title = $event; });
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementStart"](6, "img", 9);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["listener"]("click", function LabelFeatureComponent_div_4_Template_img_click_6_listener() { _angular_core__WEBPACK_IMPORTED_MODULE_1__["restoreView"](_r4); var item_r2 = ctx.$implicit; var ctx_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_1__["nextContext"](); return ctx_r5.removeFeature(item_r2); });
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementStart"](7, "div", 10);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementStart"](8, "textarea", 11);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["listener"]("ngModelChange", function LabelFeatureComponent_div_4_Template_textarea_ngModelChange_8_listener($event) { _angular_core__WEBPACK_IMPORTED_MODULE_1__["restoreView"](_r4); var item_r2 = ctx.$implicit; return item_r2.des = $event; });
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementEnd"]();
} if (rf & 2) {
    var item_r2 = ctx.$implicit;
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["advance"](3);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["property"]("src", _angular_core__WEBPACK_IMPORTED_MODULE_1__["pipeBind2"](4, 4, item_r2.icon, item_r2.type), _angular_core__WEBPACK_IMPORTED_MODULE_1__["sanitizeUrl"]);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["advance"](2);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["property"]("ngModel", item_r2.title);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["advance"](3);
    _angular_core__WEBPACK_IMPORTED_MODULE_1__["property"]("ngModel", item_r2.des)("nzAutosize", _angular_core__WEBPACK_IMPORTED_MODULE_1__["pureFunction0"](7, _c0));
} }
var LabelFeatureComponent = /** @class */ (function () {
    function LabelFeatureComponent(editToolService, datePipe, changeDetectorRef) {
        this.editToolService = editToolService;
        this.datePipe = datePipe;
        this.changeDetectorRef = changeDetectorRef;
        this.features = [];
        this.addsub = null;
        this.editsub = null;
        this.deletesub = null;
    }
    LabelFeatureComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.addsub = this.editToolService.addFeature$.subscribe(function (feature) {
            var ttype = feature.geometry.type; // as 'Point' | 'LineString' | 'Polygon',
            _this.features.push({
                feature: feature,
                title: ttype + " - " + _this.datePipe.transform(new Date(), 'yyyy-MM-dd HH:mm:ss'),
                type: ttype,
                des: '',
                icon: '',
            });
            _this.changeDetectorRef.markForCheck();
        });
        this.editsub = this.editToolService.editFeature$.subscribe(function (feature) {
            var ttype = feature.geometry.type;
            _this.features.forEach(function (fItem) {
                if (fItem.feature.id === feature.id) {
                    fItem.feature = feature;
                    fItem.title = ttype + " - " + _this.datePipe.transform(new Date(), 'yyyy-MM-dd HH:mm:ss');
                }
            });
            _this.changeDetectorRef.markForCheck();
        });
        this.deletesub = this.editToolService.deleteFeature$.subscribe(function (feature) {
            Object(lodash__WEBPACK_IMPORTED_MODULE_2__["remove"])(_this.features, function (item) {
                return item.feature.id === feature.id;
            });
        });
    };
    LabelFeatureComponent.prototype.removeFeature = function (featureListItem) {
        this.editToolService.deleteFeature(featureListItem.feature);
    };
    LabelFeatureComponent.prototype.ngOnChanges = function (changes) {
        if (this.features) {
            // features 
            var features = this.features.map(function (item) { return item.feature; });
            this.editToolService.addFeatureToMap(features);
        }
    };
    LabelFeatureComponent.prototype.ngOnDestroy = function () {
        this.editsub && this.editsub.unsubscribe();
        this.addsub && this.addsub.unsubscribe();
        this.deletesub && this.deletesub.unsubscribe();
    };
    LabelFeatureComponent.fac = function LabelFeatureComponent_Factory(t) { return new (t || LabelFeatureComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["directiveInject"](_services_edit_tool_service__WEBPACK_IMPORTED_MODULE_3__["EditToolService"]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["directiveInject"](_angular_common__WEBPACK_IMPORTED_MODULE_0__["DatePipe"]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["directiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"])); };
    LabelFeatureComponent.cmp = _angular_core__WEBPACK_IMPORTED_MODULE_1__["defineComponent"]({ type: LabelFeatureComponent, selectors: [["app-label-feature"]], inputs: { features: "features" }, features: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ProvidersFeature"]([_angular_common__WEBPACK_IMPORTED_MODULE_0__["DatePipe"]]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgOnChangesFeature"]], decls: 5, vars: 2, consts: [[1, "container"], [4, "ngIf"], [1, "content"], ["class", "item", 4, "ngFor", "ngForOf"], [1, "item"], [1, "top"], [1, "top-left"], [3, "src"], ["nz-input", "", "placeholder", "", 2, "width", "280px", "height", "32px", 3, "ngModel", "ngModelChange"], ["src", "./assets/img/map/icon_detail_delete.png", 3, "click"], [1, "bottom"], ["nz-input", "", 3, "ngModel", "nzAutosize", "ngModelChange"]], template: function LabelFeatureComponent_Template(rf, ctx) { if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementStart"](0, "div", 0);
            _angular_core__WEBPACK_IMPORTED_MODULE_1__["template"](1, LabelFeatureComponent_p_1_Template, 2, 0, "p", 1);
            _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementStart"](2, "app-cf-scroll");
            _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementStart"](3, "div", 2);
            _angular_core__WEBPACK_IMPORTED_MODULE_1__["template"](4, LabelFeatureComponent_div_4_Template, 9, 8, "div", 3);
            _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_1__["elementEnd"]();
        } if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_1__["advance"](1);
            _angular_core__WEBPACK_IMPORTED_MODULE_1__["property"]("ngIf", ctx.features.length <= 0);
            _angular_core__WEBPACK_IMPORTED_MODULE_1__["advance"](3);
            _angular_core__WEBPACK_IMPORTED_MODULE_1__["property"]("ngForOf", ctx.features);
        } }, directives: [_angular_common__WEBPACK_IMPORTED_MODULE_0__["NgIf"], _shared_components_cf_scroll_cf_scroll_component__WEBPACK_IMPORTED_MODULE_4__["CfScrollComponent"], _angular_common__WEBPACK_IMPORTED_MODULE_0__["NgForOf"], ng_zorro_antd_input__WEBPACK_IMPORTED_MODULE_5__["NzInputDirective"], _angular_forms__WEBPACK_IMPORTED_MODULE_6__["DefaultValueAccessor"], _angular_forms__WEBPACK_IMPORTED_MODULE_6__["NgControlStatus"], _angular_forms__WEBPACK_IMPORTED_MODULE_6__["NgModel"], ng_zorro_antd_input__WEBPACK_IMPORTED_MODULE_5__["NzAutosizeDirective"]], pipes: [_addTagIcon_pipe__WEBPACK_IMPORTED_MODULE_7__["AddTagIconPipe"]], styles: [".container[_ngcontent-%COMP%]   p[_ngcontent-%COMP%] {\n  margin-top: 16px;\n}\n.container[_ngcontent-%COMP%]   app-cf-scroll[_ngcontent-%COMP%] {\n  display: block;\n  height: 600px;\n  position: relative;\n  overflow: auto;\n}\n.container[_ngcontent-%COMP%]   app-cf-scroll[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%] {\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-direction: column;\n      flex-direction: column;\n}\n.container[_ngcontent-%COMP%]   app-cf-scroll[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%] {\n  margin-top: 16px;\n}\n.container[_ngcontent-%COMP%]   app-cf-scroll[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]   .top[_ngcontent-%COMP%] {\n  height: 32px;\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-align: center;\n      align-items: center;\n  -ms-flex-pack: justify;\n      justify-content: space-between;\n}\n.container[_ngcontent-%COMP%]   app-cf-scroll[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]   .top[_ngcontent-%COMP%]   .top-left[_ngcontent-%COMP%]   img[_ngcontent-%COMP%] {\n  margin-right: 5px;\n}\n.container[_ngcontent-%COMP%]   app-cf-scroll[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]   .top[_ngcontent-%COMP%]   img[_ngcontent-%COMP%] {\n  cursor: pointer;\n}\n.container[_ngcontent-%COMP%]   app-cf-scroll[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]   .bottom[_ngcontent-%COMP%] {\n  margin-top: 10px;\n  padding-left: 20px;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAvYnVzaW5lc3MvZ2VvLWxhYmVsL3NpZ24vbGFiZWwtYWRkL2xhYmVsLWZlYXR1cmUvRTpcXFByb2oyMDIwXFznqbrpl7TotYTmupDmmbrmhafnrqHnkIZcXEdlb0xhYmVsL3NyY1xcYXBwXFxidXNpbmVzc1xcZ2VvLWxhYmVsXFxzaWduXFxsYWJlbC1hZGRcXGxhYmVsLWZlYXR1cmVcXGxhYmVsLWZlYXR1cmUuY29tcG9uZW50LnNjc3MiLCJzcmMvYXBwL2J1c2luZXNzL2dlby1sYWJlbC9zaWduL2xhYmVsLWFkZC9sYWJlbC1mZWF0dXJlL2xhYmVsLWZlYXR1cmUuY29tcG9uZW50LnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0U7RUFDRSxnQkFBQTtBQ0FKO0FERUU7RUFDRSxjQUFBO0VBQ0EsYUFBQTtFQUNBLGtCQUFBO0VBQ0EsY0FBQTtBQ0FKO0FEQ0k7RUFDRSxvQkFBQTtFQUFBLGFBQUE7RUFDQSwwQkFBQTtNQUFBLHNCQUFBO0FDQ047QURBTTtFQUNFLGdCQUFBO0FDRVI7QUREUTtFQUNFLFlBQUE7RUFDQSxvQkFBQTtFQUFBLGFBQUE7RUFDQSxzQkFBQTtNQUFBLG1CQUFBO0VBQ0Esc0JBQUE7TUFBQSw4QkFBQTtBQ0dWO0FERFk7RUFDRSxpQkFBQTtBQ0dkO0FEQVU7RUFDRSxlQUFBO0FDRVo7QURDUTtFQUNFLGdCQUFBO0VBQ0Esa0JBQUE7QUNDViIsImZpbGUiOiJzcmMvYXBwL2J1c2luZXNzL2dlby1sYWJlbC9zaWduL2xhYmVsLWFkZC9sYWJlbC1mZWF0dXJlL2xhYmVsLWZlYXR1cmUuY29tcG9uZW50LnNjc3MiLCJzb3VyY2VzQ29udGVudCI6WyIuY29udGFpbmVye1xyXG4gIHB7XHJcbiAgICBtYXJnaW4tdG9wOiAxNnB4O1xyXG4gIH1cclxuICBhcHAtY2Ytc2Nyb2xsIHtcclxuICAgIGRpc3BsYXk6IGJsb2NrO1xyXG4gICAgaGVpZ2h0OiA2MDBweDtcclxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgIG92ZXJmbG93OiBhdXRvO1xyXG4gICAgLmNvbnRlbnR7XHJcbiAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XHJcbiAgICAgIC5pdGVte1xyXG4gICAgICAgIG1hcmdpbi10b3A6IDE2cHg7XHJcbiAgICAgICAgLnRvcHtcclxuICAgICAgICAgIGhlaWdodDogMzJweDtcclxuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gICAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xyXG4gICAgICAgICAgLnRvcC1sZWZ0e1xyXG4gICAgICAgICAgICBpbWd7XHJcbiAgICAgICAgICAgICAgbWFyZ2luLXJpZ2h0OiA1cHg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGltZ3tcclxuICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAuYm90dG9te1xyXG4gICAgICAgICAgbWFyZ2luLXRvcDogMTBweDtcclxuICAgICAgICAgIHBhZGRpbmctbGVmdDogMjBweDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG59XHJcbiIsIi5jb250YWluZXIgcCB7XG4gIG1hcmdpbi10b3A6IDE2cHg7XG59XG4uY29udGFpbmVyIGFwcC1jZi1zY3JvbGwge1xuICBkaXNwbGF5OiBibG9jaztcbiAgaGVpZ2h0OiA2MDBweDtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBvdmVyZmxvdzogYXV0bztcbn1cbi5jb250YWluZXIgYXBwLWNmLXNjcm9sbCAuY29udGVudCB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG59XG4uY29udGFpbmVyIGFwcC1jZi1zY3JvbGwgLmNvbnRlbnQgLml0ZW0ge1xuICBtYXJnaW4tdG9wOiAxNnB4O1xufVxuLmNvbnRhaW5lciBhcHAtY2Ytc2Nyb2xsIC5jb250ZW50IC5pdGVtIC50b3Age1xuICBoZWlnaHQ6IDMycHg7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2Vlbjtcbn1cbi5jb250YWluZXIgYXBwLWNmLXNjcm9sbCAuY29udGVudCAuaXRlbSAudG9wIC50b3AtbGVmdCBpbWcge1xuICBtYXJnaW4tcmlnaHQ6IDVweDtcbn1cbi5jb250YWluZXIgYXBwLWNmLXNjcm9sbCAuY29udGVudCAuaXRlbSAudG9wIGltZyB7XG4gIGN1cnNvcjogcG9pbnRlcjtcbn1cbi5jb250YWluZXIgYXBwLWNmLXNjcm9sbCAuY29udGVudCAuaXRlbSAuYm90dG9tIHtcbiAgbWFyZ2luLXRvcDogMTBweDtcbiAgcGFkZGluZy1sZWZ0OiAyMHB4O1xufSJdfQ== */"], changeDetection: 0 });
    return LabelFeatureComponent;
}());

/*@__PURE__*/ (function () { _angular_core__WEBPACK_IMPORTED_MODULE_1__["setClassMetadata"](LabelFeatureComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"],
        args: [{
                selector: 'app-label-feature',
                templateUrl: './label-feature.component.html',
                styleUrls: ['./label-feature.component.scss'],
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                providers: [_angular_common__WEBPACK_IMPORTED_MODULE_0__["DatePipe"]],
            }]
    }], function () { return [{ type: _services_edit_tool_service__WEBPACK_IMPORTED_MODULE_3__["EditToolService"] }, { type: _angular_common__WEBPACK_IMPORTED_MODULE_0__["DatePipe"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] }]; }, { features: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }] }); })();


/***/ }),

/***/ "./src/app/business/geo-label/sign/label-add/label-success/label-success.component.ts":
/*!********************************************************************************************!*\
  !*** ./src/app/business/geo-label/sign/label-add/label-success/label-success.component.ts ***!
  \********************************************************************************************/
/*! exports provided: LabelSuccessComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LabelSuccessComponent", function() { return LabelSuccessComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/__ivy_ngcc__/fesm5/core.js");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/__ivy_ngcc__/fesm5/common.js");
/* harmony import */ var ng_zorro_antd_button__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ng-zorro-antd/button */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-button.js");
/* harmony import */ var ng_zorro_antd_core_wave__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ng-zorro-antd/core/wave */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-core-wave.js");
/* harmony import */ var ng_zorro_antd_core_transition_patch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ng-zorro-antd/core/transition-patch */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-core-transition-patch.js");






function LabelSuccessComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementContainerStart"](0);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["element"](1, "img", 6);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](2, "span", 7);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](3, " \u65B0\u5EFA\u6807\u8BB0\u6210\u529F ");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementContainerEnd"]();
} }
function LabelSuccessComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementContainerStart"](0);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["element"](1, "img", 8);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](2, "span", 7);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](3, " \u65B0\u5EFA\u6807\u8BB0\u5931\u8D25 ");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementContainerEnd"]();
} }
var LabelSuccessComponent = /** @class */ (function () {
    function LabelSuccessComponent() {
        this.addTagSuccess = false;
        this.createAgainEmit = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.viewDetailEmit = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
    }
    LabelSuccessComponent.prototype.ngOnInit = function () {
    };
    LabelSuccessComponent.prototype.viewDetail = function () {
        this.viewDetailEmit.emit();
    };
    LabelSuccessComponent.prototype.createAgain = function () {
        this.createAgainEmit.emit();
    };
    LabelSuccessComponent.fac = function LabelSuccessComponent_Factory(t) { return new (t || LabelSuccessComponent)(); };
    LabelSuccessComponent.cmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["defineComponent"]({ type: LabelSuccessComponent, selectors: [["app-label-success"]], inputs: { addTagSuccess: "addTagSuccess" }, outputs: { createAgainEmit: "createAgainEmit", viewDetailEmit: "viewDetailEmit" }, decls: 9, vars: 2, consts: [[1, "container"], [1, "top"], [4, "ngIf"], [1, "bottom"], ["nz-button", "", "nzType", "primary", 3, "click"], ["nz-button", "", "nzType", "default", 3, "click"], ["src", "./assets/img/map/img_detail_success.png"], [1, "success"], ["src", "./assets/img/map/img_detail_fail.png"]], template: function LabelSuccessComponent_Template(rf, ctx) { if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](0, "div", 0);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](1, "div", 1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](2, LabelSuccessComponent_ng_container_2_Template, 4, 0, "ng-container", 2);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](3, LabelSuccessComponent_ng_container_3_Template, 4, 0, "ng-container", 2);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](4, "div", 3);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](5, "button", 4);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["listener"]("click", function LabelSuccessComponent_Template_button_click_5_listener() { return ctx.viewDetail(); });
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](6, "\u67E5\u770B\u6807\u8BB0");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](7, "button", 5);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["listener"]("click", function LabelSuccessComponent_Template_button_click_7_listener() { return ctx.createAgain(); });
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](8, "\u518D\u6B21\u65B0\u5EFA");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
        } if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](2);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngIf", ctx.addTagSuccess);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngIf", !ctx.addTagSuccess);
        } }, directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["NgIf"], ng_zorro_antd_button__WEBPACK_IMPORTED_MODULE_2__["NzButtonComponent"], ng_zorro_antd_core_wave__WEBPACK_IMPORTED_MODULE_3__["NzWaveDirective"], ng_zorro_antd_core_transition_patch__WEBPACK_IMPORTED_MODULE_4__["NzTransitionPatchDirective"]], styles: [".container[_ngcontent-%COMP%] {\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-direction: column;\n      flex-direction: column;\n  -ms-flex-align: center;\n      align-items: center;\n  -ms-flex-pack: center;\n      justify-content: center;\n  height: 50vh;\n}\n.container[_ngcontent-%COMP%]   .top[_ngcontent-%COMP%] {\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-direction: column;\n      flex-direction: column;\n  -ms-flex-align: center;\n      align-items: center;\n}\n.container[_ngcontent-%COMP%]   .top[_ngcontent-%COMP%]   img[_ngcontent-%COMP%] {\n  width: 60px;\n  height: 60px;\n}\n.container[_ngcontent-%COMP%]   .top[_ngcontent-%COMP%]   .success[_ngcontent-%COMP%] {\n  font-size: 16px;\n  font-weight: bold;\n  font-family: Microsoft YaHei;\n}\n.container[_ngcontent-%COMP%]   .bottom[_ngcontent-%COMP%] {\n  display: -ms-flexbox;\n  display: flex;\n  margin-top: 20px;\n}\n.container[_ngcontent-%COMP%]   .bottom[_ngcontent-%COMP%]   .success[_ngcontent-%COMP%] {\n  font-size: 16px;\n  font-weight: bold;\n}\n.container[_ngcontent-%COMP%]   .bottom[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:first-child {\n  margin-right: 10px;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAvYnVzaW5lc3MvZ2VvLWxhYmVsL3NpZ24vbGFiZWwtYWRkL2xhYmVsLXN1Y2Nlc3MvRTpcXFByb2oyMDIwXFznqbrpl7TotYTmupDmmbrmhafnrqHnkIZcXEdlb0xhYmVsL3NyY1xcYXBwXFxidXNpbmVzc1xcZ2VvLWxhYmVsXFxzaWduXFxsYWJlbC1hZGRcXGxhYmVsLXN1Y2Nlc3NcXGxhYmVsLXN1Y2Nlc3MuY29tcG9uZW50LnNjc3MiLCJzcmMvYXBwL2J1c2luZXNzL2dlby1sYWJlbC9zaWduL2xhYmVsLWFkZC9sYWJlbC1zdWNjZXNzL2xhYmVsLXN1Y2Nlc3MuY29tcG9uZW50LnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7RUFDSSxvQkFBQTtFQUFBLGFBQUE7RUFDQSwwQkFBQTtNQUFBLHNCQUFBO0VBQ0Esc0JBQUE7TUFBQSxtQkFBQTtFQUNBLHFCQUFBO01BQUEsdUJBQUE7RUFDQSxZQUFBO0FDQ0o7QURBSTtFQUNFLG9CQUFBO0VBQUEsYUFBQTtFQUNBLDBCQUFBO01BQUEsc0JBQUE7RUFDQSxzQkFBQTtNQUFBLG1CQUFBO0FDRU47QURETTtFQUNFLFdBQUE7RUFDQSxZQUFBO0FDR1I7QURETTtFQUNFLGVBQUE7RUFDQSxpQkFBQTtFQUNBLDRCQUFBO0FDR1I7QURBSTtFQUNJLG9CQUFBO0VBQUEsYUFBQTtFQUNBLGdCQUFBO0FDRVI7QUREUTtFQUNJLGVBQUE7RUFDQSxpQkFBQTtBQ0daO0FERFE7RUFDRSxrQkFBQTtBQ0dWIiwiZmlsZSI6InNyYy9hcHAvYnVzaW5lc3MvZ2VvLWxhYmVsL3NpZ24vbGFiZWwtYWRkL2xhYmVsLXN1Y2Nlc3MvbGFiZWwtc3VjY2Vzcy5jb21wb25lbnQuc2NzcyIsInNvdXJjZXNDb250ZW50IjpbIi5jb250YWluZXJ7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcclxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcclxuICAgIGhlaWdodDogIDUwdmg7XHJcbiAgICAudG9we1xyXG4gICAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xyXG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gICAgICBpbWd7XHJcbiAgICAgICAgd2lkdGg6IDYwcHg7XHJcbiAgICAgICAgaGVpZ2h0OiA2MHB4O1xyXG4gICAgICB9XHJcbiAgICAgIC5zdWNjZXNze1xyXG4gICAgICAgIGZvbnQtc2l6ZTogMTZweDtcclxuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcclxuICAgICAgICBmb250LWZhbWlseTogTWljcm9zb2Z0IFlhSGVpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAuYm90dG9te1xyXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgICAgbWFyZ2luLXRvcDogMjBweDtcclxuICAgICAgICAuc3VjY2Vzc3tcclxuICAgICAgICAgICAgZm9udC1zaXplOiAxNnB4O1xyXG4gICAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnV0dG9uOmZpcnN0LWNoaWxke1xyXG4gICAgICAgICAgbWFyZ2luLXJpZ2h0OiAxMHB4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG59XHJcbiIsIi5jb250YWluZXIge1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgaGVpZ2h0OiA1MHZoO1xufVxuLmNvbnRhaW5lciAudG9wIHtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cbi5jb250YWluZXIgLnRvcCBpbWcge1xuICB3aWR0aDogNjBweDtcbiAgaGVpZ2h0OiA2MHB4O1xufVxuLmNvbnRhaW5lciAudG9wIC5zdWNjZXNzIHtcbiAgZm9udC1zaXplOiAxNnB4O1xuICBmb250LXdlaWdodDogYm9sZDtcbiAgZm9udC1mYW1pbHk6IE1pY3Jvc29mdCBZYUhlaTtcbn1cbi5jb250YWluZXIgLmJvdHRvbSB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIG1hcmdpbi10b3A6IDIwcHg7XG59XG4uY29udGFpbmVyIC5ib3R0b20gLnN1Y2Nlc3Mge1xuICBmb250LXNpemU6IDE2cHg7XG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xufVxuLmNvbnRhaW5lciAuYm90dG9tIGJ1dHRvbjpmaXJzdC1jaGlsZCB7XG4gIG1hcmdpbi1yaWdodDogMTBweDtcbn0iXX0= */"], changeDetection: 0 });
    return LabelSuccessComponent;
}());

/*@__PURE__*/ (function () { _angular_core__WEBPACK_IMPORTED_MODULE_0__["setClassMetadata"](LabelSuccessComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
                selector: 'app-label-success',
                templateUrl: './label-success.component.html',
                styleUrls: ['./label-success.component.scss'],
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
            }]
    }], function () { return []; }, { addTagSuccess: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }], createAgainEmit: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }], viewDetailEmit: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }] }); })();


/***/ }),

/***/ "./src/app/business/geo-label/sign/label-detail/feature-detail/feature-detail.component.ts":
/*!*************************************************************************************************!*\
  !*** ./src/app/business/geo-label/sign/label-detail/feature-detail/feature-detail.component.ts ***!
  \*************************************************************************************************/
/*! exports provided: FeatureDetailComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FeatureDetailComponent", function() { return FeatureDetailComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/__ivy_ngcc__/fesm5/core.js");
/* harmony import */ var _utils_main_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/main-format */ "./src/app/business/geo-label/utils/main-format.ts");
/* harmony import */ var _cityfun_mapbox_map_service_mapboxmap_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../cityfun/mapbox-map/service/mapboxmap.service */ "./src/app/cityfun/mapbox-map/service/mapboxmap.service.ts");
/* harmony import */ var _common_tag_title_tag_title_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/tag-title/tag-title.component */ "./src/app/business/geo-label/common/tag-title/tag-title.component.ts");
/* harmony import */ var _shared_components_cf_scroll_cf_scroll_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../../shared/components/cf-scroll/cf-scroll.component */ "./src/app/shared/components/cf-scroll/cf-scroll.component.ts");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/__ivy_ngcc__/fesm5/common.js");
/* harmony import */ var _label_add_label_feature_addTagIcon_pipe__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../label-add/label-feature/addTagIcon.pipe */ "./src/app/business/geo-label/sign/label-add/label-feature/addTagIcon.pipe.ts");








function FeatureDetailComponent_div_5_Template(rf, ctx) { if (rf & 1) {
    var _r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["getCurrentView"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](0, "div", 3);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["listener"]("click", function FeatureDetailComponent_div_5_Template_div_click_0_listener() { _angular_core__WEBPACK_IMPORTED_MODULE_0__["restoreView"](_r3); var item_r1 = ctx.$implicit; var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](); return ctx_r2.featureItemClick(item_r1); });
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](1, "div", 4);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["element"](2, "img", 5);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["pipe"](3, "addTagIcon");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](4, "span");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](5);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](6, "div", 6);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](7);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
} if (rf & 2) {
    var item_r1 = ctx.$implicit;
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](2);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("src", _angular_core__WEBPACK_IMPORTED_MODULE_0__["pipeBind2"](3, 3, item_r1.icon, item_r1.geotype), _angular_core__WEBPACK_IMPORTED_MODULE_0__["sanitizeUrl"]);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](3);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["textInterpolate"](item_r1.title);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](2);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["textInterpolate"](item_r1.desc || "\u6682\u65E0\u8BF4\u660E");
} }
var FeatureDetailComponent = /** @class */ (function () {
    function FeatureDetailComponent(mapboxmapService) {
        this.mapboxmapService = mapboxmapService;
        this.data = [];
        this.map = null;
    }
    FeatureDetailComponent.prototype.ngOnInit = function () {
    };
    FeatureDetailComponent.prototype.initMap = function (data) {
        this.removelayer();
        this.map = this.mapboxmapService.getMap();
        var geojson = Object(_utils_main_format__WEBPACK_IMPORTED_MODULE_1__["listWktToGeoJson"])(data, 'geom');
        this.map.addSource('height-tag-geo', { type: 'geojson', data: geojson, });
        this.map.addLayer({
            id: 'height-line',
            type: 'line',
            source: 'height-tag-geo',
            layout: {},
            filter: ['==', ['get', 'geotype'], "LineString"],
            paint: {
                'line-width': 2,
                'line-color': 'red',
            },
        });
        this.map.addLayer({
            id: 'height-circle',
            type: 'circle',
            source: 'height-tag-geo',
            layout: {},
            filter: ['==', ['get', 'geotype'], 'Point'],
            paint: {
                'circle-radius': 4,
                'circle-color': 'red',
            },
        });
        this.map.addLayer({
            id: 'height-polygon',
            type: 'fill',
            source: 'height-tag-geo',
            layout: {},
            filter: ['==', ['get', 'geotype'], 'Polygon'],
            paint: {
                'fill-color': 'red',
                'fill-opacity': 0.5,
            },
        });
    };
    FeatureDetailComponent.prototype.removelayer = function () {
        if (this.map) {
            this.map.removeLayer('height-line');
            this.map.removeLayer('height-circle');
            this.map.removeLayer('height-polygon');
            this.map.removeSource('height-tag-geo');
        }
    };
    FeatureDetailComponent.prototype.featureItemClick = function (item) {
        this.initMap([item]);
    };
    FeatureDetailComponent.prototype.ngOnDestroy = function () {
        this.removelayer();
    };
    FeatureDetailComponent.fac = function FeatureDetailComponent_Factory(t) { return new (t || FeatureDetailComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](_cityfun_mapbox_map_service_mapboxmap_service__WEBPACK_IMPORTED_MODULE_2__["MapboxmapService"])); };
    FeatureDetailComponent.cmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["defineComponent"]({ type: FeatureDetailComponent, selectors: [["lb-feature-detail"]], inputs: { data: "data" }, decls: 6, vars: 2, consts: [[1, "feature-info"], [1, "content"], ["class", "item", 3, "click", 4, "ngFor", "ngForOf"], [1, "item", 3, "click"], [1, "title"], [3, "src"], [1, "des"]], template: function FeatureDetailComponent_Template(rf, ctx) { if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](0, "div", 0);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](1, "lb-tag-title");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](2);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](3, "app-cf-scroll");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](4, "div", 1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](5, FeatureDetailComponent_div_5_Template, 8, 6, "div", 2);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
        } if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](2);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["textInterpolate1"](" \u6807\u8BB0\u8981\u7D20 | (", ctx.data.length, ")\u4E2A ");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](3);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngForOf", ctx.data);
        } }, directives: [_common_tag_title_tag_title_component__WEBPACK_IMPORTED_MODULE_3__["TagTitleComponent"], _shared_components_cf_scroll_cf_scroll_component__WEBPACK_IMPORTED_MODULE_4__["CfScrollComponent"], _angular_common__WEBPACK_IMPORTED_MODULE_5__["NgForOf"]], pipes: [_label_add_label_feature_addTagIcon_pipe__WEBPACK_IMPORTED_MODULE_6__["AddTagIconPipe"]], styles: [".feature-info[_ngcontent-%COMP%] {\n  padding: 0 16px;\n}\n.feature-info[_ngcontent-%COMP%]   app-cf-scroll[_ngcontent-%COMP%] {\n  display: block;\n  height: 350px;\n  position: relative;\n}\n.feature-info[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%] {\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-direction: column;\n      flex-direction: column;\n  font-size: 14px;\n}\n.feature-info[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%] {\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-direction: column;\n      flex-direction: column;\n  border-bottom: 1px solid #E5E5E5;\n  cursor: pointer;\n}\n.feature-info[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%] {\n  display: -ms-flexbox;\n  display: flex;\n  height: 40px;\n  place-items: center;\n}\n.feature-info[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]   img[_ngcontent-%COMP%] {\n  margin-right: 5px;\n  width: 16px;\n  height: 16px;\n}\n.feature-info[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]   .des[_ngcontent-%COMP%] {\n  color: #333333;\n  margin-left: 21px;\n  margin-bottom: 5px;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAvYnVzaW5lc3MvZ2VvLWxhYmVsL3NpZ24vbGFiZWwtZGV0YWlsL2ZlYXR1cmUtZGV0YWlsL0U6XFxQcm9qMjAyMFxc56m66Ze06LWE5rqQ5pm65oWn566h55CGXFxHZW9MYWJlbC9zcmNcXGFwcFxcYnVzaW5lc3NcXGdlby1sYWJlbFxcc2lnblxcbGFiZWwtZGV0YWlsXFxmZWF0dXJlLWRldGFpbFxcZmVhdHVyZS1kZXRhaWwuY29tcG9uZW50LnNjc3MiLCJzcmMvYXBwL2J1c2luZXNzL2dlby1sYWJlbC9zaWduL2xhYmVsLWRldGFpbC9mZWF0dXJlLWRldGFpbC9mZWF0dXJlLWRldGFpbC5jb21wb25lbnQuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtFQUNFLGVBQUE7QUNDRjtBREFFO0VBQ0UsY0FBQTtFQUNBLGFBQUE7RUFDQSxrQkFBQTtBQ0VKO0FEQUU7RUFDRSxvQkFBQTtFQUFBLGFBQUE7RUFDQSwwQkFBQTtNQUFBLHNCQUFBO0VBQ0EsZUFBQTtBQ0VKO0FEREk7RUFDRSxvQkFBQTtFQUFBLGFBQUE7RUFDQSwwQkFBQTtNQUFBLHNCQUFBO0VBQ0EsZ0NBQUE7RUFDQSxlQUFBO0FDR047QURGTTtFQUNFLG9CQUFBO0VBQUEsYUFBQTtFQUNBLFlBQUE7RUFDQSxtQkFBQTtBQ0lSO0FESFE7RUFDRSxpQkFBQTtFQUNBLFdBQUE7RUFDQSxZQUFBO0FDS1Y7QURGTTtFQUNFLGNBQUE7RUFDQSxpQkFBQTtFQUNBLGtCQUFBO0FDSVIiLCJmaWxlIjoic3JjL2FwcC9idXNpbmVzcy9nZW8tbGFiZWwvc2lnbi9sYWJlbC1kZXRhaWwvZmVhdHVyZS1kZXRhaWwvZmVhdHVyZS1kZXRhaWwuY29tcG9uZW50LnNjc3MiLCJzb3VyY2VzQ29udGVudCI6WyIuZmVhdHVyZS1pbmZve1xyXG4gIHBhZGRpbmc6IDAgMTZweDtcclxuICBhcHAtY2Ytc2Nyb2xsIHtcclxuICAgIGRpc3BsYXk6IGJsb2NrO1xyXG4gICAgaGVpZ2h0OiAzNTBweDtcclxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICB9XHJcbiAgLmNvbnRlbnR7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcclxuICAgIGZvbnQtc2l6ZTogMTRweDtcclxuICAgIC5pdGVte1xyXG4gICAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xyXG4gICAgICBib3JkZXItYm90dG9tOiAgMXB4IHNvbGlkICNFNUU1RTU7XHJcbiAgICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgICAgLnRpdGxle1xyXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgICAgaGVpZ2h0OiA0MHB4O1xyXG4gICAgICAgIHBsYWNlLWl0ZW1zOiBjZW50ZXI7XHJcbiAgICAgICAgaW1ne1xyXG4gICAgICAgICAgbWFyZ2luLXJpZ2h0OiA1cHg7XHJcbiAgICAgICAgICB3aWR0aDogMTZweDtcclxuICAgICAgICAgIGhlaWdodDogMTZweDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLmRlc3tcclxuICAgICAgICBjb2xvcjogIzMzMzMzMztcclxuICAgICAgICBtYXJnaW4tbGVmdDogMjFweDtcclxuICAgICAgICBtYXJnaW4tYm90dG9tOiA1cHg7XHJcbiAgICAgIH1cclxuXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsIi5mZWF0dXJlLWluZm8ge1xuICBwYWRkaW5nOiAwIDE2cHg7XG59XG4uZmVhdHVyZS1pbmZvIGFwcC1jZi1zY3JvbGwge1xuICBkaXNwbGF5OiBibG9jaztcbiAgaGVpZ2h0OiAzNTBweDtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xufVxuLmZlYXR1cmUtaW5mbyAuY29udGVudCB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIGZvbnQtc2l6ZTogMTRweDtcbn1cbi5mZWF0dXJlLWluZm8gLmNvbnRlbnQgLml0ZW0ge1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI0U1RTVFNTtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuLmZlYXR1cmUtaW5mbyAuY29udGVudCAuaXRlbSAudGl0bGUge1xuICBkaXNwbGF5OiBmbGV4O1xuICBoZWlnaHQ6IDQwcHg7XG4gIHBsYWNlLWl0ZW1zOiBjZW50ZXI7XG59XG4uZmVhdHVyZS1pbmZvIC5jb250ZW50IC5pdGVtIC50aXRsZSBpbWcge1xuICBtYXJnaW4tcmlnaHQ6IDVweDtcbiAgd2lkdGg6IDE2cHg7XG4gIGhlaWdodDogMTZweDtcbn1cbi5mZWF0dXJlLWluZm8gLmNvbnRlbnQgLml0ZW0gLmRlcyB7XG4gIGNvbG9yOiAjMzMzMzMzO1xuICBtYXJnaW4tbGVmdDogMjFweDtcbiAgbWFyZ2luLWJvdHRvbTogNXB4O1xufSJdfQ== */"], changeDetection: 0 });
    return FeatureDetailComponent;
}());

/*@__PURE__*/ (function () { _angular_core__WEBPACK_IMPORTED_MODULE_0__["setClassMetadata"](FeatureDetailComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
                selector: 'lb-feature-detail',
                templateUrl: './feature-detail.component.html',
                styleUrls: ['./feature-detail.component.scss'],
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush
            }]
    }], function () { return [{ type: _cityfun_mapbox_map_service_mapboxmap_service__WEBPACK_IMPORTED_MODULE_2__["MapboxmapService"] }]; }, { data: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }] }); })();


/***/ }),

/***/ "./src/app/business/geo-label/sign/label-detail/label-baseinfo/label-baseinfo.component.ts":
/*!*************************************************************************************************!*\
  !*** ./src/app/business/geo-label/sign/label-detail/label-baseinfo/label-baseinfo.component.ts ***!
  \*************************************************************************************************/
/*! exports provided: LabelBaseinfoComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LabelBaseinfoComponent", function() { return LabelBaseinfoComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/__ivy_ngcc__/fesm5/core.js");
/* harmony import */ var _common_tag_title_tag_title_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/tag-title/tag-title.component */ "./src/app/business/geo-label/common/tag-title/tag-title.component.ts");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/__ivy_ngcc__/fesm5/common.js");




function LabelBaseinfoComponent_span_1_Template(rf, ctx) { if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](0, "span");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](1, "\u516C\u5F00 | ");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
} }
function LabelBaseinfoComponent_span_2_Template(rf, ctx) { if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](0, "span");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](1, "\u79C1\u6709 | ");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
} }
var LabelBaseinfoComponent = /** @class */ (function () {
    function LabelBaseinfoComponent() {
        this.data = null;
    }
    LabelBaseinfoComponent.prototype.ngOnInit = function () {
    };
    LabelBaseinfoComponent.fac = function LabelBaseinfoComponent_Factory(t) { return new (t || LabelBaseinfoComponent)(); };
    LabelBaseinfoComponent.cmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["defineComponent"]({ type: LabelBaseinfoComponent, selectors: [["lb-label-baseinfo"]], inputs: { data: "data" }, decls: 31, vars: 8, consts: [[4, "ngIf"], [2, "margin-left", "3px"], [1, "content"], [1, "item"]], template: function LabelBaseinfoComponent_Template(rf, ctx) { if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](0, "lb-tag-title");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](1, LabelBaseinfoComponent_span_1_Template, 2, 0, "span", 0);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](2, LabelBaseinfoComponent_span_2_Template, 2, 0, "span", 0);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](3, "span", 1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](4);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](5, "div", 2);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](6, "div", 3);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](7, "span");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](8, "\u5206\u7C7B\uFF1A");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](9, "span");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](10);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](11, "div", 3);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](12, "span");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](13, "\u6807\u7B7E\uFF1A");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](14, "span");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](15);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](16, "div", 3);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](17, "span");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](18, "\u63CF\u8FF0\u4FE1\u606F\uFF1A");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](19, "span");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](20);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](21, "div", 3);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](22, "span");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](23, "\u521B\u5EFA\u4EBA\uFF1A");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](24, "span");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](25);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](26, "div", 3);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](27, "span");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](28, "\u521B\u5EFA\uFF1A");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](29, "span");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](30);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
        } if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngIf", ctx.data.ispublic);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngIf", !ctx.data.ispublic);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](2);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["textInterpolate"](ctx.data == null ? null : ctx.data.title);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](6);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["textInterpolate"](ctx.data == null ? null : ctx.data.categoryname);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](5);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["textInterpolate"](ctx.data == null ? null : ctx.data.taginfos);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](5);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["textInterpolate"](ctx.data == null ? null : ctx.data.desc);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](5);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["textInterpolate"](ctx.data == null ? null : ctx.data.createaccount);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](5);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["textInterpolate"](ctx.data == null ? null : ctx.data.createtime);
        } }, directives: [_common_tag_title_tag_title_component__WEBPACK_IMPORTED_MODULE_1__["TagTitleComponent"], _angular_common__WEBPACK_IMPORTED_MODULE_2__["NgIf"]], styles: [".content[_ngcontent-%COMP%] {\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-direction: column;\n      flex-direction: column;\n  font-size: 14px;\n}\n.content[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%] {\n  display: -ms-flexbox;\n  display: flex;\n  height: 30px;\n  -ms-flex-align: center;\n      align-items: center;\n  cursor: pointer;\n}\n.content[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]:first-child {\n  -ms-flex: 2;\n      flex: 2;\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-pack: end;\n      justify-content: flex-end;\n  color: #999999;\n}\n.content[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]:last-child {\n  -ms-flex: 5;\n      flex: 5;\n  font-weight: bold;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAvYnVzaW5lc3MvZ2VvLWxhYmVsL3NpZ24vbGFiZWwtZGV0YWlsL2xhYmVsLWJhc2VpbmZvL0U6XFxQcm9qMjAyMFxc56m66Ze06LWE5rqQ5pm65oWn566h55CGXFxHZW9MYWJlbC9zcmNcXGFwcFxcYnVzaW5lc3NcXGdlby1sYWJlbFxcc2lnblxcbGFiZWwtZGV0YWlsXFxsYWJlbC1iYXNlaW5mb1xcbGFiZWwtYmFzZWluZm8uY29tcG9uZW50LnNjc3MiLCJzcmMvYXBwL2J1c2luZXNzL2dlby1sYWJlbC9zaWduL2xhYmVsLWRldGFpbC9sYWJlbC1iYXNlaW5mby9sYWJlbC1iYXNlaW5mby5jb21wb25lbnQuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtFQUNFLG9CQUFBO0VBQUEsYUFBQTtFQUNBLDBCQUFBO01BQUEsc0JBQUE7RUFDQSxlQUFBO0FDQ0Y7QURBRTtFQUNFLG9CQUFBO0VBQUEsYUFBQTtFQUNBLFlBQUE7RUFDQSxzQkFBQTtNQUFBLG1CQUFBO0VBQ0EsZUFBQTtBQ0VKO0FEREk7RUFDRSxXQUFBO01BQUEsT0FBQTtFQUNBLG9CQUFBO0VBQUEsYUFBQTtFQUNBLGtCQUFBO01BQUEseUJBQUE7RUFDQSxjQUFBO0FDR047QURESTtFQUNFLFdBQUE7TUFBQSxPQUFBO0VBQ0EsaUJBQUE7QUNHTiIsImZpbGUiOiJzcmMvYXBwL2J1c2luZXNzL2dlby1sYWJlbC9zaWduL2xhYmVsLWRldGFpbC9sYWJlbC1iYXNlaW5mby9sYWJlbC1iYXNlaW5mby5jb21wb25lbnQuc2NzcyIsInNvdXJjZXNDb250ZW50IjpbIi5jb250ZW50e1xyXG4gIGRpc3BsYXk6IGZsZXg7XHJcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcclxuICBmb250LXNpemU6IDE0cHg7XHJcbiAgLml0ZW17XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgaGVpZ2h0OiAzMHB4O1xyXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgIHNwYW46Zmlyc3QtY2hpbGR7XHJcbiAgICAgIGZsZXg6IDI7XHJcbiAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgIGp1c3RpZnktY29udGVudDpmbGV4LWVuZDtcclxuICAgICAgY29sb3I6ICM5OTk5OTk7XHJcbiAgICB9XHJcbiAgICBzcGFuOmxhc3QtY2hpbGR7XHJcbiAgICAgIGZsZXg6IDU7XHJcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCIuY29udGVudCB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIGZvbnQtc2l6ZTogMTRweDtcbn1cbi5jb250ZW50IC5pdGVtIHtcbiAgZGlzcGxheTogZmxleDtcbiAgaGVpZ2h0OiAzMHB4O1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICBjdXJzb3I6IHBvaW50ZXI7XG59XG4uY29udGVudCAuaXRlbSBzcGFuOmZpcnN0LWNoaWxkIHtcbiAgZmxleDogMjtcbiAgZGlzcGxheTogZmxleDtcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcbiAgY29sb3I6ICM5OTk5OTk7XG59XG4uY29udGVudCAuaXRlbSBzcGFuOmxhc3QtY2hpbGQge1xuICBmbGV4OiA1O1xuICBmb250LXdlaWdodDogYm9sZDtcbn0iXX0= */"], changeDetection: 0 });
    return LabelBaseinfoComponent;
}());

/*@__PURE__*/ (function () { _angular_core__WEBPACK_IMPORTED_MODULE_0__["setClassMetadata"](LabelBaseinfoComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
                selector: 'lb-label-baseinfo',
                templateUrl: './label-baseinfo.component.html',
                styleUrls: ['./label-baseinfo.component.scss'],
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush
            }]
    }], function () { return []; }, { data: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }] }); })();


/***/ }),

/***/ "./src/app/business/geo-label/sign/label-detail/label-comment/label-comment.component.ts":
/*!***********************************************************************************************!*\
  !*** ./src/app/business/geo-label/sign/label-detail/label-comment/label-comment.component.ts ***!
  \***********************************************************************************************/
/*! exports provided: LabelCommentComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LabelCommentComponent", function() { return LabelCommentComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/__ivy_ngcc__/fesm5/core.js");
/* harmony import */ var _common_tag_title_tag_title_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../common/tag-title/tag-title.component */ "./src/app/business/geo-label/common/tag-title/tag-title.component.ts");



var LabelCommentComponent = /** @class */ (function () {
    function LabelCommentComponent() {
    }
    LabelCommentComponent.prototype.ngOnInit = function () {
    };
    LabelCommentComponent.fac = function LabelCommentComponent_Factory(t) { return new (t || LabelCommentComponent)(); };
    LabelCommentComponent.cmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["defineComponent"]({ type: LabelCommentComponent, selectors: [["lb-label-comment"]], decls: 3, vars: 0, consts: [[1, "comment"]], template: function LabelCommentComponent_Template(rf, ctx) { if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](0, "div", 0);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](1, "lb-tag-title");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](2, " \u8BC4\u8BBA\uFF080\u6761\uFF09 ");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
        } }, directives: [_common_tag_title_tag_title_component__WEBPACK_IMPORTED_MODULE_1__["TagTitleComponent"]], styles: [".comment[_ngcontent-%COMP%] {\n  padding: 0 16px;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAvYnVzaW5lc3MvZ2VvLWxhYmVsL3NpZ24vbGFiZWwtZGV0YWlsL2xhYmVsLWNvbW1lbnQvRTpcXFByb2oyMDIwXFznqbrpl7TotYTmupDmmbrmhafnrqHnkIZcXEdlb0xhYmVsL3NyY1xcYXBwXFxidXNpbmVzc1xcZ2VvLWxhYmVsXFxzaWduXFxsYWJlbC1kZXRhaWxcXGxhYmVsLWNvbW1lbnRcXGxhYmVsLWNvbW1lbnQuY29tcG9uZW50LnNjc3MiLCJzcmMvYXBwL2J1c2luZXNzL2dlby1sYWJlbC9zaWduL2xhYmVsLWRldGFpbC9sYWJlbC1jb21tZW50L2xhYmVsLWNvbW1lbnQuY29tcG9uZW50LnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7RUFDRSxlQUFBO0FDQ0YiLCJmaWxlIjoic3JjL2FwcC9idXNpbmVzcy9nZW8tbGFiZWwvc2lnbi9sYWJlbC1kZXRhaWwvbGFiZWwtY29tbWVudC9sYWJlbC1jb21tZW50LmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsiLmNvbW1lbnR7XHJcbiAgcGFkZGluZzogMCAxNnB4O1xyXG59XHJcbiIsIi5jb21tZW50IHtcbiAgcGFkZGluZzogMCAxNnB4O1xufSJdfQ== */"], changeDetection: 0 });
    return LabelCommentComponent;
}());

/*@__PURE__*/ (function () { _angular_core__WEBPACK_IMPORTED_MODULE_0__["setClassMetadata"](LabelCommentComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
                selector: 'lb-label-comment',
                templateUrl: './label-comment.component.html',
                styleUrls: ['./label-comment.component.scss'],
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush
            }]
    }], function () { return []; }, null); })();


/***/ }),

/***/ "./src/app/business/geo-label/sign/label-detail/label-detail-content/label-detail-content.component.ts":
/*!*************************************************************************************************************!*\
  !*** ./src/app/business/geo-label/sign/label-detail/label-detail-content/label-detail-content.component.ts ***!
  \*************************************************************************************************************/
/*! exports provided: LabelDetailContentComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LabelDetailContentComponent", function() { return LabelDetailContentComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/__ivy_ngcc__/fesm5/core.js");
/* harmony import */ var _utils_main_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/main-format */ "./src/app/business/geo-label/utils/main-format.ts");
/* harmony import */ var ng_zorro_antd__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ng-zorro-antd */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd.js");
/* harmony import */ var src_app_cityfun_mapbox_map_service_mapboxmap_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! src/app/cityfun/mapbox-map/service/mapboxmap.service */ "./src/app/cityfun/mapbox-map/service/mapboxmap.service.ts");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/__ivy_ngcc__/fesm5/common.js");
/* harmony import */ var ng_zorro_antd_button__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ng-zorro-antd/button */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-button.js");
/* harmony import */ var ng_zorro_antd_core_wave__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ng-zorro-antd/core/wave */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-core-wave.js");
/* harmony import */ var ng_zorro_antd_core_transition_patch__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ng-zorro-antd/core/transition-patch */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-core-transition-patch.js");
/* harmony import */ var ng_zorro_antd_icon__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ng-zorro-antd/icon */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-icon.js");
/* harmony import */ var ng_zorro_antd_popconfirm__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ng-zorro-antd/popconfirm */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-popconfirm.js");
/* harmony import */ var _label_baseinfo_label_baseinfo_component__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../label-baseinfo/label-baseinfo.component */ "./src/app/business/geo-label/sign/label-detail/label-baseinfo/label-baseinfo.component.ts");
/* harmony import */ var _feature_detail_feature_detail_component__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../feature-detail/feature-detail.component */ "./src/app/business/geo-label/sign/label-detail/feature-detail/feature-detail.component.ts");
/* harmony import */ var _label_comment_label_comment_component__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../label-comment/label-comment.component */ "./src/app/business/geo-label/sign/label-detail/label-comment/label-comment.component.ts");














function LabelDetailContentComponent_img_4_Template(rf, ctx) { if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["element"](0, "img", 10);
} if (rf & 2) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("src", "./assets/img/map/icon_list_selected.png", _angular_core__WEBPACK_IMPORTED_MODULE_0__["sanitizeUrl"]);
} }
function LabelDetailContentComponent_img_5_Template(rf, ctx) { if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["element"](0, "img", 10);
} if (rf & 2) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("src", "./assets/img/map/icon_list_select.png", _angular_core__WEBPACK_IMPORTED_MODULE_0__["sanitizeUrl"]);
} }
var LabelDetailContentComponent = /** @class */ (function () {
    function LabelDetailContentComponent(nzMessageService, mapboxmapService) {
        this.nzMessageService = nzMessageService;
        this.mapboxmapService = mapboxmapService;
        this.data = null;
        this.delete = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.edit = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.map = null;
    }
    LabelDetailContentComponent.prototype.initMap = function () {
        this.map = this.mapboxmapService.getMap();
        var geojson = Object(_utils_main_format__WEBPACK_IMPORTED_MODULE_1__["listWktToGeoJson"])(this.data.graphs, 'geom');
        this.map.addSource('tag-geo', { type: 'geojson', data: geojson, });
        this.map.addLayer({
            id: 'line',
            type: 'line',
            source: 'tag-geo',
            layout: {},
            filter: ['==', ['get', 'geotype'], "LineString"],
            paint: {
                'line-width': 2,
                'line-color': '#0076ff',
            },
        });
        this.map.addLayer({
            id: 'circle',
            type: 'circle',
            source: 'tag-geo',
            layout: {},
            filter: ['==', ['get', 'geotype'], 'Point'],
            paint: {
                'circle-radius': 4,
                'circle-color': '#0076ff',
            },
        });
        this.map.addLayer({
            id: 'polygon',
            type: 'fill',
            source: 'tag-geo',
            layout: {},
            filter: ['==', ['get', 'geotype'], 'Polygon'],
            paint: {
                'fill-color': '#0076ff',
                'fill-opacity': 0.5,
            },
        });
    };
    LabelDetailContentComponent.prototype.ngOnInit = function () {
    };
    LabelDetailContentComponent.prototype.editTag = function () {
        this.edit.emit();
    };
    LabelDetailContentComponent.prototype.cancel = function () { };
    LabelDetailContentComponent.prototype.confirm = function () {
        this.delete.emit(this.data.tagid);
    };
    LabelDetailContentComponent.prototype.removelayer = function () {
        if (this.map) {
            this.map.removeLayer('line');
            this.map.removeLayer('circle');
            this.map.removeLayer('polygon');
            this.map.removeSource('tag-geo');
        }
    };
    LabelDetailContentComponent.prototype.ngOnChanges = function () {
        this.removelayer();
        this.initMap();
    };
    LabelDetailContentComponent.prototype.ngOnDestroy = function () {
        this.removelayer();
    };
    LabelDetailContentComponent.fac = function LabelDetailContentComponent_Factory(t) { return new (t || LabelDetailContentComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](ng_zorro_antd__WEBPACK_IMPORTED_MODULE_2__["NzMessageService"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](src_app_cityfun_mapbox_map_service_mapboxmap_service__WEBPACK_IMPORTED_MODULE_3__["MapboxmapService"])); };
    LabelDetailContentComponent.cmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["defineComponent"]({ type: LabelDetailContentComponent, selectors: [["lb-label-detail-content"]], inputs: { data: "data" }, outputs: { delete: "delete", edit: "edit" }, features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["NgOnChangesFeature"]], decls: 17, vars: 6, consts: [[1, "title"], [1, "left"], [3, "src", 4, "ngIf"], [1, "right"], ["nz-button", "", "nzType", "primary", 3, "disabled", "click"], ["nz-icon", "", "nzType", "edit", "nzTheme", "outline"], ["nz-popconfirm", "", "nzPopconfirmTitle", "\u786E\u8BA4\u5220\u9664\uFF1F", "nzPopconfirmPlacement", "right", "nz-button", "", "nzDanger", "", 3, "disabled", "nzOnConfirm", "nzOnCancel"], ["nz-icon", "", "nzType", "delete", "nzTheme", "outline"], [1, "base-info"], [3, "data"], [3, "src"]], template: function LabelDetailContentComponent_Template(rf, ctx) { if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](0, "div", 0);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](1, "div", 1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](2, "span");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](3, "\u6807\u8BB0\u8BE6\u60C5");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](4, LabelDetailContentComponent_img_4_Template, 1, 1, "img", 2);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](5, LabelDetailContentComponent_img_5_Template, 1, 1, "img", 2);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](6, "div", 3);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](7, "button", 4);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["listener"]("click", function LabelDetailContentComponent_Template_button_click_7_listener() { return ctx.editTag(); });
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["element"](8, "i", 5);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](9, "\u7F16\u8F91");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](10, "button", 6);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["listener"]("nzOnConfirm", function LabelDetailContentComponent_Template_button_nzOnConfirm_10_listener() { return ctx.confirm(); })("nzOnCancel", function LabelDetailContentComponent_Template_button_nzOnCancel_10_listener() { return ctx.cancel(); });
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["element"](11, "i", 7);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](12, "\u5220\u9664");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](13, "div", 8);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["element"](14, "lb-label-baseinfo", 9);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["element"](15, "lb-feature-detail", 9);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["element"](16, "lb-label-comment");
        } if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](4);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngIf", ctx.data.issubscribe == 1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngIf", ctx.data.issubscribe == 0);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](2);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("disabled", (ctx.data == null ? null : ctx.data.isedit) == 1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](3);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("disabled", (ctx.data == null ? null : ctx.data.isedit) == 1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](4);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("data", ctx.data);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("data", ctx.data.graphs);
        } }, directives: [_angular_common__WEBPACK_IMPORTED_MODULE_4__["NgIf"], ng_zorro_antd_button__WEBPACK_IMPORTED_MODULE_5__["NzButtonComponent"], ng_zorro_antd_core_wave__WEBPACK_IMPORTED_MODULE_6__["NzWaveDirective"], ng_zorro_antd_core_transition_patch__WEBPACK_IMPORTED_MODULE_7__["NzTransitionPatchDirective"], ng_zorro_antd_icon__WEBPACK_IMPORTED_MODULE_8__["NzIconDirective"], ng_zorro_antd_popconfirm__WEBPACK_IMPORTED_MODULE_9__["NzPopconfirmDirective"], _label_baseinfo_label_baseinfo_component__WEBPACK_IMPORTED_MODULE_10__["LabelBaseinfoComponent"], _feature_detail_feature_detail_component__WEBPACK_IMPORTED_MODULE_11__["FeatureDetailComponent"], _label_comment_label_comment_component__WEBPACK_IMPORTED_MODULE_12__["LabelCommentComponent"]], styles: [".title[_ngcontent-%COMP%] {\n  display: -ms-flexbox;\n  display: flex;\n  height: 52px;\n  padding: 0 16px;\n  -ms-flex-pack: justify;\n      justify-content: space-between;\n  -ms-flex-align: center;\n      align-items: center;\n}\n.title[_ngcontent-%COMP%]   .left[_ngcontent-%COMP%] {\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-align: center;\n      align-items: center;\n}\n.title[_ngcontent-%COMP%]   .left[_ngcontent-%COMP%]   span[_ngcontent-%COMP%] {\n  font-size: 16px;\n  font-weight: bold;\n}\n.title[_ngcontent-%COMP%]   .left[_ngcontent-%COMP%]   img[_ngcontent-%COMP%] {\n  display: inline-block;\n  margin-left: 5px;\n  width: 15px;\n  height: 15px;\n}\n.title[_ngcontent-%COMP%]   .right[_ngcontent-%COMP%] {\n  display: -ms-flexbox;\n  display: flex;\n}\n.title[_ngcontent-%COMP%]   .right[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:first-child {\n  margin-right: 10px;\n}\n.base-info[_ngcontent-%COMP%] {\n  padding: 0 16px;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAvYnVzaW5lc3MvZ2VvLWxhYmVsL3NpZ24vbGFiZWwtZGV0YWlsL2xhYmVsLWRldGFpbC1jb250ZW50L0U6XFxQcm9qMjAyMFxc56m66Ze06LWE5rqQ5pm65oWn566h55CGXFxHZW9MYWJlbC9zcmNcXGFwcFxcYnVzaW5lc3NcXGdlby1sYWJlbFxcc2lnblxcbGFiZWwtZGV0YWlsXFxsYWJlbC1kZXRhaWwtY29udGVudFxcbGFiZWwtZGV0YWlsLWNvbnRlbnQuY29tcG9uZW50LnNjc3MiLCJzcmMvYXBwL2J1c2luZXNzL2dlby1sYWJlbC9zaWduL2xhYmVsLWRldGFpbC9sYWJlbC1kZXRhaWwtY29udGVudC9sYWJlbC1kZXRhaWwtY29udGVudC5jb21wb25lbnQuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtFQUNFLG9CQUFBO0VBQUEsYUFBQTtFQUNBLFlBQUE7RUFDQSxlQUFBO0VBQ0Esc0JBQUE7TUFBQSw4QkFBQTtFQUNBLHNCQUFBO01BQUEsbUJBQUE7QUNDRjtBREFFO0VBQ0Usb0JBQUE7RUFBQSxhQUFBO0VBQ0Esc0JBQUE7TUFBQSxtQkFBQTtBQ0VKO0FEREk7RUFDRSxlQUFBO0VBQ0EsaUJBQUE7QUNHTjtBRERJO0VBQ0UscUJBQUE7RUFDQSxnQkFBQTtFQUNBLFdBQUE7RUFDQSxZQUFBO0FDR047QURBRTtFQUNFLG9CQUFBO0VBQUEsYUFBQTtBQ0VKO0FEREk7RUFDRSxrQkFBQTtBQ0dOO0FEQ0E7RUFDRSxlQUFBO0FDRUYiLCJmaWxlIjoic3JjL2FwcC9idXNpbmVzcy9nZW8tbGFiZWwvc2lnbi9sYWJlbC1kZXRhaWwvbGFiZWwtZGV0YWlsLWNvbnRlbnQvbGFiZWwtZGV0YWlsLWNvbnRlbnQuY29tcG9uZW50LnNjc3MiLCJzb3VyY2VzQ29udGVudCI6WyIudGl0bGV7XHJcbiAgZGlzcGxheTogZmxleDtcclxuICBoZWlnaHQ6IDUycHg7XHJcbiAgcGFkZGluZzogMCAxNnB4O1xyXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcclxuICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gIC5sZWZ0IHtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gICAgc3BhbntcclxuICAgICAgZm9udC1zaXplOiAxNnB4O1xyXG4gICAgICBmb250LXdlaWdodDogYm9sZDtcclxuICAgIH1cclxuICAgIGltZ3tcclxuICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xyXG4gICAgICBtYXJnaW4tbGVmdDogNXB4O1xyXG4gICAgICB3aWR0aDogMTVweDtcclxuICAgICAgaGVpZ2h0OiAxNXB4O1xyXG4gICAgfVxyXG4gIH1cclxuICAucmlnaHR7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgYnV0dG9uOmZpcnN0LWNoaWxke1xyXG4gICAgICBtYXJnaW4tcmlnaHQ6IDEwcHg7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbi5iYXNlLWluZm97XHJcbiAgcGFkZGluZzogMCAxNnB4O1xyXG5cclxuXHJcbn1cclxuIiwiLnRpdGxlIHtcbiAgZGlzcGxheTogZmxleDtcbiAgaGVpZ2h0OiA1MnB4O1xuICBwYWRkaW5nOiAwIDE2cHg7XG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cbi50aXRsZSAubGVmdCB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG59XG4udGl0bGUgLmxlZnQgc3BhbiB7XG4gIGZvbnQtc2l6ZTogMTZweDtcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XG59XG4udGl0bGUgLmxlZnQgaW1nIHtcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICBtYXJnaW4tbGVmdDogNXB4O1xuICB3aWR0aDogMTVweDtcbiAgaGVpZ2h0OiAxNXB4O1xufVxuLnRpdGxlIC5yaWdodCB7XG4gIGRpc3BsYXk6IGZsZXg7XG59XG4udGl0bGUgLnJpZ2h0IGJ1dHRvbjpmaXJzdC1jaGlsZCB7XG4gIG1hcmdpbi1yaWdodDogMTBweDtcbn1cblxuLmJhc2UtaW5mbyB7XG4gIHBhZGRpbmc6IDAgMTZweDtcbn0iXX0= */"], changeDetection: 0 });
    return LabelDetailContentComponent;
}());

/*@__PURE__*/ (function () { _angular_core__WEBPACK_IMPORTED_MODULE_0__["setClassMetadata"](LabelDetailContentComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
                selector: 'lb-label-detail-content',
                templateUrl: './label-detail-content.component.html',
                styleUrls: ['./label-detail-content.component.scss'],
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
            }]
    }], function () { return [{ type: ng_zorro_antd__WEBPACK_IMPORTED_MODULE_2__["NzMessageService"] }, { type: src_app_cityfun_mapbox_map_service_mapboxmap_service__WEBPACK_IMPORTED_MODULE_3__["MapboxmapService"] }]; }, { data: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }], delete: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }], edit: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }] }); })();


/***/ }),

/***/ "./src/app/business/geo-label/sign/label-detail/label-detail.component.ts":
/*!********************************************************************************!*\
  !*** ./src/app/business/geo-label/sign/label-detail/label-detail.component.ts ***!
  \********************************************************************************/
/*! exports provided: LabelDetailComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LabelDetailComponent", function() { return LabelDetailComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/__ivy_ngcc__/fesm5/core.js");
/* harmony import */ var _utils_main_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/main-format */ "./src/app/business/geo-label/utils/main-format.ts");
/* harmony import */ var _sign_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../sign.service */ "./src/app/business/geo-label/sign/sign.service.ts");
/* harmony import */ var ng_zorro_antd_message__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ng-zorro-antd/message */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-message.js");
/* harmony import */ var _sign_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../sign.component */ "./src/app/business/geo-label/sign/sign.component.ts");
/* harmony import */ var _common_label_container_label_container_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/label-container/label-container.component */ "./src/app/business/geo-label/common/label-container/label-container.component.ts");
/* harmony import */ var ng_zorro_antd_icon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ng-zorro-antd/icon */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-icon.js");
/* harmony import */ var ng_zorro_antd_core_transition_patch__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ng-zorro-antd/core/transition-patch */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-core-transition-patch.js");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/__ivy_ngcc__/fesm5/common.js");
/* harmony import */ var _label_add_add_content_add_content_component__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../label-add/add-content/add-content.component */ "./src/app/business/geo-label/sign/label-add/add-content/add-content.component.ts");
/* harmony import */ var _label_detail_content_label_detail_content_component__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./label-detail-content/label-detail-content.component */ "./src/app/business/geo-label/sign/label-detail/label-detail-content/label-detail-content.component.ts");












function LabelDetailComponent_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    var _r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["getCurrentView"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementContainerStart"](0);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](1, "lb-add-content", 7);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["listener"]("showDetail", function LabelDetailComponent_ng_container_7_Template_lb_add_content_showDetail_1_listener() { _angular_core__WEBPACK_IMPORTED_MODULE_0__["restoreView"](_r3); var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](); return ctx_r2.showDetail(); });
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementContainerEnd"]();
} if (rf & 2) {
    var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("addSourceInfo", ctx_r0.addSourceInfo)("tagId", ctx_r0.data == null ? null : ctx_r0.data.tagid)("isEdit", true);
} }
function LabelDetailComponent_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    var _r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["getCurrentView"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementContainerStart"](0);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](1, "lb-label-detail-content", 8);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["listener"]("delete", function LabelDetailComponent_ng_container_8_Template_lb_label_detail_content_delete_1_listener($event) { _angular_core__WEBPACK_IMPORTED_MODULE_0__["restoreView"](_r5); var ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](); return ctx_r4.deleteTag($event); })("edit", function LabelDetailComponent_ng_container_8_Template_lb_label_detail_content_edit_1_listener() { _angular_core__WEBPACK_IMPORTED_MODULE_0__["restoreView"](_r5); var ctx_r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](); return ctx_r6.editTag(); });
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementContainerEnd"]();
} if (rf & 2) {
    var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("data", ctx_r1.data);
} }
var LabelDetailComponent = /** @class */ (function () {
    function LabelDetailComponent(signService, cdr, nzMessageService, signComponent) {
        this.signService = signService;
        this.cdr = cdr;
        this.nzMessageService = nzMessageService;
        this.signComponent = signComponent;
        this.data = null;
        this.close = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.isEdit = false;
        this.addSourceInfo = null;
    }
    LabelDetailComponent.prototype.ngOnInit = function () {
    };
    LabelDetailComponent.prototype.hide = function () {
        if (this.isEdit) {
            this.isEdit = false;
        }
        else {
            this.close.emit();
        }
    };
    LabelDetailComponent.prototype.deleteTag = function (tagid) {
        var _this = this;
        this.signService
            .deleteTag({ tagid: tagid })
            .subscribe(function (result) {
            if (result) {
                _this.cdr.markForCheck();
                _this.nzMessageService.success('!');
                _this.close.emit();
            }
            else {
                _this.nzMessageService.error('!');
            }
        });
    };
    LabelDetailComponent.prototype.editTag = function () {
        this.isEdit = true;
        this.addSourceInfo = Object(_utils_main_format__WEBPACK_IMPORTED_MODULE_1__["tagDetailToSourceTagInfo"])(this.data);
        var coordinates = Object(_utils_main_format__WEBPACK_IMPORTED_MODULE_1__["wktToGeoJson"])(this.data.geom).coordinates;
        this.signComponent.addMoveMarker(coordinates, false);
        // this.signComponent.addMarker();
    };
    LabelDetailComponent.prototype.showDetail = function () {
        this.isEdit = false;
    };
    LabelDetailComponent.prototype.ngOnChanges = function () {
    };
    LabelDetailComponent.fac = function LabelDetailComponent_Factory(t) { return new (t || LabelDetailComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](_sign_service__WEBPACK_IMPORTED_MODULE_2__["SignService"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](ng_zorro_antd_message__WEBPACK_IMPORTED_MODULE_3__["NzMessageService"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](_sign_component__WEBPACK_IMPORTED_MODULE_4__["SignComponent"])); };
    LabelDetailComponent.cmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["defineComponent"]({ type: LabelDetailComponent, selectors: [["lb-label-detail"]], inputs: { data: "data", isEdit: "isEdit", addSourceInfo: "addSourceInfo" }, outputs: { close: "close" }, features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["NgOnChangesFeature"]], decls: 9, vars: 4, consts: [[1, "label-detail"], [3, "closeble", "toggleble"], ["name", "header"], [1, "header", 3, "click"], ["nz-icon", "", "nzType", "arrow-left", "nzTheme", "outline"], ["name", "content"], [4, "ngIf"], [3, "addSourceInfo", "tagId", "isEdit", "showDetail"], [3, "data", "delete", "edit"]], template: function LabelDetailComponent_Template(rf, ctx) { if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](0, "div", 0);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](1, "app-label-container", 1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementContainerStart"](2, 2);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](3, "div", 3);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["listener"]("click", function LabelDetailComponent_Template_div_click_3_listener() { return ctx.hide(); });
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["element"](4, "i", 4);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](5, " \u8FD4\u56DE");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementContainerEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementContainerStart"](6, 5);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](7, LabelDetailComponent_ng_container_7_Template, 2, 3, "ng-container", 6);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](8, LabelDetailComponent_ng_container_8_Template, 2, 1, "ng-container", 6);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementContainerEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
        } if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("closeble", false)("toggleble", false);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](6);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngIf", ctx.isEdit && ctx.addSourceInfo);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngIf", !ctx.isEdit);
        } }, directives: [_common_label_container_label_container_component__WEBPACK_IMPORTED_MODULE_5__["LabelContainerComponent"], ng_zorro_antd_icon__WEBPACK_IMPORTED_MODULE_6__["NzIconDirective"], ng_zorro_antd_core_transition_patch__WEBPACK_IMPORTED_MODULE_7__["NzTransitionPatchDirective"], _angular_common__WEBPACK_IMPORTED_MODULE_8__["NgIf"], _label_add_add_content_add_content_component__WEBPACK_IMPORTED_MODULE_9__["AddContentComponent"], _label_detail_content_label_detail_content_component__WEBPACK_IMPORTED_MODULE_10__["LabelDetailContentComponent"]], styles: [".label-detail[_ngcontent-%COMP%] {\n  width: 380px;\n  box-shadow: 0px 1px 10px rgba(0, 0, 0, 0.1);\n  background: #ffffff;\n  position: relative;\n  height: 100%;\n}\n.label-detail[_ngcontent-%COMP%]   .header[_ngcontent-%COMP%] {\n  display: -ms-flexbox;\n  display: flex;\n  cursor: pointer;\n  -ms-flex-align: center;\n      align-items: center;\n}\n.label-detail[_ngcontent-%COMP%]   .header[_ngcontent-%COMP%]   i[_ngcontent-%COMP%] {\n  margin-right: 10px;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAvYnVzaW5lc3MvZ2VvLWxhYmVsL3NpZ24vbGFiZWwtZGV0YWlsL0U6XFxQcm9qMjAyMFxc56m66Ze06LWE5rqQ5pm65oWn566h55CGXFxHZW9MYWJlbC9zcmNcXGFwcFxcYnVzaW5lc3NcXGdlby1sYWJlbFxcc2lnblxcbGFiZWwtZGV0YWlsXFxsYWJlbC1kZXRhaWwuY29tcG9uZW50LnNjc3MiLCJzcmMvYXBwL2J1c2luZXNzL2dlby1sYWJlbC9zaWduL2xhYmVsLWRldGFpbC9sYWJlbC1kZXRhaWwuY29tcG9uZW50LnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7RUFDRSxZQUFBO0VBQ0EsMkNBQUE7RUFDQSxtQkFBQTtFQUNBLGtCQUFBO0VBQ0EsWUFBQTtBQ0NGO0FEQUU7RUFDRSxvQkFBQTtFQUFBLGFBQUE7RUFDQSxlQUFBO0VBQ0Esc0JBQUE7TUFBQSxtQkFBQTtBQ0VKO0FEREk7RUFDRSxrQkFBQTtBQ0dOIiwiZmlsZSI6InNyYy9hcHAvYnVzaW5lc3MvZ2VvLWxhYmVsL3NpZ24vbGFiZWwtZGV0YWlsL2xhYmVsLWRldGFpbC5jb21wb25lbnQuc2NzcyIsInNvdXJjZXNDb250ZW50IjpbIi5sYWJlbC1kZXRhaWwge1xyXG4gIHdpZHRoOiAzODBweDtcclxuICBib3gtc2hhZG93OiAwcHggMXB4IDEwcHggcmdiYSgwLCAwLCAwLCAwLjEpO1xyXG4gIGJhY2tncm91bmQ6ICNmZmZmZmY7XHJcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gIGhlaWdodDogMTAwJTtcclxuICAuaGVhZGVyIHtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gICAgaSB7XHJcbiAgICAgIG1hcmdpbi1yaWdodDogMTBweDtcclxuICAgIH1cclxuICB9XHJcblxyXG59XHJcbiIsIi5sYWJlbC1kZXRhaWwge1xuICB3aWR0aDogMzgwcHg7XG4gIGJveC1zaGFkb3c6IDBweCAxcHggMTBweCByZ2JhKDAsIDAsIDAsIDAuMSk7XG4gIGJhY2tncm91bmQ6ICNmZmZmZmY7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgaGVpZ2h0OiAxMDAlO1xufVxuLmxhYmVsLWRldGFpbCAuaGVhZGVyIHtcbiAgZGlzcGxheTogZmxleDtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xufVxuLmxhYmVsLWRldGFpbCAuaGVhZGVyIGkge1xuICBtYXJnaW4tcmlnaHQ6IDEwcHg7XG59Il19 */"], changeDetection: 0 });
    return LabelDetailComponent;
}());

/*@__PURE__*/ (function () { _angular_core__WEBPACK_IMPORTED_MODULE_0__["setClassMetadata"](LabelDetailComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
                selector: 'lb-label-detail',
                templateUrl: './label-detail.component.html',
                styleUrls: ['./label-detail.component.scss'],
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
            }]
    }], function () { return [{ type: _sign_service__WEBPACK_IMPORTED_MODULE_2__["SignService"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] }, { type: ng_zorro_antd_message__WEBPACK_IMPORTED_MODULE_3__["NzMessageService"] }, { type: _sign_component__WEBPACK_IMPORTED_MODULE_4__["SignComponent"] }]; }, { data: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }], close: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }], isEdit: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }], addSourceInfo: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }] }); })();


/***/ }),

/***/ "./src/app/business/geo-label/sign/label-legend/label-legend.component.ts":
/*!********************************************************************************!*\
  !*** ./src/app/business/geo-label/sign/label-legend/label-legend.component.ts ***!
  \********************************************************************************/
/*! exports provided: LabelLegendComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LabelLegendComponent", function() { return LabelLegendComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/__ivy_ngcc__/fesm5/core.js");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/__ivy_ngcc__/fesm5/common.js");
/* harmony import */ var ng_zorro_antd_switch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ng-zorro-antd/switch */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-switch.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/__ivy_ngcc__/fesm5/forms.js");





function LabelLegendComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    var _r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["getCurrentView"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](0, "div", 2);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["element"](1, "img", 3);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](2);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](3, "nz-switch", 4);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["listener"]("ngModelChange", function LabelLegendComponent_div_1_Template_nz_switch_ngModelChange_3_listener($event) { _angular_core__WEBPACK_IMPORTED_MODULE_0__["restoreView"](_r3); var item_r1 = ctx.$implicit; return item_r1.active = $event; })("ngModelChange", function LabelLegendComponent_div_1_Template_nz_switch_ngModelChange_3_listener() { _angular_core__WEBPACK_IMPORTED_MODULE_0__["restoreView"](_r3); var item_r1 = ctx.$implicit; var ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](); return ctx_r4.modelChange(item_r1); });
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
} if (rf & 2) {
    var item_r1 = ctx.$implicit;
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("src", item_r1.icon, _angular_core__WEBPACK_IMPORTED_MODULE_0__["sanitizeUrl"]);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["textInterpolate1"](" ", item_r1.title, " ");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngModel", item_r1.active);
} }
var LabelLegendComponent = /** @class */ (function () {
    function LabelLegendComponent() {
        this.data = [
            {
                title: '',
                icon: './assets/img/map/icon_map_switch_mine.png',
                active: true,
                id: 'all-tag-points-my',
            },
            {
                title: '',
                icon: './assets/img/map/icon_map_switch_others.png',
                active: true,
                id: 'all-tag-points-other',
            }
        ];
        this.legendToggle = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
    }
    LabelLegendComponent.prototype.ngOnInit = function () {
    };
    LabelLegendComponent.prototype.modelChange = function (item) {
        this.legendToggle.emit(item);
    };
    LabelLegendComponent.fac = function LabelLegendComponent_Factory(t) { return new (t || LabelLegendComponent)(); };
    LabelLegendComponent.cmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["defineComponent"]({ type: LabelLegendComponent, selectors: [["lb-label-legend"]], inputs: { data: "data" }, outputs: { legendToggle: "legendToggle" }, decls: 2, vars: 1, consts: [[1, "legend"], ["class", "item", 4, "ngFor", "ngForOf"], [1, "item"], [3, "src"], [3, "ngModel", "ngModelChange"]], template: function LabelLegendComponent_Template(rf, ctx) { if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](0, "div", 0);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](1, LabelLegendComponent_div_1_Template, 4, 3, "div", 1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
        } if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngForOf", ctx.data);
        } }, directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["NgForOf"], ng_zorro_antd_switch__WEBPACK_IMPORTED_MODULE_2__["NzSwitchComponent"], _angular_forms__WEBPACK_IMPORTED_MODULE_3__["NgControlStatus"], _angular_forms__WEBPACK_IMPORTED_MODULE_3__["NgModel"]], styles: [".legend[_ngcontent-%COMP%] {\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-direction: column;\n      flex-direction: column;\n  width: 134px;\n  height: 90px;\n  background: #FFFFFF;\n  box-shadow: 0px 1px 10px rgba(0, 0, 0, 0.1);\n  opacity: 1;\n  border-radius: 4px;\n  pointer-events: all;\n  -ms-flex-align: center;\n      align-items: center;\n  -ms-flex-pack: center;\n      justify-content: center;\n}\n.legend[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%] {\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-align: center;\n      align-items: center;\n  height: 40px;\n  width: 100%;\n  -ms-flex-pack: distribute;\n      justify-content: space-around;\n  color: #333333;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAvYnVzaW5lc3MvZ2VvLWxhYmVsL3NpZ24vbGFiZWwtbGVnZW5kL0U6XFxQcm9qMjAyMFxc56m66Ze06LWE5rqQ5pm65oWn566h55CGXFxHZW9MYWJlbC9zcmNcXGFwcFxcYnVzaW5lc3NcXGdlby1sYWJlbFxcc2lnblxcbGFiZWwtbGVnZW5kXFxsYWJlbC1sZWdlbmQuY29tcG9uZW50LnNjc3MiLCJzcmMvYXBwL2J1c2luZXNzL2dlby1sYWJlbC9zaWduL2xhYmVsLWxlZ2VuZC9sYWJlbC1sZWdlbmQuY29tcG9uZW50LnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7RUFDRSxvQkFBQTtFQUFBLGFBQUE7RUFDQSwwQkFBQTtNQUFBLHNCQUFBO0VBQ0EsWUFBQTtFQUNBLFlBQUE7RUFDQSxtQkFBQTtFQUNBLDJDQUFBO0VBQ0EsVUFBQTtFQUNBLGtCQUFBO0VBQ0EsbUJBQUE7RUFDQSxzQkFBQTtNQUFBLG1CQUFBO0VBQ0EscUJBQUE7TUFBQSx1QkFBQTtBQ0NGO0FEQUU7RUFDRSxvQkFBQTtFQUFBLGFBQUE7RUFDQSxzQkFBQTtNQUFBLG1CQUFBO0VBQ0EsWUFBQTtFQUNBLFdBQUE7RUFDQSx5QkFBQTtNQUFBLDZCQUFBO0VBQ0EsY0FBQTtBQ0VKIiwiZmlsZSI6InNyYy9hcHAvYnVzaW5lc3MvZ2VvLWxhYmVsL3NpZ24vbGFiZWwtbGVnZW5kL2xhYmVsLWxlZ2VuZC5jb21wb25lbnQuc2NzcyIsInNvdXJjZXNDb250ZW50IjpbIi5sZWdlbmR7XHJcbiAgZGlzcGxheTogZmxleDtcclxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xyXG4gIHdpZHRoOiAxMzRweDtcclxuICBoZWlnaHQ6IDkwcHg7XHJcbiAgYmFja2dyb3VuZDogI0ZGRkZGRjtcclxuICBib3gtc2hhZG93OiAwcHggMXB4IDEwcHggcmdiYSgwLCAwLCAwLCAwLjEpO1xyXG4gIG9wYWNpdHk6IDE7XHJcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xyXG4gIHBvaW50ZXItZXZlbnRzOiBhbGw7XHJcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcclxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcclxuICAuaXRlbXtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gICAgaGVpZ2h0OiA0MHB4O1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcclxuICAgIGNvbG9yOiAjMzMzMzMzOztcclxuICB9XHJcbn1cclxuIiwiLmxlZ2VuZCB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIHdpZHRoOiAxMzRweDtcbiAgaGVpZ2h0OiA5MHB4O1xuICBiYWNrZ3JvdW5kOiAjRkZGRkZGO1xuICBib3gtc2hhZG93OiAwcHggMXB4IDEwcHggcmdiYSgwLCAwLCAwLCAwLjEpO1xuICBvcGFjaXR5OiAxO1xuICBib3JkZXItcmFkaXVzOiA0cHg7XG4gIHBvaW50ZXItZXZlbnRzOiBhbGw7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xufVxuLmxlZ2VuZCAuaXRlbSB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGhlaWdodDogNDBweDtcbiAgd2lkdGg6IDEwMCU7XG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xuICBjb2xvcjogIzMzMzMzMztcbn0iXX0= */"], changeDetection: 0 });
    return LabelLegendComponent;
}());

/*@__PURE__*/ (function () { _angular_core__WEBPACK_IMPORTED_MODULE_0__["setClassMetadata"](LabelLegendComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
                selector: 'lb-label-legend',
                templateUrl: './label-legend.component.html',
                styleUrls: ['./label-legend.component.scss'],
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush
            }]
    }], function () { return []; }, { data: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }], legendToggle: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }] }); })();


/***/ }),

/***/ "./src/app/business/geo-label/sign/label-search/label-search.component.ts":
/*!********************************************************************************!*\
  !*** ./src/app/business/geo-label/sign/label-search/label-search.component.ts ***!
  \********************************************************************************/
/*! exports provided: LabelSearchComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LabelSearchComponent", function() { return LabelSearchComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/__ivy_ngcc__/fesm5/core.js");
/* harmony import */ var _utils_main_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/main-format */ "./src/app/business/geo-label/utils/main-format.ts");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/__ivy_ngcc__/fesm5/common.js");
/* harmony import */ var _sign_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../sign.component */ "./src/app/business/geo-label/sign/sign.component.ts");
/* harmony import */ var _sign_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../sign.service */ "./src/app/business/geo-label/sign/sign.service.ts");
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/router */ "./node_modules/@angular/router/__ivy_ngcc__/fesm5/router.js");
/* harmony import */ var _common_label_container_label_container_component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../common/label-container/label-container.component */ "./src/app/business/geo-label/common/label-container/label-container.component.ts");
/* harmony import */ var ng_zorro_antd_input__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ng-zorro-antd/input */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-input.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/__ivy_ngcc__/fesm5/forms.js");
/* harmony import */ var ng_zorro_antd_icon__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ng-zorro-antd/icon */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-icon.js");
/* harmony import */ var ng_zorro_antd_core_transition_patch__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ng-zorro-antd/core/transition-patch */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-core-transition-patch.js");
/* harmony import */ var _common_label_list_label_list_component__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../common/label-list/label-list.component */ "./src/app/business/geo-label/common/label-list/label-list.component.ts");
/* harmony import */ var ng_zorro_antd_date_picker__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ng-zorro-antd/date-picker */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-date-picker.js");
/* harmony import */ var ng_zorro_antd_button__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ng-zorro-antd/button */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-button.js");
/* harmony import */ var ng_zorro_antd_core_wave__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ng-zorro-antd/core/wave */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-core-wave.js");

















function LabelSearchComponent_app_label_container_1_ng_container_13_Template(rf, ctx) { if (rf & 1) {
    var _r7 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["getCurrentView"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementContainerStart"](0);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](1, "div", 17);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](2, "span");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](3, "\u521B\u5EFA\u65F6\u95F4\uFF1A");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](4, "nz-range-picker", 18);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["listener"]("ngModelChange", function LabelSearchComponent_app_label_container_1_ng_container_13_Template_nz_range_picker_ngModelChange_4_listener($event) { _angular_core__WEBPACK_IMPORTED_MODULE_0__["restoreView"](_r7); var ctx_r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](2); return ctx_r6.dateRange = $event; })("ngModelChange", function LabelSearchComponent_app_label_container_1_ng_container_13_Template_nz_range_picker_ngModelChange_4_listener($event) { _angular_core__WEBPACK_IMPORTED_MODULE_0__["restoreView"](_r7); var ctx_r8 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](2); return ctx_r8.timeRangeOnChange($event); });
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementContainerEnd"]();
} if (rf & 2) {
    var ctx_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](2);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](4);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("nzFormat", ctx_r5.dateFormat)("ngModel", ctx_r5.dateRange);
} }
function LabelSearchComponent_app_label_container_1_Template(rf, ctx) { if (rf & 1) {
    var _r10 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["getCurrentView"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](0, "app-label-container", 4);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["listener"]("closed", function LabelSearchComponent_app_label_container_1_Template_app_label_container_closed_0_listener() { _angular_core__WEBPACK_IMPORTED_MODULE_0__["restoreView"](_r10); var ctx_r9 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](); return ctx_r9.closeContainer(); });
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementContainerStart"](1, 5);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](2);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementContainerEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementContainerStart"](3, 6);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](4, "div", 7);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](5, "nz-input-group", 8);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](6, "input", 9);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["listener"]("ngModelChange", function LabelSearchComponent_app_label_container_1_Template_input_ngModelChange_6_listener($event) { _angular_core__WEBPACK_IMPORTED_MODULE_0__["restoreView"](_r10); var ctx_r11 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](); return ctx_r11.keyString = $event; });
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](7, "div", 10);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](8, "span", 11);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["listener"]("click", function LabelSearchComponent_app_label_container_1_Template_span_click_8_listener() { _angular_core__WEBPACK_IMPORTED_MODULE_0__["restoreView"](_r10); var ctx_r12 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](); return ctx_r12.toggleFilter = !ctx_r12.toggleFilter; });
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](9, "\u5C5E\u6027\u7B5B\u9009");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["element"](10, "i", 12);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](11, "span", 13);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["listener"]("click", function LabelSearchComponent_app_label_container_1_Template_span_click_11_listener() { _angular_core__WEBPACK_IMPORTED_MODULE_0__["restoreView"](_r10); var ctx_r13 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](); return ctx_r13.clearParams(); });
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](12, "\u6E05\u7A7A\u6761\u4EF6");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](13, LabelSearchComponent_app_label_container_1_ng_container_13_Template, 5, 2, "ng-container", 14);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](14, "div", 15);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](15, "app-label-list", 16);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["listener"]("hideFeature", function LabelSearchComponent_app_label_container_1_Template_app_label_list_hideFeature_15_listener($event) { _angular_core__WEBPACK_IMPORTED_MODULE_0__["restoreView"](_r10); var ctx_r14 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](); return ctx_r14.hideFeature($event); })("tagItemClick", function LabelSearchComponent_app_label_container_1_Template_app_label_list_tagItemClick_15_listener($event) { _angular_core__WEBPACK_IMPORTED_MODULE_0__["restoreView"](_r10); var ctx_r15 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](); return ctx_r15.tagItemClick($event); })("pageItemClick", function LabelSearchComponent_app_label_container_1_Template_app_label_list_pageItemClick_15_listener($event) { _angular_core__WEBPACK_IMPORTED_MODULE_0__["restoreView"](_r10); var ctx_r16 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](); return ctx_r16.pageItemClick($event); })("toggleSub", function LabelSearchComponent_app_label_container_1_Template_app_label_list_toggleSub_15_listener($event) { _angular_core__WEBPACK_IMPORTED_MODULE_0__["restoreView"](_r10); var ctx_r17 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](); return ctx_r17.toggleSub($event); });
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementContainerEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
} if (rf & 2) {
    var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"]();
    var _r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["reference"](3);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("closeble", false);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](2);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["textInterpolate1"](" ", ctx_r0.modelName == "sign" ? "\u67E5\u8BE2\u6807\u8BB0" : "\u6536\u85CF\u5939", " ");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](3);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("nzAddOnAfter", _r1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngModel", ctx_r0.keyString);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](4);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("nzType", ctx_r0.toggleFilter ? "up" : "down");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](3);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngIf", ctx_r0.toggleFilter);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](2);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("currentPage", ctx_r0.pageNumber)("pageSize", ctx_r0.pageSize)("labelList", ctx_r0.tagList);
} }
function LabelSearchComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    var _r19 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["getCurrentView"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](0, "button", 19);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["listener"]("click", function LabelSearchComponent_ng_template_2_Template_button_click_0_listener() { _angular_core__WEBPACK_IMPORTED_MODULE_0__["restoreView"](_r19); var ctx_r18 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](); return ctx_r18.doSearch(); });
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](1, "\u67E5\u8BE2");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
} }
function LabelSearchComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](0);
} if (rf & 2) {
    var option_r20 = ctx.$implicit;
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["textInterpolate1"](" ", option_r20 == null ? null : option_r20.title, " ");
} }
var LabelSearchComponent = /** @class */ (function () {
    function LabelSearchComponent(signComponent, datePipe, signService, cdr, route) {
        var _this = this;
        this.signComponent = signComponent;
        this.datePipe = datePipe;
        this.signService = signService;
        this.cdr = cdr;
        this.route = route;
        this.tagList = null;
        this.keyString = '';
        this.nowData = new Date();
        this.dateRange = [];
        this.isOpen = true;
        this.toggleFilter = true;
        this.dateFormat = 'yyyy/MM/dd';
        this.classifyValues = [];
        this.pageSize = 9;
        this.pageNumber = 1;
        this.defaultSearchParams = {
            keyWord: '',
            // categoryId: '',
            startTime: '',
            endTime: '',
            pageSize: this.pageSize,
            pageNo: this.pageNumber,
        };
        this.classifyTree = [];
        this.modelName = 'sign';
        this.search = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.route.data.subscribe(function (data) {
            _this.modelName = data.path;
        });
    }
    LabelSearchComponent.prototype.ngOnInit = function () {
        this.getClassifyTree();
    };
    LabelSearchComponent.prototype.closeContainer = function () {
        this.isOpen = false;
    };
    LabelSearchComponent.prototype.clearParams = function () {
        this.dateRange = [];
        this.classifyValues = [];
        this.keyString = '';
    };
    LabelSearchComponent.prototype.timeRangeOnChange = function (result) {
        console.log('onChange: ', result);
    };
    LabelSearchComponent.prototype.doSearch = function () {
        var defaultSearchParams = {
            keyWord: this.keyString,
            // categoryId: this.classifyValues.pop() || '',
            startTime: (this.dateRange &&
                this.datePipe.transform(this.dateRange[0], 'yyyy-MM-dd HH:mm:ss')) ||
                '',
            endTime: (this.dateRange &&
                this.datePipe.transform(this.dateRange[1], 'yyyy-MM-dd HH:mm:ss')) ||
                '',
            pageSize: this.pageSize,
            pageNo: this.pageNumber,
        };
        this.search.emit(defaultSearchParams);
    };
    LabelSearchComponent.prototype.classifyOnChanges = function ($event) { };
    LabelSearchComponent.prototype.hideFeature = function (item) {
        var ids = [];
        this.tagList.list.forEach(function (item) {
            if (item.hidden) {
                ids.push(item.tagid);
            }
        });
        this.signComponent.hideTagFeatures(ids);
    };
    LabelSearchComponent.prototype.tagItemClick = function (item) {
        var coordinates = Object(_utils_main_format__WEBPACK_IMPORTED_MODULE_1__["wktToGeoJson"])(item.geom).coordinates;
        this.signComponent.mapboxMap.flyTo({
            center: coordinates,
            zoom: 15,
        });
        this.signComponent.toggleDetail(item.tagid);
    };
    LabelSearchComponent.prototype.pageItemClick = function (pageIndex) {
        this.pageNumber = pageIndex;
        this.doSearch();
    };
    LabelSearchComponent.prototype.toggleSub = function (data) {
        this.signComponent.toggleSub(data);
    };
    LabelSearchComponent.prototype.getClassifyTree = function () {
        var _this = this;
        this.signService
            .getClassifyTree({ treeid: '' })
            .subscribe(function (result) {
            _this.classifyTree = JSON.parse(result.jsontree);
        });
    };
    LabelSearchComponent.fac = function LabelSearchComponent_Factory(t) { return new (t || LabelSearchComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](_sign_component__WEBPACK_IMPORTED_MODULE_3__["SignComponent"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](_angular_common__WEBPACK_IMPORTED_MODULE_2__["DatePipe"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](_sign_service__WEBPACK_IMPORTED_MODULE_4__["SignService"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](_angular_router__WEBPACK_IMPORTED_MODULE_5__["ActivatedRoute"])); };
    LabelSearchComponent.cmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["defineComponent"]({ type: LabelSearchComponent, selectors: [["app-label-search"]], inputs: { tagList: "tagList", defaultSearchParams: "defaultSearchParams" }, outputs: { search: "search" }, features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ProvidersFeature"]([_angular_common__WEBPACK_IMPORTED_MODULE_2__["DatePipe"]])], decls: 6, vars: 1, consts: [[1, "search"], [3, "closeble", "closed", 4, "ngIf"], ["suffixButton", ""], ["renderTpl", ""], [3, "closeble", "closed"], ["name", "header"], ["name", "content"], [1, "top"], ["nzSearch", "", "nzSize", "large", 3, "nzAddOnAfter"], ["type", "text", "nz-input", "", "placeholder", "\u8BF7\u8F93\u5165\u5173\u952E\u5B57", 3, "ngModel", "ngModelChange"], [1, "condition", "param-item"], [1, "toggle", 3, "click"], ["nz-icon", "", "nzTheme", "outline", 2, "margin-left", "5px", 3, "nzType"], [1, "clear", 3, "click"], [4, "ngIf"], [1, "bottom"], [3, "currentPage", "pageSize", "labelList", "hideFeature", "tagItemClick", "pageItemClick", "toggleSub"], [1, "select-time", "param-item"], [3, "nzFormat", "ngModel", "ngModelChange"], ["nz-button", "", "nzType", "primary", "nzSize", "large", "nzSearch", "", 3, "click"]], template: function LabelSearchComponent_Template(rf, ctx) { if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](0, "div", 0);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](1, LabelSearchComponent_app_label_container_1_Template, 16, 9, "app-label-container", 1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](2, LabelSearchComponent_ng_template_2_Template, 2, 0, "ng-template", null, 2, _angular_core__WEBPACK_IMPORTED_MODULE_0__["templateRefExtractor"]);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](4, LabelSearchComponent_ng_template_4_Template, 1, 1, "ng-template", null, 3, _angular_core__WEBPACK_IMPORTED_MODULE_0__["templateRefExtractor"]);
        } if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngIf", ctx.isOpen);
        } }, directives: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["NgIf"], _common_label_container_label_container_component__WEBPACK_IMPORTED_MODULE_6__["LabelContainerComponent"], ng_zorro_antd_input__WEBPACK_IMPORTED_MODULE_7__["NzInputGroupComponent"], ng_zorro_antd_input__WEBPACK_IMPORTED_MODULE_7__["NzInputDirective"], _angular_forms__WEBPACK_IMPORTED_MODULE_8__["DefaultValueAccessor"], _angular_forms__WEBPACK_IMPORTED_MODULE_8__["NgControlStatus"], _angular_forms__WEBPACK_IMPORTED_MODULE_8__["NgModel"], ng_zorro_antd_icon__WEBPACK_IMPORTED_MODULE_9__["NzIconDirective"], ng_zorro_antd_core_transition_patch__WEBPACK_IMPORTED_MODULE_10__["NzTransitionPatchDirective"], _common_label_list_label_list_component__WEBPACK_IMPORTED_MODULE_11__["LabelListComponent"], ng_zorro_antd_date_picker__WEBPACK_IMPORTED_MODULE_12__["NzDatePickerComponent"], ng_zorro_antd_date_picker__WEBPACK_IMPORTED_MODULE_12__["NzRangePickerComponent"], ng_zorro_antd_button__WEBPACK_IMPORTED_MODULE_13__["NzButtonComponent"], ng_zorro_antd_core_wave__WEBPACK_IMPORTED_MODULE_14__["NzWaveDirective"]], styles: [".search[_ngcontent-%COMP%] {\n  width: 380px;\n  box-shadow: 0px 1px 10px rgba(0, 0, 0, 0.1);\n}\n.search[_ngcontent-%COMP%]   .top[_ngcontent-%COMP%] {\n  padding: 16px;\n  background: #ffffff;\n}\n.search[_ngcontent-%COMP%]   .top[_ngcontent-%COMP%]   .condition[_ngcontent-%COMP%] {\n  height: 54px;\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-align: center;\n      align-items: center;\n  -ms-flex-pack: justify;\n      justify-content: space-between;\n  border-bottom: 1px dashed #d9d9d9;\n  color: #1890ff;\n}\n.search[_ngcontent-%COMP%]   .top[_ngcontent-%COMP%]   .condition[_ngcontent-%COMP%]   .toggle[_ngcontent-%COMP%], .search[_ngcontent-%COMP%]   .top[_ngcontent-%COMP%]   .condition[_ngcontent-%COMP%]   .clear[_ngcontent-%COMP%] {\n  cursor: pointer;\n}\n.search[_ngcontent-%COMP%]   .top[_ngcontent-%COMP%]   .mark-classify[_ngcontent-%COMP%], .search[_ngcontent-%COMP%]   .top[_ngcontent-%COMP%]   .select-time[_ngcontent-%COMP%] {\n  margin-top: 16px;\n  display: -ms-flexbox;\n  display: flex;\n  -ms-flex-align: center;\n      align-items: center;\n  -ms-flex-pack: start;\n      justify-content: flex-start;\n}\n.search[_ngcontent-%COMP%]   .top[_ngcontent-%COMP%]   .mark-classify[_ngcontent-%COMP%]   nz-cascader[_ngcontent-%COMP%], .search[_ngcontent-%COMP%]   .top[_ngcontent-%COMP%]   .select-time[_ngcontent-%COMP%]   nz-cascader[_ngcontent-%COMP%] {\n  -ms-flex: 1;\n      flex: 1;\n}\n.search[_ngcontent-%COMP%]   .top[_ngcontent-%COMP%]   .mark-classify[_ngcontent-%COMP%]   span[_ngcontent-%COMP%], .search[_ngcontent-%COMP%]   .top[_ngcontent-%COMP%]   .select-time[_ngcontent-%COMP%]   span[_ngcontent-%COMP%] {\n  display: -ms-flexbox;\n  display: flex;\n  width: 75px;\n}\n.search[_ngcontent-%COMP%]   .bottom[_ngcontent-%COMP%] {\n  margin-top: 10px;\n  background: #fff;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAvYnVzaW5lc3MvZ2VvLWxhYmVsL3NpZ24vbGFiZWwtc2VhcmNoL0U6XFxQcm9qMjAyMFxc56m66Ze06LWE5rqQ5pm65oWn566h55CGXFxHZW9MYWJlbC9zcmNcXGFwcFxcYnVzaW5lc3NcXGdlby1sYWJlbFxcc2lnblxcbGFiZWwtc2VhcmNoXFxsYWJlbC1zZWFyY2guY29tcG9uZW50LnNjc3MiLCJzcmMvYXBwL2J1c2luZXNzL2dlby1sYWJlbC9zaWduL2xhYmVsLXNlYXJjaC9sYWJlbC1zZWFyY2guY29tcG9uZW50LnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7RUFDRSxZQUFBO0VBQ0EsMkNBQUE7QUNDRjtBREFFO0VBRUUsYUFBQTtFQUNBLG1CQUFBO0FDQ0o7QURBSTtFQUNFLFlBQUE7RUFDQSxvQkFBQTtFQUFBLGFBQUE7RUFDQSxzQkFBQTtNQUFBLG1CQUFBO0VBQ0Esc0JBQUE7TUFBQSw4QkFBQTtFQUNBLGlDQUFBO0VBQ0EsY0FBQTtBQ0VOO0FERE07RUFDRSxlQUFBO0FDR1I7QURBSTs7RUFFRSxnQkFBQTtFQUNBLG9CQUFBO0VBQUEsYUFBQTtFQUNBLHNCQUFBO01BQUEsbUJBQUE7RUFDQSxvQkFBQTtNQUFBLDJCQUFBO0FDRU47QURETTs7RUFDRSxXQUFBO01BQUEsT0FBQTtBQ0lSO0FERk07O0VBQ0Usb0JBQUE7RUFBQSxhQUFBO0VBQ0EsV0FBQTtBQ0tSO0FEREU7RUFDSSxnQkFBQTtFQUNBLGdCQUFBO0FDR04iLCJmaWxlIjoic3JjL2FwcC9idXNpbmVzcy9nZW8tbGFiZWwvc2lnbi9sYWJlbC1zZWFyY2gvbGFiZWwtc2VhcmNoLmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsiLnNlYXJjaCB7XHJcbiAgd2lkdGg6IDM4MHB4O1xyXG4gIGJveC1zaGFkb3c6IDBweCAxcHggMTBweCByZ2JhKDAsIDAsIDAsIDAuMSk7XHJcbiAgLnRvcCB7XHJcbiAgICAvLyBoZWlnaHQ6IDIxMHB4O1xyXG4gICAgcGFkZGluZzogMTZweDtcclxuICAgIGJhY2tncm91bmQ6ICNmZmZmZmY7XHJcbiAgICAuY29uZGl0aW9uIHtcclxuICAgICAgaGVpZ2h0OiA1NHB4O1xyXG4gICAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XHJcbiAgICAgIGJvcmRlci1ib3R0b206IDFweCBkYXNoZWQgI2Q5ZDlkOTtcclxuICAgICAgY29sb3I6ICMxODkwZmY7XHJcbiAgICAgIC50b2dnbGUsLmNsZWFye1xyXG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLm1hcmstY2xhc3NpZnksXHJcbiAgICAuc2VsZWN0LXRpbWUge1xyXG4gICAgICBtYXJnaW4tdG9wOiAxNnB4O1xyXG4gICAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XHJcbiAgICAgIG56LWNhc2NhZGVye1xyXG4gICAgICAgIGZsZXg6IDE7XHJcbiAgICAgIH1cclxuICAgICAgc3BhbiB7XHJcbiAgICAgICAgZGlzcGxheTogZmxleDtcclxuICAgICAgICB3aWR0aDogNzVweDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICAuYm90dG9tIHtcclxuICAgICAgbWFyZ2luLXRvcDogMTBweDtcclxuICAgICAgYmFja2dyb3VuZDogI2ZmZjtcclxuICB9XHJcbn1cclxuIiwiLnNlYXJjaCB7XG4gIHdpZHRoOiAzODBweDtcbiAgYm94LXNoYWRvdzogMHB4IDFweCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4xKTtcbn1cbi5zZWFyY2ggLnRvcCB7XG4gIHBhZGRpbmc6IDE2cHg7XG4gIGJhY2tncm91bmQ6ICNmZmZmZmY7XG59XG4uc2VhcmNoIC50b3AgLmNvbmRpdGlvbiB7XG4gIGhlaWdodDogNTRweDtcbiAgZGlzcGxheTogZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICBib3JkZXItYm90dG9tOiAxcHggZGFzaGVkICNkOWQ5ZDk7XG4gIGNvbG9yOiAjMTg5MGZmO1xufVxuLnNlYXJjaCAudG9wIC5jb25kaXRpb24gLnRvZ2dsZSwgLnNlYXJjaCAudG9wIC5jb25kaXRpb24gLmNsZWFyIHtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuLnNlYXJjaCAudG9wIC5tYXJrLWNsYXNzaWZ5LFxuLnNlYXJjaCAudG9wIC5zZWxlY3QtdGltZSB7XG4gIG1hcmdpbi10b3A6IDE2cHg7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcbn1cbi5zZWFyY2ggLnRvcCAubWFyay1jbGFzc2lmeSBuei1jYXNjYWRlcixcbi5zZWFyY2ggLnRvcCAuc2VsZWN0LXRpbWUgbnotY2FzY2FkZXIge1xuICBmbGV4OiAxO1xufVxuLnNlYXJjaCAudG9wIC5tYXJrLWNsYXNzaWZ5IHNwYW4sXG4uc2VhcmNoIC50b3AgLnNlbGVjdC10aW1lIHNwYW4ge1xuICBkaXNwbGF5OiBmbGV4O1xuICB3aWR0aDogNzVweDtcbn1cbi5zZWFyY2ggLmJvdHRvbSB7XG4gIG1hcmdpbi10b3A6IDEwcHg7XG4gIGJhY2tncm91bmQ6ICNmZmY7XG59Il19 */"], changeDetection: 0 });
    return LabelSearchComponent;
}());

/*@__PURE__*/ (function () { _angular_core__WEBPACK_IMPORTED_MODULE_0__["setClassMetadata"](LabelSearchComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
                selector: 'app-label-search',
                templateUrl: './label-search.component.html',
                styleUrls: ['./label-search.component.scss'],
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                providers: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["DatePipe"]],
            }]
    }], function () { return [{ type: _sign_component__WEBPACK_IMPORTED_MODULE_3__["SignComponent"] }, { type: _angular_common__WEBPACK_IMPORTED_MODULE_2__["DatePipe"] }, { type: _sign_service__WEBPACK_IMPORTED_MODULE_4__["SignService"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] }, { type: _angular_router__WEBPACK_IMPORTED_MODULE_5__["ActivatedRoute"] }]; }, { tagList: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }], defaultSearchParams: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }], search: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }] }); })();


/***/ }),

/***/ "./src/app/business/geo-label/sign/services/edit-tool.service.ts":
/*!***********************************************************************!*\
  !*** ./src/app/business/geo-label/sign/services/edit-tool.service.ts ***!
  \***********************************************************************/
/*! exports provided: EditToolService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EditToolService", function() { return EditToolService; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/__ivy_ngcc__/fesm5/core.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm5/index.js");



var EditToolService = /** @class */ (function () {
    function EditToolService() {
        // 
        this.subAdd = new rxjs__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
        this.addFeature$ = this.subAdd.asObservable();
        // 
        this.subEdit = new rxjs__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
        this.editFeature$ = this.subEdit.asObservable();
        //
        this.subDelete = new rxjs__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
        this.deleteFeature$ = this.subDelete.asObservable();
        //  to map
        this.subAddToMap = new rxjs__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
        this.addToMap$ = this.subAddToMap.asObservable();
        //  to map
        this.subToggleTool = new rxjs__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
        this.toggleTool$ = this.subToggleTool.asObservable();
    }
    EditToolService.prototype.addFeature = function (feature) {
        this.subAdd.next(feature);
    };
    EditToolService.prototype.editFeature = function (feature) {
        this.subEdit.next(feature);
    };
    EditToolService.prototype.deleteFeature = function (feature) {
        this.subDelete.next(feature);
    };
    EditToolService.prototype.addFeatureToMap = function (features) {
        this.subAddToMap.next(features);
    };
    EditToolService.prototype.toggleTool = function (boolean) {
        this.subToggleTool.next(boolean);
    };
    EditToolService.fac = function EditToolService_Factory(t) { return new (t || EditToolService)(); };
    EditToolService.prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["defineInjectable"]({ token: EditToolService, factory: EditToolService.fac });
    return EditToolService;
}());

/*@__PURE__*/ (function () { _angular_core__WEBPACK_IMPORTED_MODULE_0__["setClassMetadata"](EditToolService, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"]
    }], function () { return []; }, null); })();


/***/ }),

/***/ "./src/app/business/geo-label/sign/sigin.routing.ts":
/*!**********************************************************!*\
  !*** ./src/app/business/geo-label/sign/sigin.routing.ts ***!
  \**********************************************************/
/*! exports provided: SiginRoutes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SiginRoutes", function() { return SiginRoutes; });
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/router */ "./node_modules/@angular/router/__ivy_ngcc__/fesm5/router.js");
/* harmony import */ var _sign_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sign.component */ "./src/app/business/geo-label/sign/sign.component.ts");


var routes = [
    {
        path: "",
        component: _sign_component__WEBPACK_IMPORTED_MODULE_1__["SignComponent"]
    },
];
var SiginRoutes = _angular_router__WEBPACK_IMPORTED_MODULE_0__["RouterModule"].forChild(routes);


/***/ }),

/***/ "./src/app/business/geo-label/sign/sign.component.ts":
/*!***********************************************************!*\
  !*** ./src/app/business/geo-label/sign/sign.component.ts ***!
  \***********************************************************/
/*! exports provided: SignComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SignComponent", function() { return SignComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/__ivy_ngcc__/fesm5/core.js");
/* harmony import */ var cityfun_gl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cityfun-gl */ "./node_modules/cityfun-gl/dist/cityfun.min.js");
/* harmony import */ var cityfun_gl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(cityfun_gl__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_mapTool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/mapTool */ "./src/app/business/geo-label/utils/mapTool.ts");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/__ivy_ngcc__/fesm5/common.js");
/* harmony import */ var _utils_main_format__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/main-format */ "./src/app/business/geo-label/utils/main-format.ts");
/* harmony import */ var _styles_style__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./styles/style */ "./src/app/business/geo-label/sign/styles/style.ts");
/* harmony import */ var src_app_cityfun_mapbox_map_service_mapboxmap_service__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! src/app/cityfun/mapbox-map/service/mapboxmap.service */ "./src/app/cityfun/mapbox-map/service/mapboxmap.service.ts");
/* harmony import */ var _sign_service__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./sign.service */ "./src/app/business/geo-label/sign/sign.service.ts");
/* harmony import */ var _services_edit_tool_service__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./services/edit-tool.service */ "./src/app/business/geo-label/sign/services/edit-tool.service.ts");
/* harmony import */ var ng_zorro_antd__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ng-zorro-antd */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd.js");
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/router */ "./node_modules/@angular/router/__ivy_ngcc__/fesm5/router.js");












function SignComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    var _r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["getCurrentView"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementContainerStart"](0);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](1, "lb-label-detail", 5);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["listener"]("close", function SignComponent_ng_container_1_Template_lb_label_detail_close_1_listener() { _angular_core__WEBPACK_IMPORTED_MODULE_0__["restoreView"](_r6); var ctx_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](); return ctx_r5.closeDetail(); });
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementContainerEnd"]();
} if (rf & 2) {
    var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("data", ctx_r0.tagDetailInfo)("isEdit", ctx_r0.isEdit);
} }
function SignComponent_ng_container_2_app_label_search_1_Template(rf, ctx) { if (rf & 1) {
    var _r10 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["getCurrentView"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](0, "app-label-search", 7);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["listener"]("search", function SignComponent_ng_container_2_app_label_search_1_Template_app_label_search_search_0_listener($event) { _angular_core__WEBPACK_IMPORTED_MODULE_0__["restoreView"](_r10); var ctx_r9 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](2); return ctx_r9.doSearch($event); });
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
} if (rf & 2) {
    var ctx_r7 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](2);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("tagList", ctx_r7.tagList);
} }
function SignComponent_ng_container_2_app_label_add_2_Template(rf, ctx) { if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["element"](0, "app-label-add");
} }
function SignComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementContainerStart"](0);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](1, SignComponent_ng_container_2_app_label_search_1_Template, 1, 1, "app-label-search", 6);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](2, SignComponent_ng_container_2_app_label_add_2_Template, 1, 0, "app-label-add", 1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementContainerEnd"]();
} if (rf & 2) {
    var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngIf", ctx_r1.markerStatue != 2);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngIf", ctx_r1.markerStatue == 2);
} }
function SignComponent_div_3_div_4_Template(rf, ctx) { if (rf & 1) {
    var _r13 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["getCurrentView"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](0, "div", 12);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](1, "button", 13);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["listener"]("click", function SignComponent_div_3_div_4_Template_button_click_1_listener() { _angular_core__WEBPACK_IMPORTED_MODULE_0__["restoreView"](_r13); var ctx_r12 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](2); return ctx_r12.stopMarker(); });
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](2, "\u53D6\u6D88");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
} }
function SignComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    var _r15 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["getCurrentView"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](0, "div", 8);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](1, "button", 9);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["listener"]("click", function SignComponent_div_3_Template_button_click_1_listener() { _angular_core__WEBPACK_IMPORTED_MODULE_0__["restoreView"](_r15); var ctx_r14 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](); return ctx_r14.addMarker(); });
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["element"](2, "i", 10);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["text"](3, "\u6DFB\u52A0\u6807\u8BB0 ");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](4, SignComponent_div_3_div_4_Template, 3, 0, "div", 11);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
} if (rf & 2) {
    var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](4);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngIf", ctx_r2.markerStatue != 0);
} }
function SignComponent_div_4_Template(rf, ctx) { if (rf & 1) {
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](0, "div", 14);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["element"](1, "lb-edit-tool");
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
} }
function SignComponent_div_5_Template(rf, ctx) { if (rf & 1) {
    var _r17 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["getCurrentView"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](0, "div", 15);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](1, "lb-label-legend", 16);
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["listener"]("legendToggle", function SignComponent_div_5_Template_lb_label_legend_legendToggle_1_listener($event) { _angular_core__WEBPACK_IMPORTED_MODULE_0__["restoreView"](_r17); var ctx_r16 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["nextContext"](); return ctx_r16.legendToggle($event); });
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
    _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
} }
var SignComponent = /** @class */ (function () {
    function SignComponent(mapboxMapService, doc, signService, editToolService, cdr, nzMessageService, appref, route) {
        var _this = this;
        this.mapboxMapService = mapboxMapService;
        this.doc = doc;
        this.signService = signService;
        this.editToolService = editToolService;
        this.cdr = cdr;
        this.nzMessageService = nzMessageService;
        this.appref = appref;
        this.route = route;
        this.modelName = 'sign';
        this.toggleEditTool$ = null;
        this.mapboxMap = null;
        this.markerStatue = _utils_mapTool__WEBPACK_IMPORTED_MODULE_2__["MarkerStatue"].none; // 
        this.moveMarker = null;
        this.editMarker = null;
        this.showEditTool = false;
        this.showTagDetail = false;
        this.tagDetailInfo = null;
        this.tagList = null;
        this.totalCount = 0;
        this.isEdit = false;
        this.eventCallBack = {
        // key: function () {},
        };
        this.defaultSearchParams = {
            keyWord: '',
            categoryId: '',
            startTime: '',
            endTime: '',
            pageSize: 9,
            pageNo: 1,
        };
        this.route.data.subscribe(function (data) {
            _this.modelName = data.path;
        });
    }
    SignComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.mapboxMapService
            .init()
            .pipe()
            .subscribe(function (mapboxMap) {
            _this.mapboxMap = mapboxMap;
            if (mapboxMap.isStyleLoaded() &&
                _this.mapboxMapService.firstFullLoaded) {
                _this.mapInit();
            }
            _this.mapboxMap.on('load', function () {
                _this.mapInit();
            });
            _this.cdr.markForCheck();
        });
        this.toggleEditTool$ = this.editToolService.toggleTool$.subscribe(function (isShow) {
            _this.showEditTool = isShow;
        });
    };
    SignComponent.prototype.mapInit = function () {
        this.bindMapEvent();
        this.addGroupLayer();
        this.getTags(null);
        this.getAllTagListPoint();
    };
    SignComponent.prototype.addGroupLayer = function () {
        this.mapboxMapService.removeLayerByIds([
            'cityfun.null.2',
            'cityfun.null.1',
        ]);
        this.mapboxMap.addLayer({
            id: 'cityfun.null.2',
            type: 'fill',
            source: {
                type: 'geojson',
                data: null,
            },
        });
        this.mapboxMap.addLayer({
            id: 'cityfun.null.1',
            type: 'line',
            source: {
                type: 'geojson',
                data: null,
            },
        });
    };
    SignComponent.prototype.bindMapEvent = function () {
        var self = this;
        Object(_utils_mapTool__WEBPACK_IMPORTED_MODULE_2__["offMapEvent"])(this.mapboxMap, 'click', 'search-tag-layer-click', this.eventCallBack, 'search-tag-layer');
        Object(_utils_mapTool__WEBPACK_IMPORTED_MODULE_2__["offMapEvent"])(this.mapboxMap, 'click', 'all-tag-points-my-click', this.eventCallBack, 'all-tag-points-my');
        Object(_utils_mapTool__WEBPACK_IMPORTED_MODULE_2__["offMapEvent"])(this.mapboxMap, 'click', 'all-tag-points-other-click', this.eventCallBack, 'all-tag-points-other');
        // 
        this.eventCallBack['search-tag-layer-click'] = function (e) {
            if (Object(_utils_mapTool__WEBPACK_IMPORTED_MODULE_2__["preventMapDefault"])(e)) {
                return;
            }
            if (e.features && e.features.length) {
                var tagid = e.features[0].properties.tagid;
                self.getTagDetail(tagid);
            }
        };
        this.eventCallBack['all-tag-points-my-click'] = function (e) {
            if (Object(_utils_mapTool__WEBPACK_IMPORTED_MODULE_2__["preventMapDefault"])(e)) {
                return;
            }
            if (e.features && e.features.length) {
                var tagid = e.features[0].properties.tagid;
                self.getTagDetail(tagid);
            }
        };
        this.eventCallBack['all-tag-points-other-click'] = function (e) {
            if (Object(_utils_mapTool__WEBPACK_IMPORTED_MODULE_2__["preventMapDefault"])(e)) {
                return;
            }
            if (e.features && e.features.length) {
                var tagid = e.features[0].properties.tagid;
                self.getTagDetail(tagid);
            }
        };
        this.mapboxMap.on('click', 'search-tag-layer', this.eventCallBack['search-tag-layer-click']);
        this.mapboxMap.on('click', 'all-tag-points-my', this.eventCallBack['all-tag-points-my-click']);
        this.mapboxMap.on('click', 'all-tag-points-other', this.eventCallBack['all-tag-points-other-click']);
    };
    /**
     * 
     */
    SignComponent.prototype.addMarker = function () {
        var self = this;
        this.markerStatue = _utils_mapTool__WEBPACK_IMPORTED_MODULE_2__["MarkerStatue"].moveing;
        this.mapboxMapService.setCursor('default');
        // 
        Object(_utils_mapTool__WEBPACK_IMPORTED_MODULE_2__["offMapEvent"])(this.mapboxMap, 'mousemove', 'mousemove-addTag', this.eventCallBack);
        // 
        Object(_utils_mapTool__WEBPACK_IMPORTED_MODULE_2__["offMapEvent"])(this.mapboxMap, 'click', 'click-map', this.eventCallBack);
        this.eventCallBack['mousemove-addTag'] = function (e) {
            var _a = e.lngLat, lng = _a.lng, lat = _a.lat;
            self.addMoveMarker([lng, lat], true);
        };
        this.eventCallBack['click-map'] = function (e) {
            self.tagDetailInfo = null;
            var _a = e.lngLat, lng = _a.lng, lat = _a.lat;
            self.addMoveMarker([lng, lat], false);
            self.mapboxMapService.setCursor('grab');
            self.markerStatue = _utils_mapTool__WEBPACK_IMPORTED_MODULE_2__["MarkerStatue"].editing;
            self.appref.tick();
            self.cdr.markForCheck();
            Object(_utils_mapTool__WEBPACK_IMPORTED_MODULE_2__["offMapEvent"])(self.mapboxMap, 'mousemove', 'mousemove-addTag', self.eventCallBack);
        };
        this.mapboxMap.on('mousemove', this.eventCallBack['mousemove-addTag']);
        this.mapboxMap.once('click', this.eventCallBack['click-map']);
    };
    /**
     * 
     */
    SignComponent.prototype.stopMarker = function () {
        Object(_utils_mapTool__WEBPACK_IMPORTED_MODULE_2__["offMapEvent"])(this.mapboxMap, 'mousemove', 'mousemove-addTag', this.eventCallBack);
        this.markerStatue = _utils_mapTool__WEBPACK_IMPORTED_MODULE_2__["MarkerStatue"].none;
        if (this.moveMarker) {
            this.moveMarker.remove();
            this.moveMarker = null;
        }
        if (this.editMarker) {
            this.editMarker.remove();
            this.editMarker = null;
        }
        this.mapboxMapService.setCursor('default');
        this.showEditTool = false;
    };
    SignComponent.prototype.addMoveMarker = function (coordinate, isMoveing) {
        var el = this.doc.createElement('div');
        el.className = 'add-marker marker';
        el.style.backgroundImage = 'url(./assets/img/map/cursor_mark.png)';
        el.style.width = '24px';
        el.style.height = '36px';
        if (isMoveing) {
            if (this.moveMarker) {
                this.moveMarker.setLngLat(coordinate);
            }
            else {
                this.moveMarker = new cityfun_gl__WEBPACK_IMPORTED_MODULE_1___default.a.Marker({
                    element: el,
                    offset: [0, -20],
                })
                    .setLngLat(coordinate)
                    .addTo(this.mapboxMap);
            }
        }
        else {
            if (this.editMarker) {
                this.editMarker.setLngLat(coordinate);
            }
            else {
                this.editMarker = new cityfun_gl__WEBPACK_IMPORTED_MODULE_1___default.a.Marker({
                    element: el,
                    offset: [0, -20],
                })
                    .setLngLat(coordinate)
                    .addTo(this.mapboxMap);
            }
        }
    };
    /**
     * 
     * @param searchParams
     */
    SignComponent.prototype.doSearch = function (searchParams) {
        this.getTags(searchParams);
    };
    SignComponent.prototype.closeDetail = function () {
        this.markerStatue = _utils_mapTool__WEBPACK_IMPORTED_MODULE_2__["MarkerStatue"].none;
        this.tagDetailInfo = null;
        this.getTags(null);
    };
    SignComponent.prototype.drawTags = function (style, iconUrl, layerid, beforeId) {
        var _this = this;
        this.mapboxMapService.removeLayerByIds([layerid]);
        this.mapboxMap.loadImage(iconUrl, function (error, image) {
            _this.mapboxMap.addImage(layerid, image);
            _this.mapboxMap.addLayer(style, beforeId);
        });
    };
    SignComponent.prototype.hideTagFeatures = function (ids) {
        if (ids.length <= 0) {
            this.mapboxMap.setFilter('search-tag-layer', null);
            return;
        }
        this.mapboxMap.setFilter('search-tag-layer', [
            'match',
            ['get', 'tagid'],
            ids.map(function (item) {
                return item;
            }),
            false,
            true,
        ]);
    };
    SignComponent.prototype.toggleDetail = function (tagid) {
        this.showTagDetail = true;
        this.getTagDetail(tagid);
    };
    /**
     * 
     * @param tagid
     */
    SignComponent.prototype.getTagDetail = function (tagid) {
        var _this = this;
        this.markerStatue = _utils_mapTool__WEBPACK_IMPORTED_MODULE_2__["MarkerStatue"].none;
        this.signService
            .getTagDetail({ tagid: tagid })
            .subscribe(function (result) {
            _this.tagDetailInfo = result;
            _this.appref.tick();
            _this.cdr.markForCheck();
        });
    };
    /**
     * tag 
     * @param searchParams
     */
    SignComponent.prototype.getTags = function (searchParams) {
        var _this = this;
        var params = null;
        if (!searchParams) {
            params = this.defaultSearchParams;
        }
        else {
            params = searchParams;
        }
        var methods = this.modelName == 'sign' ? 'getTagList' : "getCollectList";
        this.signService[methods](params)
            .subscribe(function (searchTagResult) {
            _this.tagList = searchTagResult;
            var geoSource = Object(_utils_main_format__WEBPACK_IMPORTED_MODULE_4__["listWktToGeoJson"])(searchTagResult.list, 'geom');
            var style = Object(_styles_style__WEBPACK_IMPORTED_MODULE_5__["getSageNationTagsStyle"])('search-tag-layer', geoSource);
            _this.drawTags(style, './assets/img/map/pin.png', 'search-tag-layer', 'cityfun.null.1');
            _this.cdr.markForCheck();
        });
    };
    SignComponent.prototype.getAllTagListPoint = function () {
        var _this = this;
        var methods = this.modelName == 'sign' ? 'getAllTagListPoint' : "getAllCollecPoint";
        this.signService[methods](null)
            .subscribe(function (tagList) {
            var myTags = [], otherTags = [];
            tagList.forEach(function (item) {
                if (item.status in [0, 1]) {
                    myTags.push(item);
                }
                else {
                    otherTags.push(item);
                }
            });
            var myTagSource = Object(_utils_main_format__WEBPACK_IMPORTED_MODULE_4__["listWktToGeoJson"])(myTags, 'geom');
            var otherTagSource = Object(_utils_main_format__WEBPACK_IMPORTED_MODULE_4__["listWktToGeoJson"])(otherTags, 'geom');
            var myTagStyle = Object(_styles_style__WEBPACK_IMPORTED_MODULE_5__["getAllTagsStyle"])('all-tag-points-my', myTagSource);
            var otherTagStyle = Object(_styles_style__WEBPACK_IMPORTED_MODULE_5__["getAllTagsStyle"])('all-tag-points-other', otherTagSource);
            _this.drawTags(myTagStyle, './assets/img/map/icon_map_switch_mine.png', 'all-tag-points-my', 'cityfun.null.2');
            _this.drawTags(otherTagStyle, './assets/img/map/icon_map_switch_others.png', 'all-tag-points-other', 'cityfun.null.2');
            _this.cdr.markForCheck();
        });
    };
    /**
     * 
     * @param legnedIem
     */
    SignComponent.prototype.legendToggle = function (legnedIem) {
        var visibility = legnedIem.active ? 'visible' : 'none';
        this.mapboxMap.setLayoutProperty(legnedIem.id, 'visibility', visibility);
    };
    /**
     * 
     * @param data
     */
    SignComponent.prototype.toggleSub = function (data) {
        var _this = this;
        var tagid = data.tagid, issubscribe = data.issubscribe;
        var msg = issubscribe == 1 ? '' : '';
        this.signService
            .toggleSub({
            tagid: tagid,
            isSubscribe: issubscribe == 1 ? 0 : 1,
        })
            .subscribe(function (res) {
            _this.cdr.markForCheck();
            if (res) {
                _this.doSearch(null);
                _this.nzMessageService.success(msg + '!');
            }
            else {
                _this.nzMessageService.error(msg + '!');
            }
        });
    };
    SignComponent.prototype.ngOnDestroy = function () {
        this.mapboxMapService.removeLayerByIds([
            'all-tag-points-my',
            'all-tag-points-other',
            'search-tag-layer',
        ]);
        this.editMarker && this.editMarker.remove();
        this.moveMarker && this.moveMarker.remove();
    };
    SignComponent.fac = function SignComponent_Factory(t) { return new (t || SignComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](src_app_cityfun_mapbox_map_service_mapboxmap_service__WEBPACK_IMPORTED_MODULE_6__["MapboxmapService"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](_angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](_sign_service__WEBPACK_IMPORTED_MODULE_7__["SignService"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](_services_edit_tool_service__WEBPACK_IMPORTED_MODULE_8__["EditToolService"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](ng_zorro_antd__WEBPACK_IMPORTED_MODULE_9__["NzMessageService"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__["ApplicationRef"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__["directiveInject"](_angular_router__WEBPACK_IMPORTED_MODULE_10__["ActivatedRoute"])); };
    SignComponent.cmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["defineComponent"]({ type: SignComponent, selectors: [["app-sign"]], decls: 6, vars: 5, consts: [[1, "wrapper"], [4, "ngIf"], ["class", "add-mark", 4, "ngIf"], ["class", "edit-tool", 4, "ngIf"], ["class", "legend", 4, "ngIf"], [3, "data", "isEdit", "close"], [3, "tagList", "search", 4, "ngIf"], [3, "tagList", "search"], [1, "add-mark"], ["nz-button", "", "nzType", "primary", 3, "click"], ["nz-icon", "", "nzType", "plus", "nzTheme", "outline"], ["class", "cancel", 4, "ngIf"], [1, "cancel"], ["nz-button", "", "nzType", "default", 3, "click"], [1, "edit-tool"], [1, "legend"], [3, "legendToggle"]], template: function SignComponent_Template(rf, ctx) { if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementStart"](0, "div", 0);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](1, SignComponent_ng_container_1_Template, 2, 2, "ng-container", 1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](2, SignComponent_ng_container_2_Template, 3, 2, "ng-container", 1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](3, SignComponent_div_3_Template, 5, 1, "div", 2);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](4, SignComponent_div_4_Template, 2, 0, "div", 3);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["template"](5, SignComponent_div_5_Template, 2, 0, "div", 4);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["elementEnd"]();
        } if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngIf", ctx.tagDetailInfo);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngIf", !ctx.tagDetailInfo);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngIf", ctx.modelName == "sign");
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngIf", ctx.showEditTool);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["advance"](1);
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["property"]("ngIf", ctx.modelName == "sign");
        } }, styles: [".wrapper[_ngcontent-%COMP%] {\n  width: 100%;\n  height: 100%;\n  padding: 20px;\n}\n.wrapper[_ngcontent-%COMP%]   .add-mark[_ngcontent-%COMP%] {\n  position: absolute;\n  top: 20px;\n  right: 342px;\n  pointer-events: all;\n}\n.wrapper[_ngcontent-%COMP%]   .add-mark[_ngcontent-%COMP%]   .cancel[_ngcontent-%COMP%] {\n  display: -ms-flexbox;\n  display: flex;\n  margin-top: 4px;\n  -ms-flex-pack: end;\n      justify-content: flex-end;\n}\n.wrapper[_ngcontent-%COMP%]   .add-mark[_ngcontent-%COMP%]   .cancel[_ngcontent-%COMP%]   button[_ngcontent-%COMP%] {\n  text-align: center;\n  height: 32px;\n}\n.wrapper[_ngcontent-%COMP%]   .edit-tool[_ngcontent-%COMP%] {\n  position: absolute;\n  top: 20px;\n  left: 480px;\n}\n.wrapper[_ngcontent-%COMP%]   .legend[_ngcontent-%COMP%] {\n  position: fixed;\n  bottom: 20px;\n  right: 20px;\n}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAvYnVzaW5lc3MvZ2VvLWxhYmVsL3NpZ24vRTpcXFByb2oyMDIwXFznqbrpl7TotYTmupDmmbrmhafnrqHnkIZcXEdlb0xhYmVsL3NyY1xcYXBwXFxidXNpbmVzc1xcZ2VvLWxhYmVsXFxzaWduXFxzaWduLmNvbXBvbmVudC5zY3NzIiwic3JjL2FwcC9idXNpbmVzcy9nZW8tbGFiZWwvc2lnbi9zaWduLmNvbXBvbmVudC5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0VBQ0UsV0FBQTtFQUNBLFlBQUE7RUFDQSxhQUFBO0FDQ0Y7QURBRTtFQUNFLGtCQUFBO0VBQ0EsU0FBQTtFQUNBLFlBQUE7RUFDQSxtQkFBQTtBQ0VKO0FEQUk7RUFDRSxvQkFBQTtFQUFBLGFBQUE7RUFDQSxlQUFBO0VBQ0Esa0JBQUE7TUFBQSx5QkFBQTtBQ0VOO0FERE07RUFDRSxrQkFBQTtFQUNBLFlBQUE7QUNHUjtBRENFO0VBQ0Usa0JBQUE7RUFDQSxTQUFBO0VBQ0EsV0FBQTtBQ0NKO0FEQ0U7RUFDRSxlQUFBO0VBQ0EsWUFBQTtFQUNBLFdBQUE7QUNDSiIsImZpbGUiOiJzcmMvYXBwL2J1c2luZXNzL2dlby1sYWJlbC9zaWduL3NpZ24uY29tcG9uZW50LnNjc3MiLCJzb3VyY2VzQ29udGVudCI6WyIud3JhcHBlciB7XHJcbiAgd2lkdGg6IDEwMCU7XHJcbiAgaGVpZ2h0OiAxMDAlO1xyXG4gIHBhZGRpbmc6IDIwcHg7XHJcbiAgLmFkZC1tYXJrIHtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgIHRvcDogMjBweDtcclxuICAgIHJpZ2h0OiAzNDJweDtcclxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XHJcblxyXG4gICAgLmNhbmNlbCB7XHJcbiAgICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICAgIG1hcmdpbi10b3A6IDRweDtcclxuICAgICAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcclxuICAgICAgYnV0dG9uIHtcclxuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcbiAgICAgICAgaGVpZ2h0OiAzMnB4O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIC5lZGl0LXRvb2wge1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgdG9wOiAyMHB4O1xyXG4gICAgbGVmdDogNDgwcHg7XHJcbiAgfVxyXG4gIC5sZWdlbmR7XHJcbiAgICBwb3NpdGlvbjogZml4ZWQ7XHJcbiAgICBib3R0b206IDIwcHg7XHJcbiAgICByaWdodDogMjBweDtcclxuICB9XHJcbn1cclxuIiwiLndyYXBwZXIge1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiAxMDAlO1xuICBwYWRkaW5nOiAyMHB4O1xufVxuLndyYXBwZXIgLmFkZC1tYXJrIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDIwcHg7XG4gIHJpZ2h0OiAzNDJweDtcbiAgcG9pbnRlci1ldmVudHM6IGFsbDtcbn1cbi53cmFwcGVyIC5hZGQtbWFyayAuY2FuY2VsIHtcbiAgZGlzcGxheTogZmxleDtcbiAgbWFyZ2luLXRvcDogNHB4O1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xufVxuLndyYXBwZXIgLmFkZC1tYXJrIC5jYW5jZWwgYnV0dG9uIHtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xuICBoZWlnaHQ6IDMycHg7XG59XG4ud3JhcHBlciAuZWRpdC10b29sIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDIwcHg7XG4gIGxlZnQ6IDQ4MHB4O1xufVxuLndyYXBwZXIgLmxlZ2VuZCB7XG4gIHBvc2l0aW9uOiBmaXhlZDtcbiAgYm90dG9tOiAyMHB4O1xuICByaWdodDogMjBweDtcbn0iXX0= */"], changeDetection: 0 });
    return SignComponent;
}());

/*@__PURE__*/ (function () { _angular_core__WEBPACK_IMPORTED_MODULE_0__["setClassMetadata"](SignComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"],
        args: [{
                selector: 'app-sign',
                templateUrl: './sign.component.html',
                styleUrls: ['./sign.component.scss'],
                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
            }]
    }], function () { return [{ type: src_app_cityfun_mapbox_map_service_mapboxmap_service__WEBPACK_IMPORTED_MODULE_6__["MapboxmapService"] }, { type: Document, decorators: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"],
                args: [_angular_common__WEBPACK_IMPORTED_MODULE_3__["DOCUMENT"]]
            }] }, { type: _sign_service__WEBPACK_IMPORTED_MODULE_7__["SignService"] }, { type: _services_edit_tool_service__WEBPACK_IMPORTED_MODULE_8__["EditToolService"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] }, { type: ng_zorro_antd__WEBPACK_IMPORTED_MODULE_9__["NzMessageService"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ApplicationRef"] }, { type: _angular_router__WEBPACK_IMPORTED_MODULE_10__["ActivatedRoute"] }]; }, null); })();


/***/ }),

/***/ "./src/app/business/geo-label/sign/sign.module.ts":
/*!********************************************************!*\
  !*** ./src/app/business/geo-label/sign/sign.module.ts ***!
  \********************************************************/
/*! exports provided: SignModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SignModule", function() { return SignModule; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/__ivy_ngcc__/fesm5/core.js");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/__ivy_ngcc__/fesm5/common.js");
/* harmony import */ var _sign_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sign.component */ "./src/app/business/geo-label/sign/sign.component.ts");
/* harmony import */ var _sigin_routing__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sigin.routing */ "./src/app/business/geo-label/sign/sigin.routing.ts");
/* harmony import */ var _common_label_common_module__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/label-common.module */ "./src/app/business/geo-label/common/label-common.module.ts");
/* harmony import */ var _label_search_label_search_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./label-search/label-search.component */ "./src/app/business/geo-label/sign/label-search/label-search.component.ts");
/* harmony import */ var src_app_shared_shared_module__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! src/app/shared/shared.module */ "./src/app/shared/shared.module.ts");
/* harmony import */ var _label_add_label_add_component__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./label-add/label-add.component */ "./src/app/business/geo-label/sign/label-add/label-add.component.ts");
/* harmony import */ var _label_add_base_info_base_info_component__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./label-add/base-info/base-info.component */ "./src/app/business/geo-label/sign/label-add/base-info/base-info.component.ts");
/* harmony import */ var _label_add_label_feature_label_feature_component__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./label-add/label-feature/label-feature.component */ "./src/app/business/geo-label/sign/label-add/label-feature/label-feature.component.ts");
/* harmony import */ var _edit_tool_edit_tool_component__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./edit-tool/edit-tool.component */ "./src/app/business/geo-label/sign/edit-tool/edit-tool.component.ts");
/* harmony import */ var _services_edit_tool_service__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./services/edit-tool.service */ "./src/app/business/geo-label/sign/services/edit-tool.service.ts");
/* harmony import */ var _label_add_label_feature_addTagIcon_pipe__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./label-add/label-feature/addTagIcon.pipe */ "./src/app/business/geo-label/sign/label-add/label-feature/addTagIcon.pipe.ts");
/* harmony import */ var _label_add_label_success_label_success_component__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./label-add/label-success/label-success.component */ "./src/app/business/geo-label/sign/label-add/label-success/label-success.component.ts");
/* harmony import */ var _sign_service__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./sign.service */ "./src/app/business/geo-label/sign/sign.service.ts");
/* harmony import */ var _label_add_add_content_add_content_component__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./label-add/add-content/add-content.component */ "./src/app/business/geo-label/sign/label-add/add-content/add-content.component.ts");
/* harmony import */ var _label_detail_label_detail_component__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./label-detail/label-detail.component */ "./src/app/business/geo-label/sign/label-detail/label-detail.component.ts");
/* harmony import */ var _label_detail_label_detail_content_label_detail_content_component__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./label-detail/label-detail-content/label-detail-content.component */ "./src/app/business/geo-label/sign/label-detail/label-detail-content/label-detail-content.component.ts");
/* harmony import */ var _label_detail_feature_detail_feature_detail_component__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./label-detail/feature-detail/feature-detail.component */ "./src/app/business/geo-label/sign/label-detail/feature-detail/feature-detail.component.ts");
/* harmony import */ var _label_detail_label_comment_label_comment_component__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./label-detail/label-comment/label-comment.component */ "./src/app/business/geo-label/sign/label-detail/label-comment/label-comment.component.ts");
/* harmony import */ var _label_detail_label_baseinfo_label_baseinfo_component__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./label-detail/label-baseinfo/label-baseinfo.component */ "./src/app/business/geo-label/sign/label-detail/label-baseinfo/label-baseinfo.component.ts");
/* harmony import */ var _label_legend_label_legend_component__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./label-legend/label-legend.component */ "./src/app/business/geo-label/sign/label-legend/label-legend.component.ts");
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @angular/router */ "./node_modules/@angular/router/__ivy_ngcc__/fesm5/router.js");
/* harmony import */ var _common_label_container_label_container_component__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../common/label-container/label-container.component */ "./src/app/business/geo-label/common/label-container/label-container.component.ts");
/* harmony import */ var _common_label_list_label_list_component__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../common/label-list/label-list.component */ "./src/app/business/geo-label/common/label-list/label-list.component.ts");
/* harmony import */ var _common_add_marker_statue_add_marker_statue_component__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../common/add-marker-statue/add-marker-statue.component */ "./src/app/business/geo-label/common/add-marker-statue/add-marker-statue.component.ts");
/* harmony import */ var _common_counter_component_counter_component_component__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../common/counter-component/counter-component.component */ "./src/app/business/geo-label/common/counter-component/counter-component.component.ts");
/* harmony import */ var _common_form_tag_form_tag_component__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../common/form-tag/form-tag.component */ "./src/app/business/geo-label/common/form-tag/form-tag.component.ts");
/* harmony import */ var _common_tag_title_tag_title_component__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../common/tag-title/tag-title.component */ "./src/app/business/geo-label/common/tag-title/tag-title.component.ts");
/* harmony import */ var ng_zorro_antd_menu__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ng-zorro-antd/menu */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-menu.js");
/* harmony import */ var ng_zorro_antd_dropdown__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ng-zorro-antd/dropdown */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-dropdown.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/__ivy_ngcc__/fesm5/forms.js");
/* harmony import */ var _shared_components_side_menu_side_menu_component__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ../../../shared/components/side-menu/side-menu.component */ "./src/app/shared/components/side-menu/side-menu.component.ts");
/* harmony import */ var _shared_components_header_header_component__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ../../../shared/components/header/header.component */ "./src/app/shared/components/header/header.component.ts");
/* harmony import */ var _shared_components_cf_scroll_cf_scroll_component__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ../../../shared/components/cf-scroll/cf-scroll.component */ "./src/app/shared/components/cf-scroll/cf-scroll.component.ts");
/* harmony import */ var ng_zorro_antd_input__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ng-zorro-antd/input */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-input.js");
/* harmony import */ var ng_zorro_antd_tree__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ng-zorro-antd/tree */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-tree.js");
/* harmony import */ var ng_zorro_antd_layout__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ng-zorro-antd/layout */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-layout.js");
/* harmony import */ var ng_zorro_antd_icon__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ng-zorro-antd/icon */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-icon.js");
/* harmony import */ var ng_zorro_antd_breadcrumb__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ng-zorro-antd/breadcrumb */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-breadcrumb.js");
/* harmony import */ var ng_zorro_antd_button__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ng-zorro-antd/button */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-button.js");
/* harmony import */ var ng_zorro_antd_core_transition_patch__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ng-zorro-antd/core/transition-patch */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-core-transition-patch.js");
/* harmony import */ var ng_zorro_antd_core_wave__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ng-zorro-antd/core/wave */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-core-wave.js");
/* harmony import */ var ng_zorro_antd_pagination__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ng-zorro-antd/pagination */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-pagination.js");
/* harmony import */ var ng_zorro_antd_select__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ng-zorro-antd/select */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-select.js");
/* harmony import */ var ng_zorro_antd_date_picker__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ng-zorro-antd/date-picker */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-date-picker.js");
/* harmony import */ var ng_zorro_antd_grid__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ng-zorro-antd/grid */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-grid.js");
/* harmony import */ var ng_zorro_antd_form__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ng-zorro-antd/form */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-form.js");
/* harmony import */ var ng_zorro_antd_radio__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ng-zorro-antd/radio */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-radio.js");
/* harmony import */ var ng_zorro_antd_tag__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ng-zorro-antd/tag */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-tag.js");
/* harmony import */ var ng_zorro_antd_cascader__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ng-zorro-antd/cascader */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-cascader.js");
/* harmony import */ var ng_zorro_antd_popconfirm__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ng-zorro-antd/popconfirm */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-popconfirm.js");
/* harmony import */ var ng_zorro_antd_switch__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ng-zorro-antd/switch */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-switch.js");
/* harmony import */ var ng_zorro_antd_modal__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ng-zorro-antd/modal */ "./node_modules/ng-zorro-antd/__ivy_ngcc__/fesm5/ng-zorro-antd-modal.js");
























































var SignModule = /** @class */ (function () {
    function SignModule() {
    }
    SignModule.mod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["defineNgModule"]({ type: SignModule });
    SignModule.inj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["defineInjector"]({ factory: function SignModule_Factory(t) { return new (t || SignModule)(); }, providers: [_services_edit_tool_service__WEBPACK_IMPORTED_MODULE_11__["EditToolService"], _sign_service__WEBPACK_IMPORTED_MODULE_14__["SignService"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ApplicationRef"]], imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"], _sigin_routing__WEBPACK_IMPORTED_MODULE_3__["SiginRoutes"], _common_label_common_module__WEBPACK_IMPORTED_MODULE_4__["LabelCommonModule"], src_app_shared_shared_module__WEBPACK_IMPORTED_MODULE_6__["SharedModule"]]] });
    return SignModule;
}());

(function () { (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["setNgModuleScope"](SignModule, { declarations: [_label_add_base_info_base_info_component__WEBPACK_IMPORTED_MODULE_8__["BaseInfoComponent"],
        _sign_component__WEBPACK_IMPORTED_MODULE_2__["SignComponent"],
        _label_search_label_search_component__WEBPACK_IMPORTED_MODULE_5__["LabelSearchComponent"],
        _label_add_label_add_component__WEBPACK_IMPORTED_MODULE_7__["LabelAddComponent"],
        _label_add_label_feature_label_feature_component__WEBPACK_IMPORTED_MODULE_9__["LabelFeatureComponent"],
        _edit_tool_edit_tool_component__WEBPACK_IMPORTED_MODULE_10__["EditToolComponent"],
        _label_add_label_feature_addTagIcon_pipe__WEBPACK_IMPORTED_MODULE_12__["AddTagIconPipe"],
        _label_add_label_success_label_success_component__WEBPACK_IMPORTED_MODULE_13__["LabelSuccessComponent"],
        _label_add_add_content_add_content_component__WEBPACK_IMPORTED_MODULE_15__["AddContentComponent"],
        _label_detail_label_detail_component__WEBPACK_IMPORTED_MODULE_16__["LabelDetailComponent"],
        _label_detail_label_detail_content_label_detail_content_component__WEBPACK_IMPORTED_MODULE_17__["LabelDetailContentComponent"],
        _label_detail_feature_detail_feature_detail_component__WEBPACK_IMPORTED_MODULE_18__["FeatureDetailComponent"],
        _label_detail_label_comment_label_comment_component__WEBPACK_IMPORTED_MODULE_19__["LabelCommentComponent"],
        _label_detail_label_baseinfo_label_baseinfo_component__WEBPACK_IMPORTED_MODULE_20__["LabelBaseinfoComponent"],
        _label_legend_label_legend_component__WEBPACK_IMPORTED_MODULE_21__["LabelLegendComponent"]], imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"], _angular_router__WEBPACK_IMPORTED_MODULE_22__["RouterModule"], _common_label_common_module__WEBPACK_IMPORTED_MODULE_4__["LabelCommonModule"], src_app_shared_shared_module__WEBPACK_IMPORTED_MODULE_6__["SharedModule"]], exports: [_label_search_label_search_component__WEBPACK_IMPORTED_MODULE_5__["LabelSearchComponent"],
        _label_detail_label_detail_component__WEBPACK_IMPORTED_MODULE_16__["LabelDetailComponent"]] }); })();
/*@__PURE__*/ (function () { _angular_core__WEBPACK_IMPORTED_MODULE_0__["setClassMetadata"](SignModule, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"],
        args: [{
                imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"], _sigin_routing__WEBPACK_IMPORTED_MODULE_3__["SiginRoutes"], _common_label_common_module__WEBPACK_IMPORTED_MODULE_4__["LabelCommonModule"], src_app_shared_shared_module__WEBPACK_IMPORTED_MODULE_6__["SharedModule"]],
                declarations: [
                    _label_add_base_info_base_info_component__WEBPACK_IMPORTED_MODULE_8__["BaseInfoComponent"],
                    _sign_component__WEBPACK_IMPORTED_MODULE_2__["SignComponent"],
                    _label_search_label_search_component__WEBPACK_IMPORTED_MODULE_5__["LabelSearchComponent"],
                    _label_add_label_add_component__WEBPACK_IMPORTED_MODULE_7__["LabelAddComponent"],
                    _label_add_label_feature_label_feature_component__WEBPACK_IMPORTED_MODULE_9__["LabelFeatureComponent"],
                    _edit_tool_edit_tool_component__WEBPACK_IMPORTED_MODULE_10__["EditToolComponent"],
                    _label_add_label_feature_addTagIcon_pipe__WEBPACK_IMPORTED_MODULE_12__["AddTagIconPipe"],
                    _label_add_label_success_label_success_component__WEBPACK_IMPORTED_MODULE_13__["LabelSuccessComponent"],
                    _label_add_add_content_add_content_component__WEBPACK_IMPORTED_MODULE_15__["AddContentComponent"],
                    _label_detail_label_detail_component__WEBPACK_IMPORTED_MODULE_16__["LabelDetailComponent"],
                    _label_detail_label_detail_content_label_detail_content_component__WEBPACK_IMPORTED_MODULE_17__["LabelDetailContentComponent"],
                    _label_detail_feature_detail_feature_detail_component__WEBPACK_IMPORTED_MODULE_18__["FeatureDetailComponent"],
                    _label_detail_label_comment_label_comment_component__WEBPACK_IMPORTED_MODULE_19__["LabelCommentComponent"],
                    _label_detail_label_baseinfo_label_baseinfo_component__WEBPACK_IMPORTED_MODULE_20__["LabelBaseinfoComponent"],
                    _label_legend_label_legend_component__WEBPACK_IMPORTED_MODULE_21__["LabelLegendComponent"]
                ],
                providers: [_services_edit_tool_service__WEBPACK_IMPORTED_MODULE_11__["EditToolService"], _sign_service__WEBPACK_IMPORTED_MODULE_14__["SignService"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ApplicationRef"]],
                exports: [
                    _label_search_label_search_component__WEBPACK_IMPORTED_MODULE_5__["LabelSearchComponent"],
                    _label_detail_label_detail_component__WEBPACK_IMPORTED_MODULE_16__["LabelDetailComponent"]
                ]
            }]
    }], null, null); })();
_angular_core__WEBPACK_IMPORTED_MODULE_0__["setComponentScope"](_sign_component__WEBPACK_IMPORTED_MODULE_2__["SignComponent"], [_angular_common__WEBPACK_IMPORTED_MODULE_1__["NgClass"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgComponentOutlet"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgForOf"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgIf"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgTemplateOutlet"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgStyle"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgSwitch"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgSwitchCase"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgSwitchDefault"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgPlural"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["NgPluralCase"], _angular_router__WEBPACK_IMPORTED_MODULE_22__["RouterOutlet"], _angular_router__WEBPACK_IMPORTED_MODULE_22__["RouterLink"], _angular_router__WEBPACK_IMPORTED_MODULE_22__["RouterLinkWithHref"], _angular_router__WEBPACK_IMPORTED_MODULE_22__["RouterLinkActive"], _angular_router__WEBPACK_IMPORTED_MODULE_22__["angular_packages_router_router_l"], _common_label_container_label_container_component__WEBPACK_IMPORTED_MODULE_23__["LabelContainerComponent"], _common_label_list_label_list_component__WEBPACK_IMPORTED_MODULE_24__["LabelListComponent"], _common_add_marker_statue_add_marker_statue_component__WEBPACK_IMPORTED_MODULE_25__["AddMarkerStatueComponent"], _common_counter_component_counter_component_component__WEBPACK_IMPORTED_MODULE_26__["CounterComponentComponent"], _common_form_tag_form_tag_component__WEBPACK_IMPORTED_MODULE_27__["FormTagComponent"], _common_tag_title_tag_title_component__WEBPACK_IMPORTED_MODULE_28__["TagTitleComponent"], ng_zorro_antd_menu__WEBPACK_IMPORTED_MODULE_29__["NzMenuDirective"], ng_zorro_antd_menu__WEBPACK_IMPORTED_MODULE_29__["NzMenuItemDirective"], ng_zorro_antd_menu__WEBPACK_IMPORTED_MODULE_29__["NzSubMenuComponent"], ng_zorro_antd_menu__WEBPACK_IMPORTED_MODULE_29__["NzMenuDividerDirective"], ng_zorro_antd_menu__WEBPACK_IMPORTED_MODULE_29__["NzMenuGroupComponent"], ng_zorro_antd_dropdown__WEBPACK_IMPORTED_MODULE_30__["NzDropDownDirective"], ng_zorro_antd_dropdown__WEBPACK_IMPORTED_MODULE_30__["NzDropDownADirective"], ng_zorro_antd_dropdown__WEBPACK_IMPORTED_MODULE_30__["NzDropdownMenuComponent"], ng_zorro_antd_dropdown__WEBPACK_IMPORTED_MODULE_30__["NzDropdownButtonDirective"], _angular_forms__WEBPACK_IMPORTED_MODULE_31__["angular_packages_forms_forms_y"], _angular_forms__WEBPACK_IMPORTED_MODULE_31__["NgSelectOption"], _angular_forms__WEBPACK_IMPORTED_MODULE_31__["angular_packages_forms_forms_x"], _angular_forms__WEBPACK_IMPORTED_MODULE_31__["DefaultValueAccessor"], _angular_forms__WEBPACK_IMPORTED_MODULE_31__["NumberValueAccessor"], _angular_forms__WEBPACK_IMPORTED_MODULE_31__["RangeValueAccessor"], _angular_forms__WEBPACK_IMPORTED_MODULE_31__["CheckboxControlValueAccessor"], _angular_forms__WEBPACK_IMPORTED_MODULE_31__["SelectControlValueAccessor"], _angular_forms__WEBPACK_IMPORTED_MODULE_31__["SelectMultipleControlValueAccessor"], _angular_forms__WEBPACK_IMPORTED_MODULE_31__["RadioControlValueAccessor"], _angular_forms__WEBPACK_IMPORTED_MODULE_31__["NgControlStatus"], _angular_forms__WEBPACK_IMPORTED_MODULE_31__["NgControlStatusGroup"], _angular_forms__WEBPACK_IMPORTED_MODULE_31__["RequiredValidator"], _angular_forms__WEBPACK_IMPORTED_MODULE_31__["MinLengthValidator"], _angular_forms__WEBPACK_IMPORTED_MODULE_31__["MaxLengthValidator"], _angular_forms__WEBPACK_IMPORTED_MODULE_31__["PatternValidator"], _angular_forms__WEBPACK_IMPORTED_MODULE_31__["CheckboxRequiredValidator"], _angular_forms__WEBPACK_IMPORTED_MODULE_31__["EmailValidator"], _angular_forms__WEBPACK_IMPORTED_MODULE_31__["NgModel"], _angular_forms__WEBPACK_IMPORTED_MODULE_31__["NgModelGroup"], _angular_forms__WEBPACK_IMPORTED_MODULE_31__["NgForm"], _angular_forms__WEBPACK_IMPORTED_MODULE_31__["FormControlDirective"], _angular_forms__WEBPACK_IMPORTED_MODULE_31__["FormGroupDirective"], _angular_forms__WEBPACK_IMPORTED_MODULE_31__["FormControlName"], _angular_forms__WEBPACK_IMPORTED_MODULE_31__["FormGroupName"], _angular_forms__WEBPACK_IMPORTED_MODULE_31__["FormArrayName"], _shared_components_side_menu_side_menu_component__WEBPACK_IMPORTED_MODULE_32__["SideMenuComponent"], _shared_components_header_header_component__WEBPACK_IMPORTED_MODULE_33__["HeaderComponent"], _shared_components_cf_scroll_cf_scroll_component__WEBPACK_IMPORTED_MODULE_34__["CfScrollComponent"], ng_zorro_antd_input__WEBPACK_IMPORTED_MODULE_35__["NzInputDirective"], ng_zorro_antd_input__WEBPACK_IMPORTED_MODULE_35__["NzInputGroupComponent"], ng_zorro_antd_input__WEBPACK_IMPORTED_MODULE_35__["NzAutosizeDirective"], ng_zorro_antd_input__WEBPACK_IMPORTED_MODULE_35__["NzInputGroupWhitSuffixOrPrefixDirective"], ng_zorro_antd_tree__WEBPACK_IMPORTED_MODULE_36__["NzTreeComponent"], ng_zorro_antd_tree__WEBPACK_IMPORTED_MODULE_36__["NzTreeNodeComponent"], ng_zorro_antd_tree__WEBPACK_IMPORTED_MODULE_36__["NzTreeIndentComponent"], ng_zorro_antd_layout__WEBPACK_IMPORTED_MODULE_37__["NzLayoutComponent"], ng_zorro_antd_layout__WEBPACK_IMPORTED_MODULE_37__["NzHeaderComponent"], ng_zorro_antd_layout__WEBPACK_IMPORTED_MODULE_37__["NzContentComponent"], ng_zorro_antd_layout__WEBPACK_IMPORTED_MODULE_37__["NzFooterComponent"], ng_zorro_antd_layout__WEBPACK_IMPORTED_MODULE_37__["NzSiderComponent"], ng_zorro_antd_icon__WEBPACK_IMPORTED_MODULE_38__["NzIconDirective"], ng_zorro_antd_breadcrumb__WEBPACK_IMPORTED_MODULE_39__["NzBreadCrumbComponent"], ng_zorro_antd_breadcrumb__WEBPACK_IMPORTED_MODULE_39__["NzBreadCrumbItemComponent"], ng_zorro_antd_breadcrumb__WEBPACK_IMPORTED_MODULE_39__["NzBreadCrumbSeparatorComponent"], ng_zorro_antd_button__WEBPACK_IMPORTED_MODULE_40__["NzButtonComponent"], ng_zorro_antd_button__WEBPACK_IMPORTED_MODULE_40__["NzButtonGroupComponent"], ng_zorro_antd_core_transition_patch__WEBPACK_IMPORTED_MODULE_41__["NzTransitionPatchDirective"], ng_zorro_antd_core_wave__WEBPACK_IMPORTED_MODULE_42__["NzWaveDirective"], ng_zorro_antd_pagination__WEBPACK_IMPORTED_MODULE_43__["NzPaginationComponent"], ng_zorro_antd_select__WEBPACK_IMPORTED_MODULE_44__["NzOptionComponent"], ng_zorro_antd_select__WEBPACK_IMPORTED_MODULE_44__["NzSelectComponent"], ng_zorro_antd_select__WEBPACK_IMPORTED_MODULE_44__["NzOptionGroupComponent"], ng_zorro_antd_select__WEBPACK_IMPORTED_MODULE_44__["NzSelectArrowComponent"], ng_zorro_antd_select__WEBPACK_IMPORTED_MODULE_44__["NzSelectClearComponent"], ng_zorro_antd_select__WEBPACK_IMPORTED_MODULE_44__["NzSelectItemComponent"], ng_zorro_antd_select__WEBPACK_IMPORTED_MODULE_44__["NzSelectPlaceholderComponent"], ng_zorro_antd_select__WEBPACK_IMPORTED_MODULE_44__["NzSelectSearchComponent"], ng_zorro_antd_date_picker__WEBPACK_IMPORTED_MODULE_45__["NzDatePickerComponent"], ng_zorro_antd_date_picker__WEBPACK_IMPORTED_MODULE_45__["NzRangePickerComponent"], ng_zorro_antd_date_picker__WEBPACK_IMPORTED_MODULE_45__["NzMonthPickerComponent"], ng_zorro_antd_date_picker__WEBPACK_IMPORTED_MODULE_45__["NzYearPickerComponent"], ng_zorro_antd_date_picker__WEBPACK_IMPORTED_MODULE_45__["NzWeekPickerComponent"], ng_zorro_antd_grid__WEBPACK_IMPORTED_MODULE_46__["NzColDirective"], ng_zorro_antd_grid__WEBPACK_IMPORTED_MODULE_46__["NzRowDirective"], ng_zorro_antd_form__WEBPACK_IMPORTED_MODULE_47__["NzFormDirective"], ng_zorro_antd_form__WEBPACK_IMPORTED_MODULE_47__["NzFormItemComponent"], ng_zorro_antd_form__WEBPACK_IMPORTED_MODULE_47__["NzFormLabelComponent"], ng_zorro_antd_form__WEBPACK_IMPORTED_MODULE_47__["NzFormControlComponent"], ng_zorro_antd_form__WEBPACK_IMPORTED_MODULE_47__["NzFormTextComponent"], ng_zorro_antd_form__WEBPACK_IMPORTED_MODULE_47__["NzFormSplitComponent"], ng_zorro_antd_radio__WEBPACK_IMPORTED_MODULE_48__["NzRadioComponent"], ng_zorro_antd_radio__WEBPACK_IMPORTED_MODULE_48__["NzRadioButtonDirective"], ng_zorro_antd_radio__WEBPACK_IMPORTED_MODULE_48__["NzRadioGroupComponent"], ng_zorro_antd_tag__WEBPACK_IMPORTED_MODULE_49__["NzTagComponent"], ng_zorro_antd_cascader__WEBPACK_IMPORTED_MODULE_50__["NzCascaderComponent"], ng_zorro_antd_popconfirm__WEBPACK_IMPORTED_MODULE_51__["NzPopconfirmComponent"], ng_zorro_antd_popconfirm__WEBPACK_IMPORTED_MODULE_51__["NzPopconfirmDirective"], ng_zorro_antd_switch__WEBPACK_IMPORTED_MODULE_52__["NzSwitchComponent"], ng_zorro_antd_modal__WEBPACK_IMPORTED_MODULE_53__["NzModalComponent"], ng_zorro_antd_modal__WEBPACK_IMPORTED_MODULE_53__["NzModalFooterDirective"], _label_add_base_info_base_info_component__WEBPACK_IMPORTED_MODULE_8__["BaseInfoComponent"],
    _sign_component__WEBPACK_IMPORTED_MODULE_2__["SignComponent"],
    _label_search_label_search_component__WEBPACK_IMPORTED_MODULE_5__["LabelSearchComponent"],
    _label_add_label_add_component__WEBPACK_IMPORTED_MODULE_7__["LabelAddComponent"],
    _label_add_label_feature_label_feature_component__WEBPACK_IMPORTED_MODULE_9__["LabelFeatureComponent"],
    _edit_tool_edit_tool_component__WEBPACK_IMPORTED_MODULE_10__["EditToolComponent"],
    _label_add_label_success_label_success_component__WEBPACK_IMPORTED_MODULE_13__["LabelSuccessComponent"],
    _label_add_add_content_add_content_component__WEBPACK_IMPORTED_MODULE_15__["AddContentComponent"],
    _label_detail_label_detail_component__WEBPACK_IMPORTED_MODULE_16__["LabelDetailComponent"],
    _label_detail_label_detail_content_label_detail_content_component__WEBPACK_IMPORTED_MODULE_17__["LabelDetailContentComponent"],
    _label_detail_feature_detail_feature_detail_component__WEBPACK_IMPORTED_MODULE_18__["FeatureDetailComponent"],
    _label_detail_label_comment_label_comment_component__WEBPACK_IMPORTED_MODULE_19__["LabelCommentComponent"],
    _label_detail_label_baseinfo_label_baseinfo_component__WEBPACK_IMPORTED_MODULE_20__["LabelBaseinfoComponent"],
    _label_legend_label_legend_component__WEBPACK_IMPORTED_MODULE_21__["LabelLegendComponent"]], [_angular_common__WEBPACK_IMPORTED_MODULE_1__["AsyncPipe"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["UpperCasePipe"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["LowerCasePipe"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["JsonPipe"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["SlicePipe"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["DecimalPipe"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["PercentPipe"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["TitleCasePipe"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["CurrencyPipe"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["DatePipe"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["I18nPluralPipe"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["I18nSelectPipe"], _angular_common__WEBPACK_IMPORTED_MODULE_1__["KeyValuePipe"], _label_add_label_feature_addTagIcon_pipe__WEBPACK_IMPORTED_MODULE_12__["AddTagIconPipe"]]);


/***/ }),

/***/ "./src/app/business/geo-label/sign/sign.service.ts":
/*!*********************************************************!*\
  !*** ./src/app/business/geo-label/sign/sign.service.ts ***!
  \*********************************************************/
/*! exports provided: SignService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SignService", function() { return SignService; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/__ivy_ngcc__/fesm5/core.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");
/* harmony import */ var _angular_common_http__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common/http */ "./node_modules/@angular/common/__ivy_ngcc__/fesm5/http.js");
/* harmony import */ var _services_cfhttp_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../services/cfhttp.service */ "./src/app/services/cfhttp.service.ts");





var needToken = new _angular_common_http__WEBPACK_IMPORTED_MODULE_2__["HttpHeaders"]().set('needToken', 'true');
var SignService = /** @class */ (function () {
    function SignService(cfHttp) {
        this.cfHttp = cfHttp;
    }
    /**
     * 
     * @param body
     */
    SignService.prototype.addTag = function (body) {
        return this.cfHttp.post('add.tag', body, {
            headers: needToken
        }).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["map"])(function (res) { return res.data; }));
    };
    /**
     * 
     * @param body
     */
    SignService.prototype.editTag = function (body) {
        return this.cfHttp.post('edit.tag', body, {
            headers: needToken
        }).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["map"])(function (res) { return res.data; }));
    };
    /**
     * 
     * @param params
     */
    SignService.prototype.getTagList = function (params) {
        return this.cfHttp.get('get.tags', {
            params: params,
            headers: needToken
        }).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["map"])(function (res) { return res.data; }));
    };
    SignService.prototype.getAllTagListPoint = function (params) {
        return this.cfHttp.get('get.tags', {
            params: params,
            headers: needToken
        }).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["map"])(function (res) { return res.data; }));
    };
    /**
     * 
     * @param params
     */
    SignService.prototype.getTagDetail = function (params) {
        return this.cfHttp.get('get.taginfo', {
            params: params,
            headers: needToken
        }).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["map"])(function (res) { return res.data; }));
    };
    /**
     * 
     * @param params
     */
    SignService.prototype.deleteTag = function (params) {
        return this.cfHttp.delete('delete.tag', {
            params: params,
            headers: needToken
        }).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["map"])(function (res) { return res.data; }));
    };
    /**
     *  
     * @param params
     */
    SignService.prototype.toggleSub = function (body) {
        return this.cfHttp.post('toggle.sub', body, {
            headers: needToken
        }).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["map"])(function (res) { return res.data; }));
    };
    /**
     *  
     * @param params
     */
    SignService.prototype.getClassifyTree = function (params) {
        return this.cfHttp.get('classify.tree', {
            params: params,
            headers: needToken
        }).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["map"])(function (res) { return res.data; }));
    };
    /**
    * 
    * @param params
    */
    SignService.prototype.getCollectList = function (params) {
        return this.cfHttp.get('collect.list', {
            params: params,
            headers: needToken
        }).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["map"])(function (res) { return res.data; }));
    };
    SignService.prototype.getAllCollecPoint = function (params) {
        return this.cfHttp.get('collect.list', {
            params: params,
            headers: needToken
        }).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["map"])(function (res) { return res.data; }));
    };
    SignService.fac = function SignService_Factory(t) { return new (t || SignService)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["inject"](_services_cfhttp_service__WEBPACK_IMPORTED_MODULE_3__["CfhttpService"])); };
    SignService.prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["defineInjectable"]({ token: SignService, factory: SignService.fac, providedIn: 'root' });
    return SignService;
}());

/*@__PURE__*/ (function () { _angular_core__WEBPACK_IMPORTED_MODULE_0__["setClassMetadata"](SignService, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"],
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: _services_cfhttp_service__WEBPACK_IMPORTED_MODULE_3__["CfhttpService"] }]; }, null); })();


/***/ }),

/***/ "./src/app/business/geo-label/sign/styles/style.ts":
/*!*********************************************************!*\
  !*** ./src/app/business/geo-label/sign/styles/style.ts ***!
  \*********************************************************/
/*! exports provided: getSageNationTagsStyle, getAllTagsStyle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSageNationTagsStyle", function() { return getSageNationTagsStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAllTagsStyle", function() { return getAllTagsStyle; });
function getSageNationTagsStyle(layerid, geoSource) {
    return {
        'id': layerid,
        'type': 'symbol',
        'source': {
            'type': 'geojson',
            'data': geoSource
        },
        'layout': {
            'icon-image': layerid,
            'icon-size': 1,
            'text-field': ['get', 'index'],
            'text-font': ['MicrosoftYaHeiRegular'],
            'text-offset': [0, -.3],
            'text-anchor': 'center',
            "icon-allow-overlap": true
        },
        'paint': {
            'text-color': '#fff'
        },
    };
}
function getAllTagsStyle(layerid, geoSource) {
    return {
        'id': layerid,
        'type': 'symbol',
        'source': {
            'type': 'geojson',
            'data': geoSource
        },
        'layout': {
            'icon-image': layerid,
            'icon-size': 1,
            //'text-field': ['get','index'],
            // 'text-font': ['MicrosoftYaHeiRegular'],
            //  'text-offset': [0, -.3],
            //   'text-anchor':'center',
            "icon-allow-overlap": true
        },
        'paint': {
        // 'text-color': '#fff'
        },
    };
}


/***/ }),

/***/ "./src/app/business/geo-label/utils/main-format.ts":
/*!*********************************************************!*\
  !*** ./src/app/business/geo-label/utils/main-format.ts ***!
  \*********************************************************/
/*! exports provided: sourceTagToParams, tagDetailToSourceTagInfo, listWktToGeoJson, wktToGeoJson */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sourceTagToParams", function() { return sourceTagToParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tagDetailToSourceTagInfo", function() { return tagDetailToSourceTagInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listWktToGeoJson", function() { return listWktToGeoJson; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wktToGeoJson", function() { return wktToGeoJson; });
/* harmony import */ var wellknown__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! wellknown */ "./node_modules/wellknown/index.js");
/* harmony import */ var wellknown__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(wellknown__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);


/**
 * 
 * @param geo 
 * @param source 
 */
function sourceTagToParams(geo, source) {
    var _a = Object(lodash__WEBPACK_IMPORTED_MODULE_1__["cloneDeep"])(source), baseInfo = _a.baseInfo, graphs = _a.graphs;
    baseInfo.categoryid = baseInfo.categoryid ? baseInfo.categoryid.toString() : '';
    baseInfo.taginfos = baseInfo.taginfos.toString();
    baseInfo.geom = "Point(" + geo[0] + " " + geo[1] + ")";
    baseInfo.ispublic = +baseInfo.ispublic;
    var feature = [];
    graphs.forEach(function (item) {
        feature.push({
            title: item.title,
            desc: item.des,
            geotype: item.type,
            geom: Object(wellknown__WEBPACK_IMPORTED_MODULE_0__["stringify"])(item.feature)
        });
    });
    baseInfo['graphs'] = feature;
    return baseInfo;
}
function tagDetailToSourceTagInfo(tagDetailInfo) {
    var title = tagDetailInfo.title, taginfos = tagDetailInfo.taginfos, ispublic = tagDetailInfo.ispublic, desc = tagDetailInfo.desc, categoryid = tagDetailInfo.categoryid, graphs = tagDetailInfo.graphs;
    var baseInfo = {
        title: title,
        taginfos: taginfos ? taginfos.split(',') : [],
        ispublic: ispublic.toString(),
        desc: desc,
        categoryid: taginfos ? categoryid.split(',') : [],
    };
    var list = [];
    if (graphs) {
        graphs.forEach(function (item, index) {
            var geometry = Object(wellknown__WEBPACK_IMPORTED_MODULE_0__["parse"])(item.geom);
            list.push({
                icon: '',
                title: item.title,
                des: item.desc,
                type: item.geotype,
                feature: {
                    type: "Feature",
                    id: index,
                    geometry: geometry,
                    properties: {}
                }
            });
        });
    }
    return {
        baseInfo: baseInfo,
        graphs: list
    };
}
/**
 * wkt geoJson
 * @param wktList
 * @param wktField wkt
 */
function listWktToGeoJson(wktList, wktField) {
    var result = {
        "type": "FeatureCollection",
        features: []
    };
    if (wktList) {
        wktList.forEach(function (item, index) {
            item.index = (++index).toString();
            var wkt = item[wktField];
            var geometry = Object(wellknown__WEBPACK_IMPORTED_MODULE_0__["parse"])(wkt);
            // delete item[wktField];
            var feature = {
                type: 'feature',
                geometry: geometry,
                properties: item
            };
            result.features.push(feature);
        });
    }
    return result;
}
function wktToGeoJson(wkt) {
    return Object(wellknown__WEBPACK_IMPORTED_MODULE_0__["parse"])(wkt);
}


/***/ }),

/***/ "./src/app/business/geo-label/utils/mapTool.ts":
/*!*****************************************************!*\
  !*** ./src/app/business/geo-label/utils/mapTool.ts ***!
  \*****************************************************/
/*! exports provided: MarkerStatue, event_mousemove_key, event_click_key, event_draw_create, event_draw_delete, event_draw_update, offMapEvent, preventMapDefault */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MarkerStatue", function() { return MarkerStatue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "event_mousemove_key", function() { return event_mousemove_key; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "event_click_key", function() { return event_click_key; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "event_draw_create", function() { return event_draw_create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "event_draw_delete", function() { return event_draw_delete; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "event_draw_update", function() { return event_draw_update; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "offMapEvent", function() { return offMapEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "preventMapDefault", function() { return preventMapDefault; });
var MarkerStatue;
(function (MarkerStatue) {
    MarkerStatue[MarkerStatue["none"] = 0] = "none";
    MarkerStatue[MarkerStatue["moveing"] = 1] = "moveing";
    MarkerStatue[MarkerStatue["editing"] = 2] = "editing";
})(MarkerStatue || (MarkerStatue = {}));
var event_mousemove_key = 'map-mousemove';
var event_click_key = 'map-click';
var event_draw_create = 'draw.create';
var event_draw_delete = 'draw.delete';
var event_draw_update = 'draw.update';
function offMapEvent(map, type, eventKey, callfuns, layerid) {
    if (layerid) {
        map.off(type, layerid, callfuns[eventKey]);
    }
    else {
        map.off(type, callfuns[eventKey]);
    }
}
var preventMapDefault = function (e) {
    if (e.defaultPrevented) {
        return true;
    }
    e.preventDefault();
};


/***/ }),

/***/ 4:
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 5:
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

}]);
//# sourceMappingURL=sign-sign-module.js.map